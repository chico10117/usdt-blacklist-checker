2026-01-23T13:52:10.966235Z ERROR codex_core::skills::loader: failed to stat skills entry /Users/chiko/.codex/skills/dev-browser/profiles/browser-data/RunningChromeVersion (symlink): No such file or directory (os error 2)
2026-01-23T13:52:10.966429Z ERROR codex_core::skills::loader: failed to stat skills entry /Users/chiko/.codex/skills/dev-browser/profiles/browser-data/SingletonCookie (symlink): No such file or directory (os error 2)
2026-01-23T13:52:10.966433Z ERROR codex_core::skills::loader: failed to stat skills entry /Users/chiko/.codex/skills/dev-browser/profiles/browser-data/SingletonLock (symlink): No such file or directory (os error 2)
OpenAI Codex v0.89.0 (research preview)
--------
workdir: /Users/chiko/side_projects/usdt_blacklisted_web
model: gpt-5.2
provider: openai
approval: never
sandbox: danger-full-access
reasoning effort: high
reasoning summaries: auto
session id: 019beb20-730c-7ca2-9a04-890dc71efdd9
--------
user
# Build

You are an autonomous coding agent. Your task is to complete the work for exactly one story and record the outcome.

## Paths
- PRD: /Users/chiko/side_projects/usdt_blacklisted_web/.agents/tasks/prd-post-mvp.json
- AGENTS (optional): /Users/chiko/side_projects/usdt_blacklisted_web/AGENTS.md
- Progress Log: /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/progress.md
- Guardrails: /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/guardrails.md
- Guardrails Reference: /Users/chiko/side_projects/usdt_blacklisted_web/.agents/ralph/references/GUARDRAILS.md
- Context Reference: /Users/chiko/side_projects/usdt_blacklisted_web/.agents/ralph/references/CONTEXT_ENGINEERING.md
- Errors Log: /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/errors.log
- Activity Log: /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/activity.log
- Activity Logger: /Users/chiko/side_projects/usdt_blacklisted_web/ralph log
- No-commit: false
- Repo Root: /Users/chiko/side_projects/usdt_blacklisted_web
- Run ID: 20260123-135210-55147
- Iteration: 1
- Run Log: /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-135210-55147-iter-1.log
- Run Summary: /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-135210-55147-iter-1.md

## Global Quality Gates (apply to every story)
- pnpm lint
- pnpm test
- pnpm build

## Selected Story (Do not change scope)
ID: US-006
Title: [P2] Add Save Report flow (UI + API) gated by loggingEnabled

Story details:
### US-006: [P2] Add Save Report flow (UI + API) gated by loggingEnabled
Status: in_progress
Depends on: US-005

Description:
As an authenticated user who enabled saving, I want to save a specific analysis result so that I can refer to it later.

Acceptance Criteria:
- [ ] Add a server API route to create a SavedReport for the current user from a validated payload (address + report data).
- [ ] Enforce: saving is allowed only when authenticated AND loggingEnabled is true.
- [ ] Store `reportJson` plus summary fields (riskScore/riskTier/confidence/window) for fast listing and timeline views.
- [ ] Update the main analysis UI to show a `Save this report` control only when authenticated and loggingEnabled is enabled.
- [ ] Example: After running analysis, clicking Save creates a History entry and shows a success toast/state.
- [ ] Negative case: If loggingEnabled is false, Save is hidden/disabled and the API returns a clear error if called directly.


If the story details are empty or missing, STOP and report that the PRD story format could not be parsed.

## Rules (Non-Negotiable)
- Implement **only** the work required to complete the selected story.
- Complete all tasks associated with this story (and only this story).
- Do NOT ask the user questions.
- Do NOT change unrelated code.
- Do NOT assume something is unimplemented — confirm by reading code.
- Implement completely; no placeholders or stubs.
- If No-commit is true, do NOT commit or push changes.
- Do NOT edit the PRD JSON (status is handled by the loop).
- All changes made during the run must be committed (including updates to progress/logs).
 - Before committing, perform a final **security**, **performance**, and **regression** review of your changes.

## Your Task (Do this in order)
1. Read /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/guardrails.md before any code changes.
2. Read /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/errors.log for repeated failures to avoid.
3. Read /Users/chiko/side_projects/usdt_blacklisted_web/.agents/tasks/prd-post-mvp.json for global context (do not edit).
4. Fully audit and read all necessary files to understand the task end-to-end before implementing. Do not assume missing functionality.
5. If /Users/chiko/side_projects/usdt_blacklisted_web/AGENTS.md exists, follow its build/test instructions.
6. Implement only the tasks that belong to US-006.
7. Run verification commands listed in the story, the global quality gates, and in /Users/chiko/side_projects/usdt_blacklisted_web/AGENTS.md (if required).
8. If the project has a build or dev workflow, run what applies:
   - Build step (e.g., `npm run build`) if defined.
   - Dev server (e.g., `npm run dev`, `wrangler dev`) if it is the normal validation path.
   - Confirm no runtime/build errors in the console.
9. Perform a brief audit before committing:
   - **Security:** check for obvious vulnerabilities or unsafe handling introduced by your changes.
   - **Performance:** check for avoidable regressions (extra queries, heavy loops, unnecessary re-renders).
   - **Regression:** verify existing behavior that could be impacted still works.
10. If No-commit is false, commit changes using the `$commit` skill.
    - Stage everything: `git add -A`
    - Confirm a clean working tree after commit: `git status --porcelain` should be empty.
    - After committing, capture the commit hash and subject using:
      `git show -s --format="%h %s" HEAD`.
11. Append a progress entry to /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/progress.md with run/commit/test details (format below).
    If No-commit is true, skip committing and note it in the progress entry.

## Progress Entry Format (Append Only)
```
## [Date/Time] - US-006: [P2] Add Save Report flow (UI + API) gated by loggingEnabled
Thread: [codex exec session id if available, otherwise leave blank]
Run: 20260123-135210-55147 (iteration 1)
Run log: /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-135210-55147-iter-1.log
Run summary: /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-135210-55147-iter-1.md
- Guardrails reviewed: yes
- No-commit run: false
- Commit: <hash> <subject> (or `none` + reason)
- Post-commit status: `clean` or list remaining files
- Verification:
  - Command: <exact command> -> PASS/FAIL
  - Command: <exact command> -> PASS/FAIL
- Files changed:
  - <file path>
  - <file path>
- What was implemented
- **Learnings for future iterations:**
  - Patterns discovered
  - Gotchas encountered
  - Useful context
---
```

## Completion Signal
Only output the completion signal when the **selected story** is fully complete and verified.
When the selected story is complete, output:
<promise>COMPLETE</promise>

Otherwise, end normally without the signal.

## Additional Guardrails
- When authoring documentation, capture the why (tests + implementation intent).
- If you learn how to run/build/test the project, update /Users/chiko/side_projects/usdt_blacklisted_web/AGENTS.md briefly (operational only).
- Keep AGENTS operational only; progress notes belong in /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/progress.md.
- If you hit repeated errors, log them in /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/errors.log and add a Sign to /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/guardrails.md using /Users/chiko/side_projects/usdt_blacklisted_web/.agents/ralph/references/GUARDRAILS.md as the template.

## Activity Logging (Required)
Log major actions to /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/activity.log using the helper:
```
/Users/chiko/side_projects/usdt_blacklisted_web/ralph log "message"
```
Log at least:
- Start of work on the story
- After major code changes
- After tests/verification
- After updating progress log

## Browser Testing (Required for Frontend Stories)
If the selected story changes UI, you MUST verify it in the browser:
1. Load the `dev-browser` skill.
2. Navigate to the relevant page.
3. Verify the UI changes work as expected.
4. Take a screenshot if helpful for the progress log.

A frontend story is NOT complete until browser verification passes.

mcp startup: no servers

thinking
**Planning API development**

I’m looking at the API route in `src/app/api/history/route.ts` and thinking we need validators and tests. It sounds like adding unit tests for the API route will be essential, and I could test both the library function and the route itself. I’ll also run lint/test/build and verify with the dev-browser skill, so I need to read the SKILL.md. The next step is to plan with update_plan and focus on required reads and logs through the shell.
Plan update
  → Review guardrails and logs
  • Audit existing auth/logging/report code
  • Implement save-report API route
  • Add UI save control and toast
  • Add tests for save flow
  • Run lint, test, build
  • Browser-verify save control
  • Security/perf/regression review, commit, log progress
exec
/bin/zsh -lc "sed -n '1,200p' .ralph/guardrails.md" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 55ms:
# Guardrails (Signs)

> Lessons learned from failures. Read before acting.

## Core Signs

### Sign: Read Before Writing
- **Trigger**: Before modifying any file
- **Instruction**: Read the file first
- **Added after**: Core principle

### Sign: Test Before Commit
- **Trigger**: Before committing changes
- **Instruction**: Run required tests and verify outputs
- **Added after**: Core principle

---

## Learned Signs
### Sign: Never Kill Ralph Tee
exec
/bin/zsh -lc 'cat .ralph/errors.log || true' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 52ms:
# Error Log

> Failures and repeated issues. Use this to add guardrails.

[2026-01-23 04:55:57] ITERATION 1 left uncommitted changes; review run summary at /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-044356-6274-iter-1.md
[2026-01-23 05:11:56] ITERATION 2 left uncommitted changes; review run summary at /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-044356-6274-iter-2.md
[2026-01-23 05:30:23] ITERATION 3 left uncommitted changes; review run summary at /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-044356-6274-iter-3.md
[2026-01-23 05:48:31] ITERATION 4 left uncommitted changes; review run summary at /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-044356-6274-iter-4.md
exec
/bin/zsh -lc 'cat .agents/tasks/prd-post-mvp.json' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 63ms:
{
  "version": 1,
  "project": "TRON USDT Screening \u2014 Complete Remaining PRD Tasks (P2\u2013P4)",
  "overview": "This PRD translates the remaining unchecked items in PRD.md (P2 opt-in report saving, P3 authenticated dashboard UX upgrades, and P4 credits/packaging) into small, implementable stories for the existing Next.js + Clerk codebase. Privacy-first defaults remain: no address logging unless an authenticated user explicitly opts in.",
  "goals": [
    "Add persistent, privacy-first opt-in report saving (history + deletion) for authenticated users.",
    "Add a post-login dashboard shell with dedicated screens (Overview, History, Watchlist, Settings).",
    "Add wallet visuals (balance/flows) and charts with evidence links and time-window controls.",
    "Document and scaffold future credits/billing/workspace/export capabilities without breaking current free flows."
  ],
  "nonGoals": [
    "Multi-chain support (TRON-only).",
    "Batch screening (single address only).",
    "Automated accept/reject recommendations (findings only).",
    "Requiring users to provide private keys/seed phrases.",
    "Logging or analytics that include raw addresses by default."
  ],
  "successMetrics": [
    "Authenticated users can enable saving, save a report, view it in History, and delete it (single and all) with default-off privacy behavior.",
    "Dashboard routes are accessible post-login and unauthenticated access is blocked/redirected.",
exec
/bin/zsh -lc 'ls -la' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 53ms:
total 2928
drwxr-xr-x@ 37 chiko  staff     1184 Jan 23 05:13 .
drwxr-xr-x@ 11 chiko  staff      352 Jan 21 18:51 ..
drwxr-xr-x@  4 chiko  staff      128 Jan 23 04:36 .agents
drwxr-xr-x@  3 chiko  staff       96 Jan 21 23:12 .clerk
-rw-r--r--@  1 chiko  staff     8196 Jan 21 19:22 .DS_Store
-rw-r--r--@  1 chiko  staff      461 Jan 22 13:07 .env
-rw-r--r--@  1 chiko  staff      544 Jan 23 04:47 .env.example
drwxr-xr-x@ 12 chiko  staff      384 Jan 23 13:49 .git
-rw-r--r--@  1 chiko  staff      567 Jan 23 05:08 .gitignore
drwxr-xr-x@ 25 chiko  staff      800 Jan 23 05:59 .next
drwxr-xr-x@  8 chiko  staff      256 Jan 23 06:01 .ralph
-rw-r--r--@  1 chiko  staff     2483 Jan 23 04:02 AGENTS.md
-rw-r--r--@  1 chiko  staff     1453 Jan 21 18:26 check-usdt-blacklist.js
-rw-r--r--@  1 chiko  staff     3562 Jan 22 12:40 CLAUDE.md
drwxr-xr-x@ 13 chiko  staff      416 Jan 22 01:07 coverage
drwxr-xr-x@  4 chiko  staff      128 Jan 23 05:03 docs
-rw-r--r--@  1 chiko  staff      264 Jan 23 05:00 drizzle.config.ts
-rw-r--r--@  1 chiko  staff      484 Jan 22 12:25 eslint.config.mjs
-rw-r--r--@  1 chiko  staff     1394 Jan 22 12:32 GPT.md
exec
/bin/zsh -lc './ralph log "Start US-006: implement save report flow gated by loggingEnabled"' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 87ms:

Plan update
  ✓ Review guardrails and logs
  → Audit existing auth/logging/report code
  • Implement save-report API route
  • Add UI save control and toast
  • Add tests for save flow
  • Run lint, test, build
  • Browser-verify save control
  • Security/perf/regression review, commit, log progress
exec
/bin/zsh -lc "sed -n '1,200p' AGENTS.md" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 112ms:
# Repository Guidelines

## Project Structure & Module Organization

- `src/app/`: Next.js App Router pages and API routes (e.g. `src/app/api/check/route.ts`, `src/app/api/analyze/route.ts`).
- `src/lib/`: Core screening logic (TRON/TronScan clients, sanctions screening, AML heuristics/scoring, validators). Unit tests are co-located as `*.test.ts`.
- `src/components/`: Reusable UI components (Tailwind CSS + shadcn/ui-style components).
- `src/data/`: Cached datasets (e.g. `src/data/ofac-tron-addresses.json`).
- `scripts/`: Maintenance scripts (e.g. OFAC dataset fetcher).
- `public/`: Static assets.

## Build, Test, and Development Commands

- `pnpm dev`: Run the local dev server at `http://localhost:3000`.
- `pnpm build` / `pnpm start`: Production build and run.
- `pnpm lint`: Run ESLint (Next.js core-web-vitals + TypeScript rules).
- `pnpm test`: Run Vitest once (Node environment).
- `pnpm test:watch`: Run tests in watch mode.
- `pnpm test:coverage`: Generate coverage output in `coverage/`.
- `pnpm ofac:update`: Refresh `src/data/ofac-tron-addresses.json` (requires network access).
exec
/bin/zsh -lc "ls -R src/app | sed -n '1,200p'" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 53ms:
(dashboard)
api
favicon.ico
globals.css
layout.tsx
page.tsx
sign-in
sign-up

src/app/(dashboard):
layout.tsx
settings

src/app/(dashboard)/settings:
page.tsx
settings-client.tsx

src/app/api:
analyze
check
exec
/bin/zsh -lc "rg -n \"loggingEnabled|UserSettings|SavedReport|reportJson|history\" -S src | sed -n '1,200p'" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 58ms:
src/__tests__/api-user-settings.test.ts:9:const getUserSettings = vi.fn();
src/__tests__/api-user-settings.test.ts:10:const upsertUserSettings = vi.fn();
src/__tests__/api-user-settings.test.ts:11:vi.mock("@/lib/db/user-settings", () => ({ getUserSettings, upsertUserSettings }));
src/__tests__/api-user-settings.test.ts:46:    expect(getUserSettings).not.toHaveBeenCalled();
src/__tests__/api-user-settings.test.ts:49:  it("returns loggingEnabled=false when no row exists (default)", async () => {
src/__tests__/api-user-settings.test.ts:52:    getUserSettings.mockResolvedValue(null);
src/__tests__/api-user-settings.test.ts:56:    expect(json.loggingEnabled).toBe(false);
src/__tests__/api-user-settings.test.ts:58:    expect(upsertUserSettings).not.toHaveBeenCalled();
src/__tests__/api-user-settings.test.ts:64:    const { res } = await callPatch({ loggingEnabled: true });
src/__tests__/api-user-settings.test.ts:67:    expect(upsertUserSettings).not.toHaveBeenCalled();
src/__tests__/api-user-settings.test.ts:70:  it("persists loggingEnabled via PATCH and returns the updated setting", async () => {
src/__tests__/api-user-settings.test.ts:73:    upsertUserSettings.mockResolvedValue({ loggingEnabled: true });
src/__tests__/api-user-settings.test.ts:75:    const { res, json } = await callPatch({ loggingEnabled: true });
src/__tests__/api-user-settings.test.ts:77:    expect(json.loggingEnabled).toBe(true);
src/__tests__/api-user-settings.test.ts:79:    expect(upsertUserSettings).toHaveBeenCalledWith({}, "user_123", true);
src/app/api/analyze/route.ts:386:        notices.push("USDT transfer history could not be fetched.");
src/components/blacklist-checker.tsx:863:                    Configure privacy defaults and opt in to saving screening history.
src/components/blacklist-checker.tsx:868:                    <div className="text-sm font-medium text-foreground">Privacy &amp; history</div>
src/components/blacklist-checker.tsx:870:                      Saving screening history is off by default. Manage this in Settings.
src/app/(dashboard)/settings/settings-client.tsx:11:type UserSettingsResponse =
exec
/bin/zsh -lc "ls -R src/lib | sed -n '1,200p'" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 58ms:
aml.test.ts
aml.ts
cache.ts
db
entity.test.ts
entity.ts
exposure.test.ts
exposure.ts
heuristics.test.ts
heuristics.ts
i18n.ts
sanctions.test.ts
sanctions.ts
tron.ts
tronscan.ts
utils.ts
validators.ts
vitest-server-only.ts

src/lib/db:
exec
/bin/zsh -lc "sed -n '1,220p' src/lib/db/schema.ts" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 78ms:
import { boolean, index, integer, jsonb, pgTable, text, timestamp, uuid } from "drizzle-orm/pg-core";

export const userSettings = pgTable("user_settings", {
  userId: text("user_id").primaryKey(),
  loggingEnabled: boolean("logging_enabled").notNull().default(false),
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(),
});

export const savedReports = pgTable(
  "saved_reports",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    userId: text("user_id")
      .notNull()
      .references(() => userSettings.userId, { onDelete: "cascade" }),
    address: text("address").notNull(),
    addressHash: text("address_hash").notNull(),
    riskScore: integer("risk_score").notNull(),
    riskTier: text("risk_tier").notNull(),
exec
/bin/zsh -lc "sed -n '1,140p' src/lib/db/saved-reports.ts" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 59ms:
import "server-only";

import { and, desc, eq } from "drizzle-orm";

import type { DbClient } from "@/lib/db";
import { computeAddressHash } from "@/lib/db/address-hash";
import { schema } from "@/lib/db";

export type SavedReportCreateInput = {
  address: string;
  riskScore: number;
  riskTier: string;
  confidence: number;
  window: unknown;
  reportJson: unknown;
};

export function buildGetSavedReportByIdQuery(db: DbClient, userId: string, reportId: string) {
  return db
    .select()
exec
/bin/zsh -lc "sed -n '1,120p' src/lib/db/index.ts" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 82ms:
import "server-only";

import postgres from "postgres";
import { drizzle } from "drizzle-orm/postgres-js";

import * as schema from "@/lib/db/schema";

export type DbClient = ReturnType<typeof createDbClient>;

function createDbClient(databaseUrl: string) {
  const sql = postgres(databaseUrl, {
    max: process.env.NODE_ENV === "production" ? 10 : 1,
  });

  return drizzle(sql, { schema });
}

const globalForDb = globalThis as unknown as {
  dbClient?: DbClient;
};
exec
/bin/zsh -lc "sed -n '1,140p' src/app/api/user-settings/route.ts" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 45ms:
import { NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import { z } from "zod";

import { getDb } from "@/lib/db";
import { getUserSettings, upsertUserSettings } from "@/lib/db/user-settings";

export const runtime = "nodejs";

const UpdateUserSettingsSchema = z.object({
  loggingEnabled: z.boolean(),
});

async function getAuthenticatedUserId(): Promise<string | null> {
  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
  try {
    const { userId } = await auth();
    return userId ?? null;
  } catch {
    return null;
exec
/bin/zsh -lc "rg -n \"auth\\(|currentUser\\(|clerk|userId\" src/app/api src/middleware.ts src/app/(dashboard) -S" in /Users/chiko/side_projects/usdt_blacklisted_web exited 1 in 53ms:
zsh:1: number expected
exec
/bin/zsh -lc "sed -n '1,220p' middleware.ts" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 53ms:
import { NextResponse } from "next/server";
import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";

const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);

const isPublicRoute = createRouteMatcher([
  "/",
  "/api/check",
  "/api/analyze",
  "/api/user-settings",
  "/sign-in(.*)",
  "/sign-up(.*)",
]);

const clerk = clerkMiddleware((auth, req) => {
  if (isPublicRoute(req)) return;
  return auth().then(({ userId, redirectToSignIn }) => {
    if (!userId) return redirectToSignIn();
    return undefined;
  });
exec
/bin/zsh -lc "sed -n '1,220p' src/components/blacklist-checker.tsx" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 57ms:
"use client";

import * as React from "react";
import Image from "next/image";
import Link from "next/link";
import { AnimatePresence, motion } from "framer-motion";
import { SignedIn, SignedOut, SignInButton, UserButton, useAuth } from "@clerk/nextjs";
import {
  AlertTriangle,
  CheckCircle2,
  ChevronRight,
  Copy,
  Check,
  ExternalLink,
  Info,
  Loader2,
  ShieldAlert,
  ShieldCheck,
  EyeOff,
} from "lucide-react";
exec
/bin/zsh -lc "sed -n '780,980p' src/components/blacklist-checker.tsx" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 44ms:
                  </Button>
                  <div className="flex-1" />
                  <Button
                    type="button"
                    size="sm"
                    className="h-9 min-w-[100px] gap-2 shadow-md shadow-primary/20"
                    onClick={() => runCheck(normalizedAddress)}
                    disabled={load.state === "loading" || !normalizedAddress || (validation !== null && !validation.ok)}
                  >
                    {load.state === "loading" ? (
                      <>
                        <Loader2 className="h-4 w-4 animate-spin" />
                        <span>Checking</span>
                      </>
                    ) : (
                      <>
                        <span>{m.checkCta}</span>
                        <ChevronRight className="h-4 w-4" />
                      </>
                    )}
exec
/bin/zsh -lc "sed -n '1,120p' src/app/page.tsx" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 53ms:
import { BlacklistChecker } from "@/components/blacklist-checker";

export default function Home() {
  const jsonLd = {
    "@context": "https://schema.org",
    "@type": "FAQPage",
    mainEntity: [
      {
        "@type": "Question",
        name: "What does “blacklisted” mean for USDT on TRON?",
        acceptedAnswer: {
          "@type": "Answer",
          text: "The USDT smart contract can restrict addresses. If an address is blacklisted, USDT transfers from that address will likely revert on-chain.",
        },
      },
      {
        "@type": "Question",
        name: "Do you need my private key or seed phrase?",
        acceptedAnswer: {
          "@type": "Answer",
exec
/bin/zsh -lc "sed -n '1,220p' src/app/api/analyze/route.ts" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 53ms:
import { NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import { CheckRequestSchema } from "@/lib/validators";
import { readUsdtBlacklistStatusOnChain } from "@/lib/tron";
import { checkTronScanUsdtBlacklist } from "@/lib/tronscan";
import { checkOfacSanctions } from "@/lib/sanctions";
import { computeConfidencePercent, computeRiskScore, computeUsdtVolumeStats } from "@/lib/aml";
import { fetchTronScanAccountTag, fetchUsdtTrc20Transfers } from "@/lib/tronscan";
import { computeTopInboundCounterparties } from "@/lib/exposure";
import { computeFlowHeuristics } from "@/lib/heuristics";
import { getOrSetCache, sha256Key } from "@/lib/cache";
import { classifyEntityFromTagsAndTransfers } from "@/lib/entity";

export const runtime = "nodejs";

type Evidence = {
  contractAddress: string;
  txHash?: string;
  timestampIso?: string;
  method?: string;
exec
/bin/zsh -lc 'rg -n "riskScore|riskTier|confidence|window" src/app/api/analyze/route.ts src/components/blacklist-checker.tsx -n' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 68ms:
src/app/api/analyze/route.ts:42:          confidence: number; // 0..1
src/app/api/analyze/route.ts:62:          window: { lookbackDays: number };
src/app/api/analyze/route.ts:86:          window: { lookbackDays: number; topN: number; sampleK: number };
src/app/api/analyze/route.ts:177:        risk: { score: 0, tier: "low", confidence: 0, breakdown: [] },
src/app/api/analyze/route.ts:227:        risk: { score: 0, tier: "low", confidence: 0, breakdown: [] },
src/app/api/analyze/route.ts:324:        nowMs: transfers.window.toTsMs,
src/app/api/analyze/route.ts:336:        confidence: classified.confidence,
src/app/api/analyze/route.ts:369:        confidence: classified.confidence,
src/app/api/analyze/route.ts:381:        const stats = computeUsdtVolumeStats(transfers.transfers, address, transfers.window.toTsMs);
src/app/api/analyze/route.ts:392:      const inbound = computeTopInboundCounterparties(transfers.transfers, address, { lookbackDays: 90, topN: 10, nowMs: transfers.window.toTsMs });
src/app/api/analyze/route.ts:431:      if (totalInbound === BigInt(0)) exposureNotices.push("No inbound USDT transfers found in the analyzed window.");
src/app/api/analyze/route.ts:436:        window: { lookbackDays: 90 },
src/app/api/analyze/route.ts:454:      const inbound = computeTopInboundCounterparties(transfers.transfers, address, { lookbackDays: 90, topN: 10, nowMs: transfers.window.toTsMs });
src/app/api/analyze/route.ts:462:        const sources = computeTopInboundCounterparties(viaTransfers.transfers, viaCounterparty, { lookbackDays: 90, topN: sampleK, nowMs: viaTransfers.window.toTsMs }).top;
src/app/api/analyze/route.ts:476:        window: { lookbackDays: 90, topN, sampleK },
src/app/api/analyze/route.ts:485:      heuristics = computeFlowHeuristics(transfers.transfers, address, { lookbackDays: 90, nowMs: transfers.window.toTsMs });
src/app/api/analyze/route.ts:501:    const partialSignals: Array<"pagination_limited" | "window_limited"> = [];
src/app/api/analyze/route.ts:504:    const confidencePercent = computeConfidencePercent({ lockedChecks, failedChecks, partialSignals });
src/app/api/analyze/route.ts:509:      confidencePercent,
src/components/blacklist-checker.tsx:74:          confidence: number; // 0..1
exec
/bin/zsh -lc "sed -n '220,580p' src/app/api/analyze/route.ts" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 74ms:
          entity: { ok: false, error: message },
          volume: { ok: false, error: message },
          exposure1hop: { ok: false, error: message },
          tracing2hop: { ok: false, error: message },
          heuristics: { ok: false, error: message },
        },
        consensus: { status: "inconclusive", match: false },
        risk: { score: 0, tier: "low", confidence: 0, breakdown: [] },
        timestamps: { checkedAtIso: new Date().toISOString() },
        notices: ["Provide a valid public TRON address (starts with “T”)."],
      } satisfies AnalyzeResponse,
      { status: 400, headers: { "Cache-Control": "no-store" } },
    );
  }

  const address = parsed.data.address;

  let authenticated = false;
  if (process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY) {
    try {
exec
/bin/zsh -lc 'rg -n "clerkEnabled" src/components/blacklist-checker.tsx' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 68ms:
515:  const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
637:          {clerkEnabled && (
656:        {clerkEnabled && (
659:              enabled={clerkEnabled}
851:        {clerkEnabled && (
exec
/bin/zsh -lc "sed -n '480,720p' src/components/blacklist-checker.tsx" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 67ms:
      </Card>
    </motion.div>
  );
}

/* ────────────────────────────────────────────────────────────────────────────
 * Scam Warning Alert
 * ──────────────────────────────────────────────────────────────────────────── */

function ScamWarningAlert() {
  return (
    <motion.div
      {...fadeInUp}
      transition={{ duration: 0.25, delay: 0.1 }}
      className="rounded-xl border border-red-200/60 bg-red-50/50 p-4 dark:border-red-500/20 dark:bg-red-950/30"
    >
      <div className="flex gap-3">
        <ShieldAlert className="h-5 w-5 shrink-0 text-red-600 dark:text-red-400" />
        <div>
          <p className="text-sm font-medium text-red-900 dark:text-red-100">Scam Warning</p>





thinking
**Considering user authentication and persistence**

It looks like BlacklistChecker is using Clerk for signing in, but the Save button should only appear when the user is logged in and logging is enabled. I need to fetch user settings from the API in the component, but there shouldn’t be a fetch on the main page. We'll implement a hook or fetch data once signed in.

Saving requires authentication, logging enabled, and persistence in the database, so I have to check the API response to ensure these conditions are met while designing the user interface.
thinking
**Implementing saved reports API**

I'm planning to implement the saved reports API in `src/app/api/saved-reports/route.ts`. This will involve parsing the request JSON using Zod to validate both the address and report data. I'll need to verify authentication through the Clerk server, similar to the user-settings route, and ensure there's a database present.

I'll utilize an existing function, `getUserSettings`, to check if logging is enabled. If there's no settings row, default it to logging being false, which means saving isn't allowed by default unless the user has been authenticated and enabled saving. Additionally, I want to confirm that the payload includes address and report data while validating certain fields in the report to maintain security.
thinking
**Validating payload for reports**

I need to check the validated payload, which includes the address and report data. I'll validate the address using either `validateTronAddress` or `CheckRequestSchema`, making sure it matches the report address. I plan to use `CheckRequestSchema` since it's already implemented in our validators.

Also, I’ll ensure that `report.address` matches the provided address and store a normalized version along with a summary that includes the risk score and risk tier. Using a Zod enum will help enforce valid options for the risk tier. 

Regarding the report window, I can pull from either `report.checks.exposure1hop.window` or `tracing2hop.window`. I think I’ll record the chosen value along with a fixed `lookbackDays` of 90, as it's used consistently for fast retrieval in the API.
thinking
**Storing parameters for reports**

I’m considering whether to store parameters like `{ lookbackDays: 90, maxPages: 20 }`. I need to check if `fetchUsdtTrc20Transfers` includes important timestamps in its response. From what I've seen, only the `exposure1hop` and `tracing2hop` windows are available for checks, while the volume check has separate windows without an explicit object.

So, I think I'll keep `{ lookbackDays: 90 }` and possibly add `checkedAtIso`. For the UI, I need to show the save control only when the user is signed in and logging is enabled. I’ll fetch user settings responsibly to avoid spamming, maintaining `userSettings` in the BlacklistChecker when the user is authenticated.
thinking
**Implementing user settings and save functionality**

I need to be careful with `GET /api/user-settings` since it requires authentication and will return a 401 error if the user is not signed in. I’ll call this API only when the user is authenticated and Clerk is enabled, using `useAuth` to check the signed-in status.

When the user is signed in and proper conditions are met, I'll fetch the settings. The Save button should only appear when the relevant states indicate success, including checking if logging is enabled and persistence is available. If persistent storage is disabled, we may choose to hide the button and display a subtle message instead. I want to ensure that the records are adequately handled, so I need to implement the API call for saving the report and managing potential errors by showing appropriate toast notifications. Also, I'll add Vitest tests for the new API route to ensure everything works smoothly!
exec
/bin/zsh -lc "sed -n '1,220p' src/__tests__/api-user-settings.test.ts" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 45ms:
import { beforeEach, describe, expect, it, vi } from "vitest";

const auth = vi.fn();
vi.mock("@clerk/nextjs/server", () => ({ auth }));

const getDb = vi.fn();
vi.mock("@/lib/db", () => ({ getDb }));

const getUserSettings = vi.fn();
const upsertUserSettings = vi.fn();
vi.mock("@/lib/db/user-settings", () => ({ getUserSettings, upsertUserSettings }));

async function callGet() {
  const { GET } = await import("@/app/api/user-settings/route");
  const res = await GET();
  const json = await res.json();
  return { res, json };
}

async function callPatch(body: unknown) {

thinking
**Validating risk values**

I need to validate risk values in the schema. The riskScore should be an integer, and computeRiskScore returns a score that could range from 0 to 100. The riskTier is a string, and confidence is an integer percentage between 0 and 100. I'll parse this information from reportJson. I'll make sure the risk score is converted to an integer using Math.round or floor, ensuring it stays within 0 to 100. I should check the computeRiskScore function for safety.
exec
/bin/zsh -lc "rg -n \"export function computeRiskScore\" -n src/lib/aml.ts && sed -n '1,220p' src/lib/aml.ts" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 68ms:
189:export function computeRiskScore(input: {
import type { NormalizedUsdtTransfer } from "@/lib/tronscan";
import { normalizeTronAddress } from "@/lib/validators";

const USDT_DECIMALS = BigInt(6);
const USDT_BASE = BigInt(10) ** USDT_DECIMALS;

function addThousandSeparators(whole: string): string {
  return whole.replace(/\B(?=(\d{3})+(?!\d))/g, ",");
}

export function formatUsdtFromBaseUnits(amountBaseUnits: bigint): string {
  const negative = amountBaseUnits < BigInt(0);
  const n = negative ? -amountBaseUnits : amountBaseUnits;
  const whole = n / USDT_BASE;
  const frac = n % USDT_BASE;
  const fracStr = frac.toString().padStart(Number(USDT_DECIMALS), "0").replace(/0+$/, "");
  const wholeStr = addThousandSeparators(whole.toString());
  const out = fracStr.length ? `${wholeStr}.${fracStr}` : wholeStr;
  return negative ? `-${out}` : out;
exec
/bin/zsh -lc "rg -n \"createSavedReport\\(|SavedReportCreateInput\" -S src" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 68ms:
src/lib/db/saved-reports.ts:9:export type SavedReportCreateInput = {
src/lib/db/saved-reports.ts:50:export async function createSavedReport(db: DbClient, userId: string, input: SavedReportCreateInput) {

thinking
**Planning UI updates**

I’m focused on setting up the Save functionality in the UI. After saving, I might use `const [saveState, setSaveState] = React.useState<"idle"|"saving"|"saved">` to keep track, possibly storing the `savedReportId`.

The Save button should be visible once certain conditions are met, like successful loading and user settings being enabled. I’ll ensure the button's placement is near the results, likely within the StatusBanner component, so I’ll look for its definition to find the best spot.
exec
/bin/zsh -lc 'rg -n "function StatusBanner" -n src/components/blacklist-checker.tsx' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 67ms:
331:function StatusBanner({ data }: { data: ApiResponse }) {
exec
/bin/zsh -lc "sed -n '300,480p' src/components/blacklist-checker.tsx" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 56ms:
  return (
    <div className="group flex items-start justify-between gap-3 py-2">
      <div className="min-w-0 flex-1">
        <div className="mb-0.5 text-xs font-medium text-muted-foreground">{label}</div>
        {href ? (
          <a
            href={href}
            target="_blank"
            rel="noreferrer"
            className={`${textClasses} inline-flex items-center gap-1.5 break-all text-foreground underline decoration-muted-foreground/30 underline-offset-4 transition-colors hover:decoration-primary`}
          >
            {displayValue}
            <ExternalLink className="h-3 w-3 shrink-0 text-muted-foreground" />
          </a>
        ) : (
          <div className={`${textClasses} break-all text-foreground`}>{displayValue}</div>
        )}
      </div>
      {copyValue && (
        <div className="opacity-0 transition-opacity group-hover:opacity-100">


thinking
**Planning interface adjustments**

I’m realizing that the StatusBanner doesn’t currently have actions, so I’ll consider adding a Save button in the success section. It might make sense to put it on the same line, wrapping it in a flex layout with the save control on the right. To minimize changes, I’m thinking about adjusting the display of `<StatusBanner data={load.data} />` and maybe placing a `SaveReportControl` component next to it.  
However, given that the StatusBanner is full width, I could also add a small card or button group above the results, perhaps like this:   

```  
{canSaveReport && (  
  <motion.div {...fadeInUp} ...>  
    <Card ...>  
      <CardContent ...> <Button ...>Save this report</Button> ...</CardContent>  
  </motion.div>  
)}  
```  

Acceptance says to show the Save control, but it doesn't specify where. I’m thinking to place it below the StatusBanner and before the Summary Card. Also, I need to gate this by authentication: `load.data.access.authenticated` will show if the server recognizes the user as authenticated, but I wonder if the initial run could occur before sign in via Clerk.
thinking
**Implementing user authentication**

After the user signs in, I’ll automatically rerun the fetch with authentication, ensuring that `access.authenticated` is true. That's a great step forward! I also need to show the Save control only when the user is authenticated and logging is enabled. To confirm if logging is enabled, I plan to fetch `/api/user-settings` once the user is signed in and persistence is available, as that route requires authentication.  

Next, I’ll create a new file in `src/app/api/saved-reports/route.ts` for the API route, making sure any file touches adhere to AGENTS. I'll also log major actions after code changes, especially after route and UI adjustments. With this, I think I’ll mark step 2 as completed and start implementing step 3 for the API route.
Plan update
  ✓ Review guardrails and logs
  ✓ Audit existing auth/logging/report code
  → Implement save-report API route
  • Add UI save control and toast
  • Add tests for save flow
  • Run lint, test, build
  • Browser-verify save control
  • Security/perf/regression review, commit, log progress

thinking
**Reviewing schema validation**

I'm working on a schema using zod for analyzing reports. I'm defining address, risk fields, and checks using `.passthrough()` to keep flexibility, since reports from clients may have extra fields. Validation is key, so I want to ensure risk fields are there and validate the address with CheckRequestSchema. This might help normalize the address, but I need to make sure it aligns correctly with report.address. Let me check the validators to clarify that.
exec
/bin/zsh -lc "sed -n '1,220p' src/lib/validators.ts" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 73ms:
import bs58 from "bs58";
import { sha256 } from "@noble/hashes/sha2.js";
import { z } from "zod";

export type TronAddressValidation =
  | { ok: true; normalized: string }
  | { ok: false; normalized: string; error: string };

export function normalizeTronAddress(input: string): string {
  return input.trim();
}

function bytesEqual(a: Uint8Array, b: Uint8Array): boolean {
  if (a.length !== b.length) return false;
  for (let i = 0; i < a.length; i += 1) if (a[i] !== b[i]) return false;
  return true;
}

export function validateTronAddress(input: string): TronAddressValidation {
  const normalized = normalizeTronAddress(input);
file update
M /Users/chiko/side_projects/usdt_blacklisted_web/middleware.ts
@@ -10,2 +10,3 @@
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
A /Users/chiko/side_projects/usdt_blacklisted_web/src/app/api/saved-reports/route.ts
import { NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import { z } from "zod";

import { getDb } from "@/lib/db";
import { createSavedReport } from "@/lib/db/saved-reports";
import { getUserSettings } from "@/lib/db/user-settings";
import { TronAddressSchema } from "@/lib/validators";

export const runtime = "nodejs";

const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);

const SaveReportBodySchema = z.object({
  address: TronAddressSchema,
  report: z.unknown(),
});

const AnalyzeReportSchema = z
  .object({
    address: TronAddressSchema,
    risk: z.object({
      score: z.number(),
      tier: RiskTierSchema,
      confidence: z.number(),
    }),
    checks: z
      .object({
        exposure1hop: z.unknown().optional(),
        tracing2hop: z.unknown().optional(),
      })
      .passthrough()
      .optional(),
  })
  .passthrough();

function clampInt(n: number, min: number, max: number) {
  return Math.max(min, Math.min(max, Math.round(n)));
}

function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
    return exposure.window;
  }

  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
    return tracing.window;
  }

  return { lookbackDays: 90 };
}

async function getAuthenticatedUserId(): Promise<string | null> {
  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
  try {
    const { userId } = await auth();
    return userId ?? null;
  } catch {
    return null;
  }
}

export async function POST(request: Request) {
  const userId = await getAuthenticatedUserId();
  if (!userId) {
    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
  }

  const db = getDb();
  if (!db) {
    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
  }

  const settings = await getUserSettings(db, userId);
  if (!settings?.loggingEnabled) {
    return NextResponse.json(
      { error: "Saving is disabled. Enable it in Settings first." },
      { status: 403, headers: { "Cache-Control": "no-store" } },
    );
  }

  let json: unknown;
  try {
    json = await request.json();
  } catch {
    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
  }

  const parsed = SaveReportBodySchema.safeParse(json);
  if (!parsed.success) {
    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
  }

  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
  if (!reportParsed.success) {
    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
  }

  if (reportParsed.data.address !== parsed.data.address) {
    return NextResponse.json(
      { error: "Report address mismatch." },
      { status: 400, headers: { "Cache-Control": "no-store" } },
    );
  }

  const report = reportParsed.data;
  const created = await createSavedReport(db, userId, {
    address: parsed.data.address,
    riskScore: clampInt(report.risk.score, 0, 100),
    riskTier: report.risk.tier,
    confidence: clampInt(report.risk.confidence, 0, 100),
    window: deriveWindow(report),
    reportJson: parsed.data.report,
  });

  if (!created) {
    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
  }

  return NextResponse.json(
    { id: created.id, createdAt: created.createdAt },
    { status: 200, headers: { "Cache-Control": "no-store" } },
  );
}

apply_patch(auto_approved=true) exited 0 in 30ms:
Success. Updated the following files:
A src/app/api/saved-reports/route.ts
M middleware.ts
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fabd0647bc12621fbf4da90ca79977f4eaffcd68
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,127 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+

file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fabd0647bc12621fbf4da90ca79977f4eaffcd68
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,127 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+

exec
/bin/zsh -lc './ralph log "Added /api/saved-reports route (auth + loggingEnabled gated) and updated middleware public API list"' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 76ms:

file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fabd0647bc12621fbf4da90ca79977f4eaffcd68
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,127 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+


thinking
**Updating API progress**

I've implemented the API route, which is great! The next step is to add the UI control. I wonder if I should update step 3 to completed yet; it might be too soon since I need to ensure that the route compiles correctly and meets acceptance criteria. Maybe I should also consider adding more endpoints and using a RESTful approach since that could save some time. Now, I'll move on to step 4.
Plan update
  ✓ Review guardrails and logs
  ✓ Audit existing auth/logging/report code
  ✓ Implement save-report API route
  → Add UI save control and toast
  • Add tests for save flow
  • Run lint, test, build
  • Browser-verify save control
  • Security/perf/regression review, commit, log progress
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fabd0647bc12621fbf4da90ca79977f4eaffcd68
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,127 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+

exec
/bin/zsh -lc "sed -n '1,220p' src/app/layout.tsx" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 69ms:
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";
import { ThemeProvider } from "@/components/theme-provider";
import { Toaster } from "@/components/ui/sonner";
import { Analytics } from "@vercel/analytics/next";
import { ClerkProvider } from "@clerk/nextjs";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: {
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fabd0647bc12621fbf4da90ca79977f4eaffcd68
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,127 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+






thinking
**Evaluating conditional hooks**

I'm figuring out how the ClerkProvider works. The thing is, it only needs the publishable key, not the secret one. It seems like `clerkEnabled` in BlacklistChecker depends solely on that publishable key. Maybe `useAuth` should be called only when `clerkEnabled` is true, but I can't conditionally use hooks. However, since `SignedInAutoRerun` is only rendered when `clerkEnabled` is true, it seems safe there. If I call `useAuth` unconditionally in BlacklistChecker, it might throw if `clerkEnabled` is false. So, I need to keep it within the right context.
thinking
**Designing SaveReportButton**

I'm thinking about creating a component called `SaveReportButton` that would use `useAuth` to fetch user settings. I want to render it only when `clerkEnabled` and within a `SignedIn` scope. However, it’s essential that this shows up in the results regardless of authentication. I can still wrap it in `SignedIn` to ensure it's safe, as it will only render when `clerkEnabled` is true. I also need to check if logging is enabled and I could potentially use the server-side check. I'm a bit unsure about cached responses for anonymous users, but I'll manage that.
thinking
**Designing SaveReportControl**

Let’s outline the `SaveReportControl` component, which will accept a report of type `ApiResponse`. It will leverage `useAuth` to check if it's loaded and if the user is signed in, though being wrapped in `SignedIn` should ensure safety. I’ll also fetch `/api/user-settings` to determine if logging is enabled and if persistence is available, managing the local state accordingly.

In the `BlacklistChecker` success area, I want to render the component conditionally, depending on `clerkEnabled`, user authentication, and then handle cases where logging or persistence is disabled by returning null from `SaveReportControl`. Since it's only shown when `clerkEnabled` and wrapped in `SignedIn`, it seems safe.
thinking
**Implementing SaveReportControl**

Alright, I’m going to implement `SaveReportControl`. I think I'll use `React.useEffect` to fetch settings once on mount, but only after the analysis is successful. If the user changes a setting afterward, they’d need to refresh, which is fine. It’s likely that returning from `/settings` would remount the component, so I'm keeping that in mind.

I also need to reset the saved status whenever the report changes. I could use `report.timestamps.checkedAtIso` or `report.address` as a dependency to trigger state updates when the report changes. This way, I'm ensuring everything stays in sync!
thinking
**Finalizing SaveReportControl Implementation**

I'm diving into the details for the `SaveReportControl`. I want to utilize `motion` for animations and ensure it uses the `fadeInUp` variant. It’s great that the `motion.div` is already included in the file! 

The component will check if logging is enabled and persistence is available before rendering the save button. If `report.access.authenticated` is false, I’ll return null to ensure we only show it to authenticated users. I also need to place the component correctly in the file, just before the `BlacklistChecker` export, so everything's in order!
file update
M /Users/chiko/side_projects/usdt_blacklisted_web/src/components/blacklist-checker.tsx
@@ -508,2 +508,104 @@
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
@@ -965,2 +1067,8 @@
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
apply_patch(auto_approved=true) exited 0 in 52ms:
Success. Updated the following files:
M src/components/blacklist-checker.tsx
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fabd0647bc12621fbf4da90ca79977f4eaffcd68
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,127 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">

file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fabd0647bc12621fbf4da90ca79977f4eaffcd68
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,127 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">

exec
/bin/zsh -lc './ralph log "Updated main analysis UI to conditionally show Save this report control (SignedIn + loggingEnabled) and call /api/saved-reports"' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 77ms:

file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fabd0647bc12621fbf4da90ca79977f4eaffcd68
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,127 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">

exec
/bin/zsh -lc 'rg -n "T[1-9A-HJ-NP-Za-km-z]{20,}" src -S | head' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 87ms:
src/__tests__/api-analyze.test.ts:25:const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
src/__tests__/api-analyze.test.ts:26:const USDT_CONTRACT = "TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t";
src/__tests__/api-analyze.test.ts:71:        from: "TAfrom1111111111111111111111111111111111",
src/data/ofac-tron-addresses.json:25:      "address": "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz",
src/data/ofac-tron-addresses.json:30:          "context": "ency Address - USDT</idType> <idNumber>TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz</idNumber> </id> <id> <u"
src/data/ofac-tron-addresses.json:35:      "address": "TA39q3p75XRSWYAEaSF7dANtyksoa3sLge",
src/data/ofac-tron-addresses.json:40:          "context": "ency Address - USDT</idType> <idNumber>TA39q3p75XRSWYAEaSF7dANtyksoa3sLge</idNumber> </id> <id> <u"
src/data/ofac-tron-addresses.json:45:      "address": "TAoLw5yD5XUoHWeBZRSZ1ExK9HMv2CiPvP",
src/data/ofac-tron-addresses.json:50:          "context": "rency Address - TRX</idType> <idNumber>TAoLw5yD5XUoHWeBZRSZ1ExK9HMv2CiPvP</idNumber> </id> <id> <u"
src/data/ofac-tron-addresses.json:55:      "address": "TAYhjpL8pPs8T84FSM329nffQpc6jD8GBM",
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fabd0647bc12621fbf4da90ca79977f4eaffcd68
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,127 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">


thinking
**Looking into api-analyze tests**

I see that there are existing api-analyze tests we can utilize, which is convenient! I’ll check the valid address already in use. It makes sense to look at `src/__tests__/api-analyze.test.ts` to understand the mocking patterns. I think that’ll give me a solid guide on how to proceed. I’m excited about following this path and figuring out the best way to implement our tests!
exec
/bin/zsh -lc "sed -n '1,220p' src/__tests__/api-analyze.test.ts" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 54ms:
import { beforeEach, describe, expect, it, vi } from "vitest";

const auth = vi.fn();
vi.mock("@clerk/nextjs/server", () => ({ auth }));

const checkTronScanUsdtBlacklist = vi.fn();
const fetchUsdtTrc20Transfers = vi.fn();
const fetchTronScanAccountTag = vi.fn();
vi.mock("@/lib/tronscan", () => ({
  checkTronScanUsdtBlacklist,
  fetchUsdtTrc20Transfers,
  fetchTronScanAccountTag,
}));

const readUsdtBlacklistStatusOnChain = vi.fn();
vi.mock("@/lib/tron", () => ({
  readUsdtBlacklistStatusOnChain,
}));

const checkOfacSanctions = vi.fn();
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fabd0647bc12621fbf4da90ca79977f4eaffcd68
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,127 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">

file update
A /Users/chiko/side_projects/usdt_blacklisted_web/src/__tests__/api-saved-reports.test.ts
import { beforeEach, describe, expect, it, vi } from "vitest";

const auth = vi.fn();
vi.mock("@clerk/nextjs/server", () => ({ auth }));

const getDb = vi.fn();
vi.mock("@/lib/db", () => ({ getDb }));

const getUserSettings = vi.fn();
vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));

const createSavedReport = vi.fn();
vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));

const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";

async function callPost(body: unknown) {
  const { POST } = await import("@/app/api/saved-reports/route");
  const req = new Request("http://localhost/api/saved-reports", {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify(body),
  });
  const res = await POST(req);
  const json = await res.json().catch(() => null);
  return { res, json };
}

beforeEach(() => {
  vi.resetModules();
  vi.clearAllMocks();
  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
  process.env.CLERK_SECRET_KEY = "sk_test_123";
});

describe("/api/saved-reports", () => {
  it("returns 401 when unauthenticated and does not touch the DB", async () => {
    auth.mockResolvedValue({ userId: null });

    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
    expect(res.status).toBe(401);
    expect(getDb).not.toHaveBeenCalled();
    expect(getUserSettings).not.toHaveBeenCalled();
    expect(createSavedReport).not.toHaveBeenCalled();
  });

  it("returns 503 when persistence is disabled", async () => {
    auth.mockResolvedValue({ userId: "user_123" });
    getDb.mockReturnValue(null);

    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
    expect(res.status).toBe(503);
    expect(json?.error).toBeTypeOf("string");
    expect(getUserSettings).not.toHaveBeenCalled();
    expect(createSavedReport).not.toHaveBeenCalled();
  });

  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
    auth.mockResolvedValue({ userId: "user_123" });
    getDb.mockReturnValue({});
    getUserSettings.mockResolvedValue({ loggingEnabled: false });

    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
    expect(res.status).toBe(403);
    expect(createSavedReport).not.toHaveBeenCalled();
  });

  it("validates payload and rejects mismatched report addresses", async () => {
    auth.mockResolvedValue({ userId: "user_123" });
    getDb.mockReturnValue({});
    getUserSettings.mockResolvedValue({ loggingEnabled: true });

    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
    const { res } = await callPost({ address: VALID_ADDRESS, report });
    expect(res.status).toBe(400);
    expect(createSavedReport).not.toHaveBeenCalled();
  });

  it("creates a SavedReport and returns its id", async () => {
    auth.mockResolvedValue({ userId: "user_123" });
    getDb.mockReturnValue({});
    getUserSettings.mockResolvedValue({ loggingEnabled: true });
    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });

    const report = {
      address: VALID_ADDRESS,
      risk: { score: 55.2, tier: "high", confidence: 91.7 },
      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
    };

    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
    expect(res.status).toBe(200);
    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
    expect(createSavedReport).toHaveBeenCalledWith(
      {},
      "user_123",
      expect.objectContaining({
        address: VALID_ADDRESS,
        riskScore: 55,
        riskTier: "high",
        confidence: 92,
        window: { lookbackDays: 90 },
      }),
    );
  });
});

apply_patch(auto_approved=true) exited 0 in 73ms:
Success. Updated the following files:
A src/__tests__/api-saved-reports.test.ts
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..18acb0eee01df2b986a28761b80c57def8065974
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
+
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fabd0647bc12621fbf4da90ca79977f4eaffcd68
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,127 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">

file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..18acb0eee01df2b986a28761b80c57def8065974
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
+
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fabd0647bc12621fbf4da90ca79977f4eaffcd68
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,127 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">

exec
/bin/zsh -lc './ralph log "Added Vitest coverage for /api/saved-reports (auth, persistence, loggingEnabled gating, payload validation, create success)"' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 80ms:

file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..18acb0eee01df2b986a28761b80c57def8065974
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
+
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fabd0647bc12621fbf4da90ca79977f4eaffcd68
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,127 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">

Plan update
  ✓ Review guardrails and logs
  ✓ Audit existing auth/logging/report code
  ✓ Implement save-report API route
  ✓ Add UI save control and toast
  → Add tests for save flow
  • Run lint, test, build
  • Browser-verify save control
  • Security/perf/regression review, commit, log progress
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..18acb0eee01df2b986a28761b80c57def8065974
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
+
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fabd0647bc12621fbf4da90ca79977f4eaffcd68
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,127 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">


thinking
**Updating project plan**

I've already added the tests, so it seems like I can move on and complete step 5. That’s a relief! Now, I need to update the plan to reflect this progress and figure out what the next step should be. I guess it’s about staying organized and keeping track of what’s done and what’s next. I want to make sure I don't overlook anything important as I move forward!
Plan update
  ✓ Review guardrails and logs
  ✓ Audit existing auth/logging/report code
  ✓ Implement save-report API route
  ✓ Add UI save control and toast
  ✓ Add tests for save flow
  → Run lint, test, build
  • Browser-verify save control
  • Security/perf/regression review, commit, log progress
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..18acb0eee01df2b986a28761b80c57def8065974
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
+
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fabd0647bc12621fbf4da90ca79977f4eaffcd68
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,127 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">


thinking
**Running quality checks**

I need to run some quality gates using commands like `pnpm lint`, `pnpm test`, and `pnpm build`. It makes sense to run them sequentially since the commands can be long. I'll log the process before and after each command, using ralph to log the outputs after the tests finish. I'll start with `pnpm lint`, followed by `pnpm test`, and then `pnpm build`. Let's make sure everything runs smoothly!
exec
/bin/zsh -lc 'pnpm lint' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 2.98s:

> usdt_blacklisted_web@0.1.0 lint /Users/chiko/side_projects/usdt_blacklisted_web
> eslint

file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..18acb0eee01df2b986a28761b80c57def8065974
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
+
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fabd0647bc12621fbf4da90ca79977f4eaffcd68
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,127 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">

exec
/bin/zsh -lc 'pnpm test' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 1.25s:

> usdt_blacklisted_web@0.1.0 test /Users/chiko/side_projects/usdt_blacklisted_web
> vitest run


[1m[46m RUN [49m[22m [36mv4.0.17 [39m[90m/Users/chiko/side_projects/usdt_blacklisted_web[39m

 [32m✓[39m src/lib/sanctions.test.ts [2m([22m[2m2 tests[22m[2m)[22m[32m 8[2mms[22m[39m
 [32m✓[39m src/lib/aml.test.ts [2m([22m[2m7 tests[22m[2m)[22m[32m 8[2mms[22m[39m
 [32m✓[39m src/__tests__/api-user-settings.test.ts [2m([22m[2m4 tests[22m[2m)[22m[32m 125[2mms[22m[39m
 [32m✓[39m src/__tests__/api-saved-reports.test.ts [2m([22m[2m5 tests[22m[2m)[22m[32m 142[2mms[22m[39m
 [32m✓[39m src/__tests__/api-analyze.test.ts [2m([22m[2m2 tests[22m[2m)[22m[32m 176[2mms[22m[39m
 [32m✓[39m src/lib/db/address-hash.test.ts [2m([22m[2m4 tests[22m[2m)[22m[32m 3[2mms[22m[39m
 [32m✓[39m src/lib/exposure.test.ts [2m([22m[2m1 test[22m[2m)[22m[32m 2[2mms[22m[39m
 [32m✓[39m src/lib/heuristics.test.ts [2m([22m[2m3 tests[22m[2m)[22m[32m 2[2mms[22m[39m
 [32m✓[39m src/lib/db/scoped-queries.test.ts [2m([22m[2m4 tests[22m[2m)[22m[32m 4[2mms[22m[39m
 [32m✓[39m src/lib/entity.test.ts [2m([22m[2m2 tests[22m[2m)[22m[32m 1[2mms[22m[39m
 [32m✓[39m src/lib/db/index.test.ts [2m([22m[2m1 test[22m[2m)[22m[33m 319[2mms[22m[39m
     [33m[2m✓[22m[39m returns null when DATABASE_URL is missing [33m 319[2mms[22m[39m

file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..18acb0eee01df2b986a28761b80c57def8065974
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
+
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fabd0647bc12621fbf4da90ca79977f4eaffcd68
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,127 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">

exec
/bin/zsh -lc 'pnpm build' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 13.82s:

> usdt_blacklisted_web@0.1.0 build /Users/chiko/side_projects/usdt_blacklisted_web
> next build

▲ Next.js 16.1.4 (Turbopack)
- Environments: .env

  Creating an optimized production build ...
✓ Compiled successfully in 5.3s
  Running TypeScript ...
  Collecting page data using 7 workers ...
  Generating static pages using 7 workers (0/9) ...
  Generating static pages using 7 workers (2/9) 
  Generating static pages using 7 workers (4/9) 
  Generating static pages using 7 workers (6/9) 
✓ Generating static pages using 7 workers (9/9) in 188.8ms
  Finalizing page optimization ...

Route (app)
┌ ○ /
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..18acb0eee01df2b986a28761b80c57def8065974
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
+
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fabd0647bc12621fbf4da90ca79977f4eaffcd68
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,127 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">

exec
/bin/zsh -lc './ralph log "Quality gates: pnpm lint/test/build all passed"' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 80ms:

file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..18acb0eee01df2b986a28761b80c57def8065974
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
+
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fabd0647bc12621fbf4da90ca79977f4eaffcd68
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,127 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">

Plan update
  ✓ Review guardrails and logs
  ✓ Audit existing auth/logging/report code
  ✓ Implement save-report API route
  ✓ Add UI save control and toast
  ✓ Add tests for save flow
  ✓ Run lint, test, build
  → Browser-verify save control
  • Security/perf/regression review, commit, log progress
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..18acb0eee01df2b986a28761b80c57def8065974
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
+
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fabd0647bc12621fbf4da90ca79977f4eaffcd68
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,127 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">

exec
/bin/zsh -lc "sed -n '1,200p' /Users/chiko/.codex/skills/dev-browser/SKILL.md" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 62ms:
---
name: dev-browser
description: Browser automation with persistent page state. Use when users ask to navigate websites, fill forms, take screenshots, extract web data, test web apps, or automate browser workflows. Trigger phrases include "go to [url]", "click on", "fill out the form", "take a screenshot", "scrape", "automate", "test the website", "log into", or any browser interaction request.
---

# Dev Browser Skill

Browser automation that maintains page state across script executions. Write small, focused scripts to accomplish tasks incrementally. Once you've proven out part of a workflow and there is repeated work to be done, you can write a script to do the repeated work in a single execution.

## Choosing Your Approach

- **Local/source-available sites**: Read the source code first to write selectors directly
- **Unknown page layouts**: Use `getAISnapshot()` to discover elements and `selectSnapshotRef()` to interact with them
- **Visual feedback**: Take screenshots to see what the user sees

## Setup

Two modes available. Ask the user if unclear which to use.

### Standalone Mode (Default)
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..18acb0eee01df2b986a28761b80c57def8065974
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
+
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fabd0647bc12621fbf4da90ca79977f4eaffcd68
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,127 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">






thinking
**Starting the server**

I need to start the server with the command `./skills/dev-browser/server.sh &`. It seems like it's in the `skills/dev-browser` directory. However, I’m wondering if the path exists in the current repo. The skill documentation mentions running it relative to the environment. It’s possibly located in `/skills/dev-browser`. I should check for the script in `/Users/chiko/.codex/skills/dev-browser`. My goal is to run both the Next dev server and the dev-browser server concurrently while verifying UI changes in the browser.
thinking
**Planning browser verification steps**

Since approvals are never straightforward, I can proceed with the verification steps. First, I’ll start the dev-browser server. After that, I should run `pnpm dev` in the background while keeping it active for automation purposes. I might want to store logs using `./ralph log` to ensure they persist. Then, I’ll run the dev-browser script to open a page and analyze whether the Save control appears or hides based on logging and authentication settings. However, signing in might be tricky due to Clerk's requirements, so I must remember that verification in the browser doesn’t necessarily need authenticated sign-ins.
thinking
**Verifying without sign-in**

I won’t be able to sign in since I don't have credentials, but I can still verify the hidden elements when signed out. I also need to confirm that the success path works for saving. Stubbing cookies could help simulate this. However, the acceptance criteria require that an authenticated user clicks Save to create a history entry and display a success toast. I'll check the `.env` file for Clerk keys and ensure the local database is set up without exposing any secrets. I just need to read the keys without printing them in my output.
thinking
**Exploring environment variables and login options**

I can check if the environment variables are correctly set using `rg`. Opening the `.env` file might help, but I’ll need to be cautious not to log any sensitive information. To save to the database, I’ll ensure the `DATABASE_URL` is set, possibly pointing to a local Postgres instance. For signing in, I might need actual user credentials, but Clerk's development mode could allow for user creation. Alternatively, I could simulate being signed in by mocking fetch responses to verify the Save control behaves as expected.
thinking
**Exploring Clerk options for local testing**

I’m considering running Next.js with Clerk disabled by removing the publishable key, but then the Save control wouldn’t appear. Alternatively, I could set environment variables for Clerk to function locally and sign in with an email account. I could create a new account using something like `test@example.com`, but I need access to that email for verification. Maybe Clerk allows passwordless sign-in or magic links; I should check its configuration. I’ll look for a `CLERK_TEST_TOKEN` or any relevant instructions in the repository, particularly in the `.env.example`, since it’s non-secret.
exec
/bin/zsh -lc 'cat .env.example' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 89ms:
TRONGRID_API_KEY=
NEXT_PUBLIC_SITE_URL=https://usdt.chikocorp.com

# Clerk (auth)
NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=
CLERK_SECRET_KEY=
NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
NEXT_PUBLIC_CLERK_SIGN_UP_URL=/sign-up
NEXT_PUBLIC_CLERK_AFTER_SIGN_IN_URL=/
NEXT_PUBLIC_CLERK_AFTER_SIGN_UP_URL=/

# Database (future: opt-in report saving + credits)
DATABASE_URL=
ADDRESS_HASH_KEY=
# Optional: retention cap for saved reports (default: unlimited)
REPORT_RETENTION_DAYS=
# Optional: cap saved reports per user (default: unlimited)
MAX_REPORTS_PER_USER=
exec
/bin/zsh -lc "cat .env | sed -n '1,120p'" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 58ms:
TRONGRID_API_KEY=
NEXT_PUBLIC_SITE_URL=https://usdt.chikocorp.com

# Clerk (auth)
NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
CLERK_SECRET_KEY=<redacted>
NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
NEXT_PUBLIC_CLERK_SIGN_UP_URL=/sign-up
NEXT_PUBLIC_CLERK_AFTER_SIGN_IN_URL=/
NEXT_PUBLIC_CLERK_AFTER_SIGN_UP_URL=/


# Database (future: opt-in report saving + credits)
DATABASE_URL=
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..18acb0eee01df2b986a28761b80c57def8065974
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
+
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fabd0647bc12621fbf4da90ca79977f4eaffcd68
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,127 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">


thinking
**Considering database options**

Now that I have network access, using a cloud Postgres like Neon could be an option, but I should probably avoid that for now since I’d need credentials. I think it might be best to start a local Postgres instance using Docker. First, I need to check if Docker is installed, so I’ll look into that quickly. It's always good to make sure everything's set up correctly before proceeding!
exec
/bin/zsh -lc 'command -v docker || true; command -v psql || true; command -v postgres || true' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 64ms:
/usr/local/bin/docker
/opt/homebrew/bin/psql
/opt/homebrew/bin/postgres
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..18acb0eee01df2b986a28761b80c57def8065974
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
+
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fabd0647bc12621fbf4da90ca79977f4eaffcd68
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,127 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">


thinking
**Setting up PostgreSQL container**

I’ve got docker, psql, and postgres installed, which is great! I can launch a postgres container to verify everything’s running smoothly. For the `pnpm dev` process, I need to set up the DATABASE_URL environment variable. I should also make sure to run the necessary migrations. Hmm, maybe I should check the package.json scripts for the Drizzle migration scripts to see what needs to be done next. Let's take a closer look at that!
exec
/bin/zsh -lc 'cat package.json' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 68ms:
{
  "name": "usdt_blacklisted_web",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "eslint",
    "db:generate": "drizzle-kit generate",
    "db:migrate": "drizzle-kit migrate",
    "db:studio": "drizzle-kit studio",
    "ofac:update": "node scripts/fetch-ofac-tron-addresses.mjs",
    "test": "vitest run",
    "test:watch": "vitest",
    "test:coverage": "vitest run --coverage"
  },
  "dependencies": {
    "@clerk/nextjs": "^6.36.9",
    "@noble/hashes": "^2.0.1",
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..18acb0eee01df2b986a28761b80c57def8065974
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
+
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fabd0647bc12621fbf4da90ca79977f4eaffcd68
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,127 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">

exec
/bin/zsh -lc "sed -n '1,120p' src/lib/db/address-hash.ts" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 93ms:
import "server-only";

import { createHmac } from "crypto";

function requireAddressHashKey(): string {
  const key = process.env.ADDRESS_HASH_KEY;
  if (!key) throw new Error("Persistence is disabled (ADDRESS_HASH_KEY not set).");
  return key;
}

export function normalizeAddress(address: string): string {
  return address.trim();
}

export function computeAddressHash(userId: string, address: string): string {
  const key = requireAddressHashKey();
  const normalizedAddress = normalizeAddress(address);
  return createHmac("sha256", key).update(`${userId}:${normalizedAddress}`, "utf8").digest("hex");
}

file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..18acb0eee01df2b986a28761b80c57def8065974
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
+
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fabd0647bc12621fbf4da90ca79977f4eaffcd68
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,127 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">

file update
M /Users/chiko/side_projects/usdt_blacklisted_web/src/app/api/saved-reports/route.ts
@@ -70,2 +70,6 @@
 
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
   const db = getDb();
@@ -126,2 +130 @@
 }
-
apply_patch(auto_approved=true) exited 0 in 97ms:
Success. Updated the following files:
M src/app/api/saved-reports/route.ts
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..18acb0eee01df2b986a28761b80c57def8065974
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
+
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">

file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..18acb0eee01df2b986a28761b80c57def8065974
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
+
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">


thinking
**Updating tests for environment variable**

I'm planning to update tests to set the `ADDRESS_HASH_KEY` environment variable in the `beforeEach` function. This should help ensure the tests run with the necessary setup for this key. I think patching the test file is the next step I need to take to facilitate this change. It's exciting to think about how this alteration could improve the reliability of the tests! I'll get to work on implementing this soon.
file update
M /Users/chiko/side_projects/usdt_blacklisted_web/src/__tests__/api-saved-reports.test.ts
@@ -33,2 +33,3 @@
   process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
 });
@@ -106,2 +107 @@
 });
-
apply_patch(auto_approved=true) exited 0 in 72ms:
Success. Updated the following files:
M src/__tests__/api-saved-reports.test.ts
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">

file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">

exec
/bin/zsh -lc './ralph log "Hardened /api/saved-reports: require ADDRESS_HASH_KEY for persistence; updated tests env"' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 93ms:

file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">


thinking
**Running Tests and Migrations**

I’ve already run quality gates, but since we changed some code, it seems I'll need to re-run the tests and linting before committing. Eventually, we'll do that again after browser verification. The global gates must pass, so quickly running `pnpm test` and linting sounds good. First, though, we need to start the dev server with `pnpm dev`, making sure the environment is set for the database and key. I'll check if the necessary migrations for user settings and saved reports exist before proceeding with `pnpm db:migrate`.
exec
/bin/zsh -lc "sed -n '1,200p' src/lib/db/migrations/0000_worthless_guardian.sql" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 71ms:
CREATE EXTENSION IF NOT EXISTS "pgcrypto";
--> statement-breakpoint
CREATE TABLE "saved_reports" (
	"id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
	"user_id" text NOT NULL,
	"address" text NOT NULL,
	"address_hash" text NOT NULL,
	"risk_score" integer NOT NULL,
	"risk_tier" text NOT NULL,
	"confidence" integer NOT NULL,
	"window" jsonb NOT NULL,
	"report_json" jsonb NOT NULL,
	"created_at" timestamp with time zone DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "user_settings" (
	"user_id" text PRIMARY KEY NOT NULL,
	"logging_enabled" boolean DEFAULT false NOT NULL,
	"created_at" timestamp with time zone DEFAULT now() NOT NULL,
	"updated_at" timestamp with time zone DEFAULT now() NOT NULL
exec
/bin/zsh -lc "sed -n '1,200p' src/lib/db/migrations/0001_overrated_plazm.sql" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 58ms:
ALTER TABLE "watchlist_items" ADD CONSTRAINT "watchlist_items_user_id_user_settings_user_id_fk" FOREIGN KEY ("user_id") REFERENCES "public"."user_settings"("user_id") ON DELETE cascade ON UPDATE no action;
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">




thinking
**Verifying setup process**

Alright, I need to confirm the steps for setting things up. First, I’ll start the PostgreSQL container and set the environment variables DATABASE_URL and ADDRESS_HASH_KEY. Then, I'll run migration to initialize the database. After that, I’ll start the development process and check if I can sign up or sign in using Clerk's development instance. I wonder if I can use Clerk's test accounts without needing real email credentials? It looks like there might be options like "Continue with Google" or a demo user. Let's explore!
thinking
**Attempting sign-up process**

I’m thinking about trying the email/password sign-up to see if it requires email verification. I’ll sign up using a random email and password. Clerk typically handles this, so it should work, but I’m not sure if they'll require verification in the development environment. I’ll set up a browser script to interact with the UI for sign-up. Additionally, I’ll ensure the loggingEnabled toggle in the settings, keeping in mind not to commit any environment changes, and get the Docker Postgres server running as well.
thinking
**Starting Docker container**

I’m planning to remove the existing Docker container named `usdt_blacklisted_web_pg`, if it exists, just to keep things clean. Then I’ll go ahead and start a new container using the command `docker run`, setting the necessary environment variable for POSTGRES_PASSWORD and mapping the port 54329 to 5432. I have to make sure that the image is pulled correctly before running this. Let’s get the container up and see how it goes!
exec
/bin/zsh -lc 'docker rm -f usdt_blacklisted_web_pg >/dev/null 2>&1 || true
docker run --name usdt_blacklisted_web_pg -e POSTGRES_PASSWORD=postgres -p 54329:5432 -d postgres:16' in /Users/chiko/side_projects/usdt_blacklisted_web exited 125 in 91ms:
docker: Cannot connect to the Docker daemon at unix:///Users/chiko/.orbstack/run/docker.sock. Is the docker daemon running?

Run 'docker run --help' for more information
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">


thinking
**Checking local PostgreSQL setup**

I noticed that the Docker daemon isn't running, so I need a fallback plan. I could use the local PostgreSQL binary that I've installed. My idea is to start a temporary local instance with the data directory by using `initdb`. Since I’m on a Mac and using Homebrew, I'll check if `initdb` is indeed available by running `command -v initdb pg_ctl`. That should help me move forward!
exec
/bin/zsh -lc 'command -v initdb || true; command -v pg_ctl || true' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 58ms:
/opt/homebrew/bin/initdb
/opt/homebrew/bin/pg_ctl
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">


thinking
**Setting up local Postgres cluster**

I’m planning to set up a local Postgres cluster in the `/tmp` directory. To start, I need to create a data directory and run it on port 54329 with the appropriate socket options. I'll use the command `pg_ctl -D ... -o "-p 54329" -l ... start`. Setting up authentication to trust for local tests should make things easier, and stopping the server afterwards isn’t strictly necessary but a good practice. I’ll confirm all details before proceeding!
exec
/bin/zsh -lc 'set -euo pipefail
PGDATA="/tmp/usdt_blacklisted_web_pgdata"
if [ ! -d "$PGDATA" ]; then
  initdb -D "$PGDATA" -A trust -U postgres >/dev/null
fi
pg_ctl -D "$PGDATA" -o "-p 54329" -l "$PGDATA/logfile" start >/dev/null || true
sleep 1
psql "postgres://postgres@localhost:54329/postgres" -c "select 1" >/dev/null' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 3.09s:

file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">


thinking
**Running migrations in Postgres**

I see that Postgres has started, which is great! Now I need to run the migrations while making sure to set the necessary environment variables like `DATABASE_URL` and `ADDRESS_HASH_KEY`. I’ll set `ADDRESS_HASH_KEY` to `test_hash_key` or something random since it shouldn't be committed. So, I'll run the command: `DATABASE_URL=postgres://postgres@localhost:54329/postgres ADDRESS_HASH_KEY=test_hash_key pnpm db:migrate`. Let’s get this done!
exec
/bin/zsh -lc 'DATABASE_URL="postgres://postgres@localhost:54329/postgres" ADDRESS_HASH_KEY="dev_hash_key" pnpm db:migrate' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 1.45s:

> usdt_blacklisted_web@0.1.0 db:migrate /Users/chiko/side_projects/usdt_blacklisted_web
> drizzle-kit migrate

No config path provided, using default 'drizzle.config.ts'
Reading config file '/Users/chiko/side_projects/usdt_blacklisted_web/drizzle.config.ts'
Using 'postgres' driver for database querying
[⣷] applying migrations...[2K[1G[⣯] applying migrations...[2K[1G[⣟] applying migrations...[2K[1G[✓] migrations applied successfully!
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">

exec
/bin/zsh -lc 'set -euo pipefail
NEXT_LOG="/tmp/usdt_blacklisted_web_next_dev.log"
DB_URL="postgres://postgres@localhost:54329/postgres"
ADDRESS_HASH_KEY="dev_hash_key"

# Start Next.js dev server (if not already running)
if ! lsof -iTCP:3000 -sTCP:LISTEN >/dev/null 2>&1; then
  (DATABASE_URL="$DB_URL" ADDRESS_HASH_KEY="$ADDRESS_HASH_KEY" pnpm dev >"$NEXT_LOG" 2>&1 &) 
  sleep 2
fi

# Start dev-browser server
DEV_BROWSER_DIR="/Users/chiko/.codex/skills/dev-browser"
DEV_BROWSER_LOG="/tmp/dev-browser.log"
if ! lsof -iTCP:3025 -sTCP:LISTEN >/dev/null 2>&1; then
  (cd "$DEV_BROWSER_DIR" && ./server.sh >"$DEV_BROWSER_LOG" 2>&1 &)
  sleep 2
fi

lsof -iTCP:3000 -sTCP:LISTEN | head -n 2 || true
lsof -iTCP:3025 -sTCP:LISTEN | head -n 2 || true
' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 2.21s:
COMMAND   PID  USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME
node    46239 chiko   17u  IPv6 0x4a85b4ac09c868f4      0t0  TCP *:hbci (LISTEN)
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">


thinking
**Checking ports and logs**

It looks like port 3000 is listening, possibly for hbci. But for the dev-browser, maybe it should be on port 3025, though that’s not showing up. It’s possible that it might be using a different port altogether, so I should check the logs for more details. Let’s take a quick look at `DEV_BROWSER_LOG` to gather some insights!
exec
/bin/zsh -lc 'tail -n 30 /tmp/dev-browser.log || true' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 66ms:
(node:62838) ExperimentalWarning: CommonJS module /Users/chiko/.nvm/versions/node/v23.3.0/lib/node_modules/npm/node_modules/debug/src/node.js is loading ES Module /Users/chiko/.nvm/versions/node/v23.3.0/lib/node_modules/npm/node_modules/supports-color/index.js using require().
Support for loading ES Module in require() is an experimental feature and might change at any time
(Use `node --trace-warnings ...` to show where the warning was created)

up to date, audited 140 packages in 1s

29 packages are looking for funding
  run `npm fund` for details

7 vulnerabilities (5 moderate, 2 high)

To address issues that do not require attention, run:
  npm audit fix

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
Starting dev-browser server...
(node:62855) ExperimentalWarning: CommonJS module /Users/chiko/.nvm/versions/node/v23.3.0/lib/node_modules/npm/node_modules/debug/src/node.js is loading ES Module /Users/chiko/.nvm/versions/node/v23.3.0/lib/node_modules/npm/node_modules/supports-color/index.js using require().
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">





thinking
**Verifying analysis process**

I need to verify the address analysis process. First, I'll check the results and ensure the "Save" control is hidden unless signed in or logging is enabled. I’ll start by running the analysis without being signed in. After that, I’ll sign in to enable logging and rerun the analysis to verify that the “Save” button appears correctly and functions as intended. I need to address potential email verification issues and note that there’s no TRONGRID_API_KEY in the environment.
thinking
**Analyzing TronScan process**

I need to confirm whether the analyze function uses TronScan with an on-chain read through TronWeb. It might work without the TRONGRID_API_KEY, using a default public endpoint instead. I’ll check the libraries and see how TronScan operates to streamline the process. Running the analysis could be slow, but I can test it in the browser with a stable address. For automation, I'll use a recognized address and check for results like "Not Blacklisted." Instead of a modal for signing up, it seems easier to navigate directly to the sign-up page.
thinking
**Planning Clerk sign-up process**

I need to work on the Clerk sign-up page and confirm that the middleware, `isPublicRoute`, allows access for sign-in and sign-up. Once I create an account and log in, I expect to be redirected to the home page. From there, I’ll head to the `/settings` to toggle the "Save screening history" option, which will call the API to update the user settings. 

I’ll identify selectors to verify that the Save control appears and functions properly. Instead of taking a massive snapshot, I’ll use `page.getByRole` to check for key nodes efficiently. We can implement small scripts to handle each step.
thinking
**Navigating and running analysis**

First, I’ll navigate to the home page and initiate the analysis. I need to verify that there isn’t a Save control present at this point, which is my initial expectation. It’s a straightforward task, so I’m ready to run the analysis and see if everything works as intended. Let’s move ahead with this to ensure that the basic functionality is operating correctly.
exec
/bin/zsh -lc "cd /Users/chiko/.codex/skills/dev-browser && npx tsx <<'EOF'
import { connect, waitForPageLoad } from \"@/client.js\";

const client = await connect();
const page = await client.page(\"usdt-save-report\", { viewport: { width: 1280, height: 900 } });

await page.goto(\"http://localhost:3000/\");
await waitForPageLoad(page);

// Run an analysis as signed-out user.
const address = \"T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb\";
await page.getByRole(\"textbox\").first().fill(address);
await page.getByRole(\"button\", { name: /check/i }).click();

// Wait for results to render.
await page.waitForSelector(\"text=Status\", { timeout: 60_000 }).catch(() => null);

const hasSaveControl = (await page.getByText(\"Save this report\").count()) > 0;
console.log({ url: page.url(), hasSaveControl });

await page.screenshot({ path: \"tmp/usdt-signed-out-results.png\", fullPage: true });
await client.disconnect();
EOF" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 8.86s:
{ url: 'http://localhost:3000/', hasSaveControl: false }
(node:63284) ExperimentalWarning: CommonJS module /Users/chiko/.nvm/versions/node/v23.3.0/lib/node_modules/npm/node_modules/debug/src/node.js is loading ES Module /Users/chiko/.nvm/versions/node/v23.3.0/lib/node_modules/npm/node_modules/supports-color/index.js using require().
Support for loading ES Module in require() is an experimental feature and might change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">

exec
/bin/zsh -lc "cd /Users/chiko/.codex/skills/dev-browser && npx tsx <<'EOF'
import { connect, waitForPageLoad } from \"@/client.js\";

const client = await connect();
const page = await client.page(\"usdt-save-report\");

await page.goto(\"http://localhost:3000/sign-up\");
await waitForPageLoad(page);

const frames = page.frames().map((f) => f.url());
console.log({ url: page.url(), title: await page.title(), iframeCount: (await page.locator(\"iframe\").count()), frameUrls: frames.filter((u) => u && u "'!== page.url()).slice(0, 5) });

await page.screenshot({ path: "tmp/usdt-sign-up.png", fullPage: true });
await client.disconnect();
EOF' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 3.23s:
{
  url: 'http://localhost:3000/sign-up',
  title: 'USDT (TRON) Blacklist Checker',
  iframeCount: 0,
  frameUrls: []
}
(node:63524) ExperimentalWarning: CommonJS module /Users/chiko/.nvm/versions/node/v23.3.0/lib/node_modules/npm/node_modules/debug/src/node.js is loading ES Module /Users/chiko/.nvm/versions/node/v23.3.0/lib/node_modules/npm/node_modules/supports-color/index.js using require().
Support for loading ES Module in require() is an experimental feature and might change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">


thinking
**Preparing to fill sign-up form**

I'm noting that the Clerk sign-up is rendering in the DOM, so I need to fill out the sign-up form. To check the fields, I'll use an aria snapshot by calling getAISnapshot for the page "usdt-save-report." I’m planning to run a script to print out the top 200 lines of the snapshot, which comes in YAML format. The code looks like this: `const snap = await client.getAISnapshot("usdt-save-report"); console.log(snap.split("\n").slice(0,200).join("\n"));`. Ok, let’s proceed!
exec
/bin/zsh -lc "cd /Users/chiko/.codex/skills/dev-browser && npx tsx <<'EOF'
import { connect } from \"@/client.js\";

const client = await connect();
const snapshot = await client.getAISnapshot(\"usdt-save-report\");
console.log(snapshot.split(\"\\n\").slice(0, 240).join(\"\\n\"));
await client.disconnect();
EOF" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 942ms:
- generic [active] [ref=e1]:
  - main [ref=e2]:
    - generic [ref=e4]:
      - generic [ref=e5]:
        - generic [ref=e7]:
          - heading "Create your account" [level=1] [ref=e8]
          - paragraph [ref=e9]: Welcome! Please fill in the details to get started.
        - generic [ref=e10]:
          - generic [ref=e12]:
            - button "Sign in with Apple" [ref=e13] [cursor=pointer]:
              - img "Sign in with Apple" [ref=e14]
            - button "Sign in with Facebook" [ref=e15] [cursor=pointer]:
              - img "Sign in with Facebook" [ref=e16]
            - button "Sign in with Google" [ref=e17] [cursor=pointer]:
              - img "Sign in with Google" [ref=e18]
          - paragraph [ref=e21]: or
          - generic [ref=e23]:
            - generic [ref=e24]:
              - generic [ref=e25]:
                - generic [ref=e27]:
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">

exec
/bin/zsh -lc "cd /Users/chiko/.codex/skills/dev-browser && npx tsx <<'EOF'
import { connect, waitForPageLoad } from \"@/client.js\";

const client = await connect();
const page = await client.page(\"usdt-save-report\");

if ("'!page.url().includes("/sign-up")) {
  await page.goto("http://localhost:3000/sign-up");
  await waitForPageLoad(page);
}

const ts = Date.now();
const email = `codex+${ts}@example.com`;

await page.getByRole("textbox", { name: "First name" }).fill("Codex");
await page.getByRole("textbox", { name: "Last name" }).fill("Tester");
await page.getByRole("textbox", { name: "Email address" }).fill(email);

await page.getByRole("button", { name: /continue/i }).click();

// Wait for next step to render.
await page.waitForTimeout(1000);
await page.screenshot({ path: "tmp/usdt-sign-up-step2.png", fullPage: true });

const snapshot = await client.getAISnapshot("usdt-save-report");
console.log({ email });
console.log(snapshot.split("'"\\n\").slice(0, 260).join(\"\\n\"));

await client.disconnect();
EOF" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 2.20s:
{ email: 'codex+1769176932357@example.com' }
- generic [active] [ref=e1]:
  - main [ref=e2]:
    - generic [ref=e4]:
      - generic [ref=e5]:
        - generic [ref=e7]:
          - heading "Create your account" [level=1] [ref=e8]
          - paragraph [ref=e9]: Welcome! Please fill in the details to get started.
        - generic [ref=e10]:
          - generic [ref=e12]:
            - button "Sign in with Apple" [disabled]:
              - img "Sign in with Apple"
            - button "Sign in with Facebook" [disabled]:
              - img "Sign in with Facebook"
            - button "Sign in with Google" [disabled]:
              - img "Sign in with Google"
          - paragraph [ref=e21]: or
          - generic [ref=e23]:
            - generic [ref=e24]:
              - generic [ref=e25]:
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">


thinking
**Waiting for password step**

I think the loading issue might be due to network problems or the need for captchas. The snapshot shows that fields are disabled and still loading, so perhaps I just need to wait longer. I’ll run another script to check for the password step, using `waitForSelector` for the text "Password." I’ll also set it to wait for `textbox "Password"` to appear or for the "Verify your email" message. Time to print the snapshot and run it!
exec
/bin/zsh -lc "cd /Users/chiko/.codex/skills/dev-browser && npx tsx <<'EOF'
import { connect } from \"@/client.js\";

const client = await connect();
const page = await client.page(\"usdt-save-report\");

await page.waitForTimeout(5000);

const snapshot = await client.getAISnapshot(\"usdt-save-report\");
console.log(snapshot.split(\"\\n\").slice(0, 260).join(\"\\n\"));
await page.screenshot({ path: \"tmp/usdt-sign-up-after-wait.png\", fullPage: true });

await client.disconnect();
EOF" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 6.07s:
- generic [active] [ref=e1]:
  - main [ref=e2]:
    - generic [ref=e4]:
      - generic [ref=e5]:
        - generic [ref=e7]:
          - heading "Create your account" [level=1] [ref=e8]
          - paragraph [ref=e9]: Welcome! Please fill in the details to get started.
        - generic [ref=e79]:
          - img [ref=e80]
          - paragraph [ref=e83]: The CAPTCHA failed to load. This may be due to an unsupported browser or a browser extension. Please try a different browser or disabling extensions. If this issue persists, please contact support.
        - generic [ref=e10]:
          - generic [ref=e12]:
            - button "Sign in with Apple" [ref=e13] [cursor=pointer]:
              - img "Sign in with Apple" [ref=e14]
            - button "Sign in with Facebook" [ref=e15] [cursor=pointer]:
              - img "Sign in with Facebook" [ref=e16]
            - button "Sign in with Google" [ref=e17] [cursor=pointer]:
              - img "Sign in with Google" [ref=e18]
          - paragraph [ref=e21]: or
          - generic [ref=e23]:
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">


thinking
**Evaluating sign-in options**

In terms of acceptance, a significant change seems to be saving control. I could verify if anything is hidden, but without a positive aspect, maybe that's insufficient. A better idea might be to bypass the sign-up process using Clerk's "development instance," which could feature a "Sign in with email" option that doesn't require a captcha. However, sign-up has triggered a captcha, so I should check the `/sign-in` snapshot before proceeding.
exec
/bin/zsh -lc "cd /Users/chiko/.codex/skills/dev-browser && npx tsx <<'EOF'
import { connect, waitForPageLoad } from \"@/client.js\";

const client = await connect();
const page = await client.page(\"usdt-save-report\");

await page.goto(\"http://localhost:3000/sign-in\");
await waitForPageLoad(page);

const snapshot = await client.getAISnapshot(\"usdt-save-report\");
console.log(snapshot.split(\"\\n\").slice(0, 260).join(\"\\n\"));
await page.screenshot({ path: \"tmp/usdt-sign-in.png\", fullPage: true });
await client.disconnect();
EOF" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 2.66s:
- generic [active] [ref=e1]:
  - main [ref=e2]
  - region "Notifications alt+T"
  - button "Open Next.js Dev Tools" [ref=e8] [cursor=pointer]:
    - img [ref=e9]
  - alert [ref=e12]
(node:64442) ExperimentalWarning: CommonJS module /Users/chiko/.nvm/versions/node/v23.3.0/lib/node_modules/npm/node_modules/debug/src/node.js is loading ES Module /Users/chiko/.nvm/versions/node/v23.3.0/lib/node_modules/npm/node_modules/supports-color/index.js using require().
Support for loading ES Module in require() is an experimental feature and might change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">

viewed image /Users/chiko/.codex/skills/dev-browser/tmp/usdt-sign-in.png
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">

exec
/bin/zsh -lc "cd /Users/chiko/.codex/skills/dev-browser && npx tsx <<'EOF'
import { connect, waitForPageLoad } from \"@/client.js\";

const client = await connect();
const page = await client.page(\"usdt-save-report\");

await page.goto(\"http://localhost:3000/sign-in\");
await waitForPageLoad(page);
await page.waitForTimeout(3000);

const title = await page.title();
const text = await page.evaluate(() => document.body.innerText.slice(0, 500));
const htmlLen = (await page.content()).length;
const snapshot = await client.getAISnapshot(\"usdt-save-report\");
console.log({ url: page.url(), title, htmlLen, text });
console.log(snapshot.split(\"\\n\").slice(0, 240).join(\"\\n\"));

await page.screenshot({ path: \"tmp/usdt-sign-in-debug.png\", fullPage: true });
await client.disconnect();
EOF" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 4.58s:
{
  url: 'http://localhost:3000/sign-in',
  title: 'USDT (TRON) Blacklist Checker',
  htmlLen: 57298,
  text: 'Sign in to USDT wallet checker\n' +
    '\n' +
    'Welcome back! Please sign in to continue\n' +
    '\n' +
    'or\n' +
    '\n' +
    'Email address\n' +
    'Password\n' +
    'Continue\n' +
    'Don’t have an account?\n' +
    'Sign up\n' +
    '\n' +
    'Secured by\n' +
    '\n' +
    'Development mode'
}
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">

exec
/bin/zsh -lc 'rg -n "CAPTCHA|captcha|hcaptcha|turnstile|bot protection|botProtection" node_modules/@clerk -S | head -n 50' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 86ms:

file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">


thinking
I'm considering the situation where there are no matches. It could be that the code is bundled or minified, making it harder to find what I'm looking for. I realize I might need to search within the `node_modules` directory, specifically checking under `.pnpm`. Perhaps widening my search parameters will help too, as it feels like there might still be something worth discovering if I look beyond what I initially targeted. Let's see how that goes!
exec
/bin/zsh -lc 'rg -n "hcaptcha|turnstile|captcha" node_modules/.pnpm -S | head -n 50' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 419ms:
node_modules/.pnpm/@clerk+shared@3.43.1_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/@clerk/shared/dist/types/index.d.ts:1039:type CaptchaWidgetType = 'smart' | 'invisible' | null;
node_modules/.pnpm/@clerk+shared@3.43.1_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/@clerk/shared/dist/types/index.d.ts:1040:type CaptchaProvider = 'turnstile';
node_modules/.pnpm/@clerk+shared@3.43.1_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/@clerk/shared/dist/types/index.d.ts:1051:  captcha_public_key: string | null;
node_modules/.pnpm/@clerk+shared@3.43.1_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/@clerk/shared/dist/types/index.d.ts:1052:  captcha_widget_type: CaptchaWidgetType;
node_modules/.pnpm/@clerk+shared@3.43.1_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/@clerk/shared/dist/types/index.d.ts:1053:  captcha_public_key_invisible: string | null;
node_modules/.pnpm/@clerk+shared@3.43.1_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/@clerk/shared/dist/types/index.d.ts:1054:  captcha_provider: CaptchaProvider;
node_modules/.pnpm/@clerk+shared@3.43.1_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/@clerk/shared/dist/types/index.d.ts:1055:  captcha_oauth_bypass: OAuthStrategy[] | null;
node_modules/.pnpm/@clerk+shared@3.43.1_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/@clerk/shared/dist/types/index.d.ts:1056:  captcha_heartbeat?: boolean;
node_modules/.pnpm/@clerk+shared@3.43.1_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/@clerk/shared/dist/types/index.d.ts:1057:  captcha_heartbeat_interval_ms?: number;
node_modules/.pnpm/@clerk+shared@3.43.1_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/@clerk/shared/dist/types/index.d.ts:1090:  captchaPublicKey: string | null;
node_modules/.pnpm/@clerk+shared@3.43.1_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/@clerk/shared/dist/types/index.d.ts:1091:  captchaWidgetType: CaptchaWidgetType;
node_modules/.pnpm/@clerk+shared@3.43.1_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/@clerk/shared/dist/types/index.d.ts:1092:  captchaProvider: CaptchaProvider;
node_modules/.pnpm/@clerk+shared@3.43.1_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/@clerk/shared/dist/types/index.d.ts:1093:  captchaPublicKeyInvisible: string | null;
node_modules/.pnpm/@clerk+shared@3.43.1_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/@clerk/shared/dist/types/index.d.ts:1095:   * An array of OAuth strategies for which we will bypass the captcha.
node_modules/.pnpm/@clerk+shared@3.43.1_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/@clerk/shared/dist/types/index.d.ts:1097:   * This can also be used to bypass the captcha for a specific OAuth provider on a per-instance basis.
node_modules/.pnpm/@clerk+shared@3.43.1_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/@clerk/shared/dist/types/index.d.ts:1099:  captchaOauthBypass: OAuthStrategy[];
node_modules/.pnpm/@clerk+shared@3.43.1_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/@clerk/shared/dist/types/index.d.ts:1100:  captchaHeartbeat: boolean;
node_modules/.pnpm/@clerk+shared@3.43.1_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/@clerk/shared/dist/types/index.d.ts:1101:  captchaHeartbeatIntervalMs?: number;
node_modules/.pnpm/@clerk+shared@3.43.1_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/@clerk/shared/dist/types/index.d.ts:2919:  captcha_enabled: boolean;
node_modules/.pnpm/@clerk+shared@3.43.1_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/@clerk/shared/dist/types/index.d.ts:3953:  captcha_bypass?: boolean;
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">


thinking
**Reviewing parameters for login**

I’m considering minimal parameters for the login process. I want to include the email address, password, first name, and last name. I'm uncertain about `skip_password_requirement`—it might not be accepted, so I'll include `skip_password_checks: true`. While the password needs to meet requirements, using a strong password seems like a smart move. Also, I'm not sure if `skip_email_verification` is necessary. I’ll call the function and log the status and response keys. Let's move forward!
exec
/bin/zsh -lc "node <<'EOF'
import fs from \"node:fs\";

const secret = process.env.CLERK_SECRET_KEY;
if ("'!secret) throw new Error("Missing CLERK_SECRET_KEY in env");

const ts = Date.now();
const email = `codex.save.${ts}@example.com`;
const password = `S3cure!Pass${ts}`;

const res = await fetch("https://api.clerk.com/v1/users", {
  method: "POST",
  headers: {
    Authorization: `Bearer ${secret}`,
    "Content-Type": "application/json",
  },
  body: JSON.stringify({
    email_address: [email],
    password,
    first_name: "Codex",
    last_name: "Save",
    skip_password_checks: true,
  }),
});

const text = await res.text();
let json = null;
try {
  json = text ? JSON.parse(text) : null;
} catch {
  json = null;
}

if (!res.ok) {
  console.error("Create user failed", res.status, text.slice(0, 500));
  process.exit(1);
}

const userId = json?.id;
const emailId = Array.isArray(json?.email_addresses) ? json.email_addresses?.[0]?.id : undefined;

fs.writeFileSync("/tmp/usdt_clerk_test_user.json", JSON.stringify({ email, password, userId, emailId }, null, 2));
console.log(JSON.stringify({ created: true, userId, email }, null, 2));
EOF' in /Users/chiko/side_projects/usdt_blacklisted_web exited 1 in 119ms:
file:///Users/chiko/side_projects/usdt_blacklisted_web/[eval1]:4
if (!secret) throw new Error("Missing CLERK_SECRET_KEY in env");
                   ^

Error: Missing CLERK_SECRET_KEY in env
    at file:///Users/chiko/side_projects/usdt_blacklisted_web/[eval1]:4:20
    at ModuleJob.run (node:internal/modules/esm/module_job:271:25)
    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)
    at async onImport.tracePromise.__proto__ (node:internal/modules/esm/loader:217:26)
    at async ModuleLoader.eval (node:internal/modules/esm/loader:213:20)
    at async asyncRunEntryPointWithESMLoader (node:internal/modules/run_main:116:5)

Node.js v23.3.0
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">

exec
/bin/zsh -lc "set -euo pipefail
set -a
source .env
set +a
node <<'EOF'
import fs from \"node:fs\";

const secret = process.env.CLERK_SECRET_KEY;
if ("'!secret) throw new Error("Missing CLERK_SECRET_KEY in env");

const ts = Date.now();
const email = `codex.save.${ts}@example.com`;
const password = `S3cure!Pass${ts}`;

const res = await fetch("https://api.clerk.com/v1/users", {
  method: "POST",
  headers: {
    Authorization: `Bearer ${secret}`,
    "Content-Type": "application/json",
  },
  body: JSON.stringify({
    email_address: [email],
    password,
    first_name: "Codex",
    last_name: "Save",
    skip_password_checks: true,
  }),
});

const text = await res.text();
let json = null;
try {
  json = text ? JSON.parse(text) : null;
} catch {
  json = null;
}

if (!res.ok) {
  console.error("Create user failed", res.status, text.slice(0, 500));
  process.exit(1);
}

const userId = json?.id;
const emailId = Array.isArray(json?.email_addresses) ? json.email_addresses?.[0]?.id : undefined;

fs.writeFileSync("/tmp/usdt_clerk_test_user.json", JSON.stringify({ email, password, userId, emailId }, null, 2));
console.log(JSON.stringify({ created: true, userId, email }, null, 2));
EOF' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 1.09s:
{
  "created": true,
  "userId": "user_38f45oLLXBluEGkK45cSFyJLbpX",
  "email": "codex.save.1769177109650@example.com"
}
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">


thinking
**Verifying development setup**

I started the next development phase with `DATABASE_URL` pointing to local Postgres and using the `dev_hash_key` for `ADDRESS_HASH_KEY`. Now, I need to ensure that the `CREATE EXTENSION ...` migration is applied correctly. The API will call getDb with `DATABASE_URL` during save, and the dev server has those environment variables set. Additionally, `createSavedReport` uses `computeAddressHash`, which requires the `ADDRESS_HASH_KEY`. I’ve added a check for this in the API route. Now, I’ll test the full flow in the dev browser. Let's run it!
exec
/bin/zsh -lc "cd /Users/chiko/.codex/skills/dev-browser && npx tsx <<'EOF'
import fs from \"node:fs\";
import { connect, waitForPageLoad } from \"@/client.js\";

const creds = JSON.parse(fs.readFileSync(\"/tmp/usdt_clerk_test_user.json\", \"utf8\"));
const { email, password } = creds;

const client = await connect();
const page = await client.page(\"usdt-save-report\");

await page.goto(\"http://localhost:3000/sign-in\");
await waitForPageLoad(page);
await page.getByRole(\"textbox\", { name: \"Email address\" }).fill(email);
await page.getByRole(\"textbox\", { name: \"Password\" }).fill(password);
await page.getByRole(\"button\", { name: /continue/i }).click();

await page.waitForURL(\"http://localhost:3000/\", { timeout: 60_000 });

// Enable saving in settings.
await page.goto(\"http://localhost:3000/settings\");
await waitForPageLoad(page);

// Switch has aria-label \"Save screening history\".
const toggle = page.getByRole(\"switch\", { name: \"Save screening history\" });
await toggle.waitFor({ timeout: 30_000 });

const wasChecked = await toggle.getAttribute(\"aria-checked\");
if (wasChecked "'!== "true") {
  await toggle.click();
  await page.waitForTimeout(800);
}

// Run analysis.
await page.goto("http://localhost:3000/");
await waitForPageLoad(page);

const address = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
await page.getByRole("textbox").first().fill(address);
await page.getByRole("button", { name: /check/i }).click();

await page.getByText("Save this report").waitFor({ timeout: 60_000 });

// Save.
await page.getByRole("button", { name: /''^save$/i }).click();
await page.getByText("Report saved.").waitFor({ timeout: 60_000 });
await page.getByRole("button", { name: /saved/i }).waitFor({ timeout: 60_000 });

await page.screenshot({ path: "tmp/usdt-save-report-signed-in.png", fullPage: true });

console.log(JSON.stringify({ signedIn: true, loggingEnabled: true, saveControlVisible: true }, null, 2));

await client.disconnect();
EOF' in /Users/chiko/side_projects/usdt_blacklisted_web exited 1 in 33.41s:
(node:66452) ExperimentalWarning: CommonJS module /Users/chiko/.nvm/versions/node/v23.3.0/lib/node_modules/npm/node_modules/debug/src/node.js is loading ES Module /Users/chiko/.nvm/versions/node/v23.3.0/lib/node_modules/npm/node_modules/supports-color/index.js using require().
Support for loading ES Module in require() is an experimental feature and might change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
node:internal/modules/run_main:122
    triggerUncaughtException(
    ^

locator.waitFor: Timeout 30000ms exceeded.
Call log:
[2m  - waiting for getByRole('switch', { name: 'Save screening history' }) to be visible[22m

    at /Users/chiko/.codex/skills/dev-browser/[eval1]:24:14 {
  name: 'TimeoutError'
}

Node.js v23.3.0
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">


thinking
**Inspecting settings for switch**

I couldn't find the switch in the settings, so I think I should inspect the settings page further. I'll need to get an accessibility snapshot to locate the label and reference. After navigating to the /settings page, I'll script a way to print the snapshot. This way, I can examine everything properly and see what's going wrong! Let's make sure I cover all my bases.
exec
/bin/zsh -lc "cd /Users/chiko/.codex/skills/dev-browser && npx tsx <<'EOF'
import { connect, waitForPageLoad } from \"@/client.js\";

const client = await connect();
const page = await client.page(\"usdt-save-report\");

await page.goto(\"http://localhost:3000/settings\");
await waitForPageLoad(page);
await page.waitForTimeout(1500);

const snapshot = await client.getAISnapshot(\"usdt-save-report\");
console.log(snapshot.split(\"\\n\").slice(0, 320).join(\"\\n\"));
await page.screenshot({ path: \"tmp/usdt-settings.png\", fullPage: true });

await client.disconnect();
EOF" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 2.96s:
- generic [active] [ref=e1]:
  - generic [ref=e2]:
    - banner [ref=e3]:
      - generic [ref=e4]:
        - generic [ref=e5]:
          - link "USDT Checker" [ref=e6] [cursor=pointer]:
            - /url: /
          - navigation [ref=e7]:
            - link "Settings" [ref=e8] [cursor=pointer]:
              - /url: /settings
        - button "Switch to dark mode" [ref=e10]:
          - img
    - main [ref=e11]:
      - generic [ref=e12]:
        - generic [ref=e13]:
          - heading "Settings" [level=1] [ref=e14]
          - paragraph [ref=e15]: Control privacy defaults for your account.
        - generic [ref=e16]:
          - generic [ref=e17]:
            - heading "Privacy" [level=3] [ref=e18]
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">



thinking
**Inspecting sign-in logic**

I need to check the sign-in page for errors after clicking 'continue.' It seems like I might be missing something. The sign-in page should redirect properly after a successful sign-in, or it stays if credentials are incorrect. I suspect the issue arises from the way the API accesses user data, potentially returning null if not in the right context. If we're using cookies correctly, fetching settings should work. So, why am I still seeing unauthorized? It might be worth double-checking fetch credentials.
thinking
**Troubleshooting cookie issues**

I’m considering that the cookie domain might be problematic if it's set to `localhost`. It might be related to how I started the Next.js dev server without properly setting up the `NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY` environment variable. Next.js loads environment variables at build time, but if I start from a subshell, it may miss some keys. The `.env` file should cover these settings, so `clerkEnabled` in the UI should show true. I'll verify if Clerk is actually used in the dashboard layout.
exec
/bin/zsh -lc "sed -n '1,220p' src/app/(dashboard)/layout.tsx" in /Users/chiko/side_projects/usdt_blacklisted_web exited 1 in 61ms:
zsh:1: no matches found: src/app/(dashboard)/layout.tsx
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">


thinking
**Resolving Zsh Globbing Issues**

I'm encountering a problem with Zsh glob patterns. It seems that using parentheses is causing some issues, and I need to either quote or escape them to make things work smoothly. To approach this, I'll consider using `sed -n` while ensuring that I properly quote or escape the necessary elements. Hopefully, this will clear up the complications I'm facing!
exec
/bin/zsh -lc "sed -n '1,220p' 'src/app/(dashboard)/layout.tsx'" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 60ms:
import Link from "next/link";

import { ThemeToggle } from "@/components/theme-toggle";
import { Separator } from "@/components/ui/separator";

export default function DashboardLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <div className="min-h-screen">
      <header className="border-b border-border/60 bg-card/60 backdrop-blur-sm">
        <div className="mx-auto flex w-full max-w-5xl items-center justify-between px-4 py-4 sm:px-6">
          <div className="flex items-center gap-3">
            <Link href="/" className="font-semibold tracking-tight text-foreground">
              USDT Checker
            </Link>
            <Separator orientation="vertical" className="h-5 bg-border/60" />
            <nav className="flex items-center gap-4 text-sm">
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">

exec
/bin/zsh -lc 'tail -n 80 /tmp/usdt_blacklisted_web_next_dev.log || true' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 68ms:
tail: /tmp/usdt_blacklisted_web_next_dev.log: No such file or directory
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">

exec
/bin/zsh -lc 'lsof -iTCP:3000 -sTCP:LISTEN -n -P | head -n 20 && ps -p $(lsof -t -iTCP:3000 -sTCP:LISTEN) -o pid,command | sed -n '"'1,5p'" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 124ms:
COMMAND   PID  USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME
node    46239 chiko   17u  IPv6 0x4a85b4ac09c868f4      0t0  TCP *:3000 (LISTEN)
  PID COMMAND
46239 next-server (v16.1.4) 
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">



thinking
**Troubleshooting server logs**

I'm looking into our server logs to figure things out. It seems like the next development task is using `pnpm start`, but I might usually see `next dev`. I'm checking the environment setup because there might be some remnants from previous runs. I realize we need to restart the dev server with the correct environment variables without leaking any secrets. I'll ensure everything is set up properly before restarting the process on port 3000. So, I'll double-check the setup!
thinking
**Managing server processes**

I'm planning to run in the background and capture logs to the `/tmp` directory for easy access. So, first things first: I need to kill process 46239 using the `kill` command. After that, I'll start everything back up. I want to make sure the logs are properly captured and managed this time around. I just need to be cautious and methodical to ensure everything goes smoothly!
exec
/bin/zsh -lc 'set -euo pipefail
PID=$(lsof -t -iTCP:3000 -sTCP:LISTEN || true)
if [ -n "${PID:-}" ]; then
  kill "$PID" || true
  sleep 1
fi
NEXT_LOG="/tmp/usdt_blacklisted_web_next_dev.log"
DB_URL="postgres://postgres@localhost:54329/postgres"
ADDRESS_HASH_KEY="dev_hash_key"
set -a
source .env
set +a
(DATABASE_URL="$DB_URL" ADDRESS_HASH_KEY="$ADDRESS_HASH_KEY" pnpm dev >"$NEXT_LOG" 2>&1 &)
# wait for server
for i in {1..30}; do
  if lsof -iTCP:3000 -sTCP:LISTEN >/dev/null 2>&1; then
    break
  fi
  sleep 1
done
lsof -iTCP:3000 -sTCP:LISTEN -n -P | head -n 2

tail -n 20 "$NEXT_LOG" || true
' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 2.23s:
COMMAND   PID  USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME
node    68120 chiko   13u  IPv6 0x56aef0c4594fa766      0t0  TCP *:3000 (LISTEN)

> usdt_blacklisted_web@0.1.0 dev /Users/chiko/side_projects/usdt_blacklisted_web
> next dev

▲ Next.js 16.1.4 (Turbopack)
- Local:         http://localhost:3000
- Network:       http://192.168.1.40:3000
- Environments: .env

✓ Starting...
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">


thinking
**Testing server functionality**

I've started the dev server, and the logs show that it's loading the .env file, which is great! Now I'm thinking the middleware should have access to those keys. I want to retry the sign-in and settings toggle flow. I'll reuse the existing session in the dev browser, but I'm worried we might lose the state since the server was restarted. So, I'll run the script from scratch by going to sign in, filling in the email and password from the file, and then check the settings. Let's get started!
exec
/bin/zsh -lc "cd /Users/chiko/.codex/skills/dev-browser && npx tsx <<'EOF'
import fs from \"node:fs\";
import { connect, waitForPageLoad } from \"@/client.js\";

const { email, password } = JSON.parse(fs.readFileSync(\"/tmp/usdt_clerk_test_user.json\", \"utf8\"));

const client = await connect();
const page = await client.page(\"usdt-save-report\", { viewport: { width: 1280, height: 900 } });

await page.goto(\"http://localhost:3000/sign-in\");
await waitForPageLoad(page);
await page.getByRole(\"textbox\", { name: \"Email address\" }).fill(email);
await page.getByRole(\"textbox\", { name: \"Password\" }).fill(password);
await page.getByRole(\"button\", { name: /continue/i }).click();

await page.waitForURL(\"http://localhost:3000/\", { timeout: 60_000 });

// Ensure we are signed in (User button should exist)
const userButtonCount = await page.getByRole(\"button\").filter({ hasText: \"\" }).count().catch(() => 0);
console.log({ signedInRedirect: true, userButtonCount });

await page.goto(\"http://localhost:3000/settings\");
await waitForPageLoad(page);
await page.waitForTimeout(1500);

const snapshot = await client.getAISnapshot(\"usdt-save-report\");
console.log(snapshot.split(\"\\n\").slice(0, 240).join(\"\\n\"));

await page.screenshot({ path: \"tmp/usdt-settings-after-signin.png\", fullPage: true });
await client.disconnect();
EOF" in /Users/chiko/side_projects/usdt_blacklisted_web exited 124 in 10.03s:
(node:68335) ExperimentalWarning: CommonJS module /Users/chiko/.nvm/versions/node/v23.3.0/lib/node_modules/npm/node_modules/debug/src/node.js is loading ES Module /Users/chiko/.nvm/versions/node/v23.3.0/lib/node_modules/npm/node_modules/supports-color/index.js using require().
Support for loading ES Module in require() is an experimental feature and might change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">


thinking
**Adjusting script timeout**

It looks like the script timed out after just 10 seconds because I didn't specify the `timeout_ms`. The default for the `shell_command` is 10 seconds. To avoid this, I need to set the timeout to 600,000 milliseconds. I'll go ahead and adjust that in the `functions.shell_command`. Once that's done, I'll rerun it with the proper timeout to make sure it executes without interruption.
exec
/bin/zsh -lc "cd /Users/chiko/.codex/skills/dev-browser && npx tsx <<'EOF'
import fs from \"node:fs\";
import { connect, waitForPageLoad } from \"@/client.js\";

const { email, password } = JSON.parse(fs.readFileSync(\"/tmp/usdt_clerk_test_user.json\", \"utf8\"));

const client = await connect();
const page = await client.page(\"usdt-save-report\", { viewport: { width: 1280, height: 900 } });

await page.goto(\"http://localhost:3000/sign-in\");
await waitForPageLoad(page);
await page.getByRole(\"textbox\", { name: \"Email address\" }).fill(email);
await page.getByRole(\"textbox\", { name: \"Password\" }).fill(password);
await page.getByRole(\"button\", { name: /continue/i }).click();

await page.waitForURL(\"http://localhost:3000/\", { timeout: 60_000 });

await page.goto(\"http://localhost:3000/settings\");
await waitForPageLoad(page);
await page.waitForTimeout(1500);

const snapshot = await client.getAISnapshot(\"usdt-save-report\");
console.log(snapshot.split(\"\\n\").slice(0, 260).join(\"\\n\"));

await page.screenshot({ path: \"tmp/usdt-settings-after-signin.png\", fullPage: true });
await client.disconnect();
EOF" in /Users/chiko/side_projects/usdt_blacklisted_web exited 1 in 31.38s:
(node:68634) ExperimentalWarning: CommonJS module /Users/chiko/.nvm/versions/node/v23.3.0/lib/node_modules/npm/node_modules/debug/src/node.js is loading ES Module /Users/chiko/.nvm/versions/node/v23.3.0/lib/node_modules/npm/node_modules/supports-color/index.js using require().
Support for loading ES Module in require() is an experimental feature and might change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
node:internal/modules/run_main:122
    triggerUncaughtException(
    ^

locator.fill: Timeout 30000ms exceeded.
Call log:
[2m  - waiting for getByRole('textbox', { name: 'Email address' })[22m

    at /Users/chiko/.codex/skills/dev-browser/[eval1]:11:60 {
  name: 'TimeoutError'
}

Node.js v23.3.0
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">

exec
/bin/zsh -lc "cd /Users/chiko/.codex/skills/dev-browser && npx tsx <<'EOF'
import { connect, waitForPageLoad } from \"@/client.js\";

const client = await connect();
const page = await client.page(\"usdt-save-report\");

await page.goto(\"http://localhost:3000/sign-in\");
await waitForPageLoad(page);
await page.waitForTimeout(1000);

const snapshot = await client.getAISnapshot(\"usdt-save-report\");
console.log(snapshot.split(\"\\n\").slice(0, 220).join(\"\\n\"));
await page.screenshot({ path: \"tmp/usdt-sign-in-after-restart.png\", fullPage: true });
await client.disconnect();
EOF" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 2.68s:
- generic [active] [ref=e1]:
  - generic [ref=e2]:
    - banner [ref=e3]:
      - img "Chikocorp TRON Security" [ref=e5]
      - generic [ref=e7]:
        - generic [ref=e8]: Tron wallet blacklist checker
        - generic [ref=e9]: TRON Security by Chikocorp
      - generic [ref=e10]:
        - button "Open user menu" [ref=e12] [cursor=pointer]:
          - img "Codex Save's logo" [ref=e15]
        - button "Switch to dark mode" [ref=e17]:
          - img
    - main [ref=e18]:
      - generic [ref=e19]:
        - generic [ref=e20]:
          - heading "USDT (TRON) Blacklist Checker" [level=1] [ref=e21]
          - paragraph [ref=e22]: Check whether a TRON address is blacklisted by the USDT smart contract. No keys. No tracking.
        - generic [ref=e23]:
          - generic [ref=e24]:
            - img [ref=e25]
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">


thinking
**Navigating sign-in session**

Now that we're on the homepage after signing in, it looks like our previous sign-in succeeded. That's good to know because it explains why we couldn't find the textbox earlier. We can now move forward to enable logging in settings, but we had issues earlier with unauthorized access due to disabled middleware. 

Okay, since the middleware should be enabled again after the server restart, let's make sure our session is still recognized and try accessing the /settings page to find the switch.
exec
/bin/zsh -lc "cd /Users/chiko/.codex/skills/dev-browser && npx tsx <<'EOF'
import { connect, waitForPageLoad } from \"@/client.js\";

const client = await connect();
const page = await client.page(\"usdt-save-report\");

await page.goto(\"http://localhost:3000/settings\");
await waitForPageLoad(page);
await page.waitForTimeout(1500);

const snapshot = await client.getAISnapshot(\"usdt-save-report\");
console.log(snapshot.split(\"\\n\").slice(0, 320).join(\"\\n\"));
await page.screenshot({ path: \"tmp/usdt-settings-signed-in.png\", fullPage: true });

await client.disconnect();
EOF" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 3.00s:
- generic [active] [ref=e1]:
  - generic [ref=e2]:
    - banner [ref=e3]:
      - generic [ref=e4]:
        - generic [ref=e5]:
          - link "USDT Checker" [ref=e6] [cursor=pointer]:
            - /url: /
          - navigation [ref=e7]:
            - link "Settings" [ref=e8] [cursor=pointer]:
              - /url: /settings
        - button "Switch to dark mode" [ref=e10]:
          - img
    - main [ref=e11]:
      - generic [ref=e12]:
        - generic [ref=e13]:
          - heading "Settings" [level=1] [ref=e14]
          - paragraph [ref=e15]: Control privacy defaults for your account.
        - generic [ref=e16]:
          - generic [ref=e17]:
            - heading "Privacy" [level=3] [ref=e18]
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">

exec
/bin/zsh -lc "cd /Users/chiko/.codex/skills/dev-browser && npx tsx <<'EOF'
import { connect } from \"@/client.js\";

const client = await connect();
const page = await client.page(\"usdt-save-report\");

await page.goto(\"http://localhost:3000/\");
await page.waitForTimeout(500);

const result = await page.evaluate(async () => {
  const res = await fetch('/api/user-settings', { credentials: 'include' });
  const text = await res.text();
  return { status: res.status, text: text.slice(0, 400) };
});

console.log(result);
await client.disconnect();
EOF" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 1.83s:
{ status: 401, text: '{"error":"Unauthorized."}' }
(node:69562) ExperimentalWarning: CommonJS module /Users/chiko/.nvm/versions/node/v23.3.0/lib/node_modules/npm/node_modules/debug/src/node.js is loading ES Module /Users/chiko/.nvm/versions/node/v23.3.0/lib/node_modules/npm/node_modules/supports-color/index.js using require().
Support for loading ES Module in require() is an experimental feature and might change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">






thinking
**Analyzing authentication middleware**

I'm diving into the middleware code where it checks if a route is public. It seems that for /api/user-settings, it's returning early, skipping the auth setup. But I wonder if `clerkMiddleware` still runs for public routes to establish the auth context.

The docs suggest there's a way to conditionally call `auth()` if it's not a public request, but I'm uncertain if this means `clerkMiddleware` provides any auth context at all for those routes marked as public, like /api/user-settings.
thinking
**Clarifying authentication logic**

I'm trying to figure out the authentication data in route handlers regarding `clerkMiddleware` and how it sets the request state. It seems like `clerkMiddleware` might execute for every request, but I'm questioning if it always provides authentication context, particularly for `/api/user-settings`.

The `isPublicRoute` logic makes it return early, which could mean that `clerkMiddleware` doesn't authenticate until `auth()` is explicitly called. If that's true, then public routes might not receive the necessary authentication context, leading to failures in their route handlers. That makes sense to me.
thinking
**Exploring authentication behavior**

I'm trying to understand how the `/api/analyze` route determines if it's authenticated. It calls `auth()` within its route, but since it’s a public route, I’m wondering if the middleware shouldn't authenticate unless `auth()` is explicitly called.

If it doesn't, the route would always see `userId` as null, meaning it would always be unauthenticated. Could it be that `access.authenticated` is false even if the user is signed in? 

To allow `auth()` in public APIs without redirection, I think the middleware should still call `auth()` for those routes; this way, it can build the state without redirecting if no user is found.
thinking
**Refining the authentication middleware**

I'm looking at the middleware code. It seems like calling `auth()` twice might be unnecessary, as we can streamline it to just one call. 

By awaiting `auth()` once and then checking if the route is public, I can return early if it is. This ensures that authentication gets called for all requests, including public ones, which might be essential for fixing the gating of report-saving and authentication UI.

However, I wonder if these changes could impact other existing functionality. Are we looking at a regression fix here?
thinking
**Investigating user settings authentication**

I’m considering how US-005 is linked to setting up the settings route. There might be a bug where `/api/user-settings` consistently returns a 401 status. 

Tests show that when `auth()` is called, it returns valid user data, but in the live environment, it seems to fail. If middleware isn’t calling `auth()` for public routes, it would lead to this issue. 

I’m noticing we get 401s even while signed in, suggesting a disconnect between the client and server's authentication states. I'll check whether `/api/analyze` returns `access.authenticated` as true for this signed-in session. Let's fetch that data!
exec
/bin/zsh -lc "cd /Users/chiko/.codex/skills/dev-browser && npx tsx <<'EOF'
import { connect } from \"@/client.js\";

const client = await connect();
const page = await client.page(\"usdt-save-report\");

const address = \"T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb\";
const result = await page.evaluate(async (addr) => {
  const res = await fetch('/api/analyze', {
    method: 'POST',
    headers: { 'content-type': 'application/json', 'user-agent': 'dev-browser' },
    credentials: 'include',
    body: JSON.stringify({ address: addr }),
  });
  const json = await res.json().catch(() => null);
  return { status: res.status, authenticated: json?.access?.authenticated, hasError: Boolean(json?.error) };
}, address);

console.log(result);
await client.disconnect();
EOF" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 4.07s:
{ status: 200, authenticated: false, hasError: false }
(node:69985) ExperimentalWarning: CommonJS module /Users/chiko/.nvm/versions/node/v23.3.0/lib/node_modules/npm/node_modules/debug/src/node.js is loading ES Module /Users/chiko/.nvm/versions/node/v23.3.0/lib/node_modules/npm/node_modules/supports-color/index.js using require().
Support for loading ES Module in require() is an experimental feature and might change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">




thinking
**Analyzing authentication issues**

I'm diagnosing a problem where the route sees unauthenticated access even though the client is signed in. This seems to be a middleware issue with the API routes. It looks like the public middleware might not set the auth context correctly. If auth() fails, it could affect the whole app. I think I need to adjust the middleware for public routes to still call auth(). This is crucial for testing US-006 and ensuring proper user functionality.
thinking
**Adjusting middleware scope**

It looks like adjusting the middleware is necessary. I should verify with a real browser, but I've already done some checks. The change would involve always calling auth() to populate the authentication context. I'm unsure how this affects the route handler that uses auth() directly. It seems the auth() function likely relies on headers that the middleware has set. So, I need to ensure that the middleware calls auth() for proper user authentication and to set the required headers.
thinking
**Clarifying cookie handling**

I'm considering that the route handler might utilize Next.js's request, which includes cookies. It seems that the auth() function in the route handler may not need middleware, but it does require the `CLERK_SECRET_KEY` and the session cookie `__session`. When signing in, the cookie might set for the `localhost:3000` domain, but perhaps not due to using the Clerk domain. It’s essential to investigate the cookies in the developer tools to clarify their status.
exec
/bin/zsh -lc "cd /Users/chiko/.codex/skills/dev-browser && npx tsx <<'EOF'
import { connect } from \"@/client.js\";

const client = await connect();
const page = await client.page(\"usdt-save-report\");

const cookies = await page.context().cookies(\"http://localhost:3000/\");
console.log(cookies.map((c) => ({ name: c.name, domain: c.domain, path: c.path, httpOnly: c.httpOnly, sameSite: c.sameSite, secure: c.secure })).slice(0, 30));
await client.disconnect();
EOF" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 979ms:
[
  {
    name: '__clerk_db_jwt_QYDEmpDp',
    domain: 'localhost',
    path: '/',
    httpOnly: false,
    sameSite: 'Lax',
    secure: false
  },
  {
    name: '__clerk_db_jwt',
    domain: 'localhost',
    path: '/',
    httpOnly: false,
    sameSite: 'Lax',
    secure: false
  },
  {
    name: 'clerk_active_context',
    domain: 'localhost',
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">






thinking
**Testing environment variables**

I think there's a possibility that `NEXT_PUBLIC` might not be set correctly in the server runtime, even though it should be. If only the secret is set, auth might still be allowed, but that could lead to issues, especially with a 401 error if `NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY` isn’t set. I'll check if both variables are being exposed correctly and directly test if access to /settings is protected to confirm if the middleware is disabled.
thinking
**Checking settings access**

I'm noticing that we can access /settings without being redirected when signed out, which suggests it might be disabled. But wait, what if it's enabled but /settings is in the public routes? In that case, it should redirect when not signed in, but it doesn't. So, I plan to open a new incognito window to check this without any stored cookies. By using `page.context().clearCookies()`, I can test the access to /settings without losing my signed-in session. I'm ensuring each page has its own context for testing.
thinking
**Isolating browser context**

In Playwright, I realize that pages in the same browser context share cookies. It seems like the `dev-browser` client.page might use a persistent context across pages, which isn’t ideal for isolation. I’m curious if the API allows creating a new context—maybe `page.context().browser().newContext()` could work. For now, I might just fetch `/api/user-settings` using the same cookies, although I suspect a 401 error will arise due to middleware issues. The key aspect might be that the `CLERK_SECRET_KEY` isn't accessible in the Edge runtime, so I need to check if enabling the clerkMiddleware can proceed without it.
thinking
**Investigating redirection issues**

I'm thinking for the redirection, it may rely on the publishable key. However, I’m concerned about whether `@clerk/nextjs/server` middleware in Edge requires the secret key. If it's missing, it might throw an error with each request, which is not ideal. I'm wondering if the middleware uses the `CLERK_PUBLISHABLE_KEY` instead. It's unclear whether the secret key isn't accessible due to Next's handling of environment variables unless runtime is set to 'nodejs'. I should check if the secret key is set in the `pnpm dev` environment or if it's being filtered out.
thinking
**Investigating Clerk authentication issues**

I realize we started `pnpm dev` with a command that loads our `.env` file, which includes a blank `DATABASE_URL`. The issue might be that Clerk's authentication relies on `NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY` and `CLERK_SECRET_KEY` being the same as the client’s. The 401 I encountered could be due to the `/api/user-settings` being excluded from public routes, which prevents `clerkMiddleware` from setting the `Clerk-Auth` state. To confirm this, I should check response headers from `/api/analyze` for `x-clerk-auth-status`. I'll fetch that and see if the header is present, which would indicate if the middleware is running.
exec
/bin/zsh -lc "cd /Users/chiko/.codex/skills/dev-browser && npx tsx <<'EOF'
import { connect } from \"@/client.js\";

const client = await connect();
const page = await client.page(\"usdt-save-report\");

const headers = await page.evaluate(async () => {
  const res = await fetch('/api/user-settings', { credentials: 'include' });
  const keys = Array.from(res.headers.keys());
  const interesting = keys.filter((k) => k.toLowerCase().includes('clerk') || k.toLowerCase().includes('auth'));
  const out = {};
  for (const k of interesting) out[k] = res.headers.get(k);
  return { status: res.status, interesting, out };
});

console.log(headers);
await client.disconnect();
EOF" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 1.10s:
{ status: 401, interesting: [], out: {} }
(node:70842) ExperimentalWarning: CommonJS module /Users/chiko/.nvm/versions/node/v23.3.0/lib/node_modules/npm/node_modules/debug/src/node.js is loading ES Module /Users/chiko/.nvm/versions/node/v23.3.0/lib/node_modules/npm/node_modules/supports-color/index.js using require().
Support for loading ES Module in require() is an experimental feature and might change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..98f20d10190d53541d29d61877d795331e2910cc
--- a/middleware.ts
+++ b/middleware.ts
@@ -8,6 +8,7 @@
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">






thinking
**Verifying secret variables in Node**

I’m checking whether `clerkMiddleware` needs a secret. It probably uses `process.env.CLERK_SECRET_KEY`, which could cause issues if it's missing. In our environment, the secret is set, but I wonder if the middleware can access it. I should run a quick Node script to confirm that `process.env.CLERK_SECRET_KEY` exists. I remember Next uses Edge runtime for middleware, and it looks like secret variables only carry over if they’re part of the build output. It's likely that in development, the secret is missing from middleware.
thinking
**Considering edge runtime limitations**

I understand that Next's edge runtime doesn’t fully support Node APIs, but env variables might still work, though there could be a bug. To resolve compatibility across environments, I could base `clerkEnabled` on the presence of the publishable key alone. In the callback, I'll use `auth()` to check the user. If the secret is missing in middleware runtime and `auth()` throws an error, we can catch that and treat it as unauthorized. 

But wait—route handlers in Node still have the secret. They might need the middleware active, which complicates things.
thinking
**Modifying middleware for Clerk**

I’m thinking of changing the middleware to check if the publishable key is present. This will determine if `clerkEnabled` should be true or false. In the middleware function, I’ll attempt to get the authentication state. If `auth()` throws an error, especially if the route is public, I should handle that gracefully.

However, this setup could break if the publishable key is set but the secret isn’t, which might cause `clerkMiddleware` to throw before the callback runs. Still, in most deployments, both keys are likely set, so that might not be an issue. But I’m concerned that `CLERK_SECRET_KEY` may not be accessible in the middleware environment when it should be.
thinking
**Examining clerk middleware needs**

I’m wondering if `process.env.CLERK_SECRET_KEY` isn’t accessible because Next doesn’t expose non-`NEXT_PUBLIC` variables to edge environments, making it undefined. However, route handlers still have access. But do we actually need to check the secret in the middleware? If the edge can’t see the secret, maybe we should rely solely on the publishable key.

It’s possible that Clerk’s middleware in edge uses `CLERK_SECRET_KEY` through some configuration, but if it can’t access the secret, it would fail anyway. To satisfy the requirements, I could modify `clerkEnabled` not to require the secret, while ensuring `auth()` is called for all requests to support server-side authentication in route handlers. But I’m uncertain if changing `clerkEnabled` is safe.
thinking
**Adjusting middleware for Clerk**

This change seems acceptable and may fix the current bug with the `/settings` route not being protected if the secret isn't available. They likely want to disable Clerk in deployments without keys, so if I rely only on the publishable key, it might cause errors when the secret is missing. 

I could set the `CLERK_SECRET_KEY` as an environment variable in `next.config.ts`, but I need to check if `middleware.ts` sees that key by force-setting `clerkEnabled` to true. I want to implement a quick test to see if `/api/user-settings` starts working again. Thus, I’ll change the middleware to always call `auth()` to set request headers and protect public routes properly. I will ensure this call does not throw errors for public routes and revise the middleware based on that. I'll also patch any relevant tests.
file update
M /Users/chiko/side_projects/usdt_blacklisted_web/middleware.ts
@@ -3,3 +3,3 @@
 
-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
+const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
 
@@ -15,8 +15,7 @@
 
-const clerk = clerkMiddleware((auth, req) => {
+const clerk = clerkMiddleware(async (auth, req) => {
+  const { userId, redirectToSignIn } = await auth();
   if (isPublicRoute(req)) return;
-  return auth().then(({ userId, redirectToSignIn }) => {
-    if (!userId) return redirectToSignIn();
-    return undefined;
-  });
+  if (!userId) return redirectToSignIn();
+  return undefined;
 });
apply_patch(auto_approved=true) exited 0 in 84ms:
Success. Updated the following files:
M middleware.ts
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..23fbb8e377e5f4c495aa20396001d9b81dd66f44
--- a/middleware.ts
+++ b/middleware.ts
@@ -1,23 +1,23 @@
 import { NextResponse } from "next/server";
 import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
 
-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
+const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
 
 const isPublicRoute = createRouteMatcher([
   "/",
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
 
-const clerk = clerkMiddleware((auth, req) => {
+const clerk = clerkMiddleware(async (auth, req) => {
+  const { userId, redirectToSignIn } = await auth();
   if (isPublicRoute(req)) return;
-  return auth().then(({ userId, redirectToSignIn }) => {
-    if (!userId) return redirectToSignIn();
-    return undefined;
-  });
+  if (!userId) return redirectToSignIn();
+  return undefined;
 });
 
 export default clerkEnabled ? clerk : () => NextResponse.next();
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">

file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..23fbb8e377e5f4c495aa20396001d9b81dd66f44
--- a/middleware.ts
+++ b/middleware.ts
@@ -1,23 +1,23 @@
 import { NextResponse } from "next/server";
 import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
 
-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
+const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
 
 const isPublicRoute = createRouteMatcher([
   "/",
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
 
-const clerk = clerkMiddleware((auth, req) => {
+const clerk = clerkMiddleware(async (auth, req) => {
+  const { userId, redirectToSignIn } = await auth();
   if (isPublicRoute(req)) return;
-  return auth().then(({ userId, redirectToSignIn }) => {
-    if (!userId) return redirectToSignIn();
-    return undefined;
-  });
+  if (!userId) return redirectToSignIn();
+  return undefined;
 });
 
 export default clerkEnabled ? clerk : () => NextResponse.next();
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">

exec
/bin/zsh -lc './ralph log "Adjusted Clerk middleware to enable with publishable key and always evaluate auth() so route handlers can see sessions"' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 82ms:

file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..23fbb8e377e5f4c495aa20396001d9b81dd66f44
--- a/middleware.ts
+++ b/middleware.ts
@@ -1,23 +1,23 @@
 import { NextResponse } from "next/server";
 import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
 
-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
+const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
 
 const isPublicRoute = createRouteMatcher([
   "/",
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
 
-const clerk = clerkMiddleware((auth, req) => {
+const clerk = clerkMiddleware(async (auth, req) => {
+  const { userId, redirectToSignIn } = await auth();
   if (isPublicRoute(req)) return;
-  return auth().then(({ userId, redirectToSignIn }) => {
-    if (!userId) return redirectToSignIn();
-    return undefined;
-  });
+  if (!userId) return redirectToSignIn();
+  return undefined;
 });
 
 export default clerkEnabled ? clerk : () => NextResponse.next();
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">

exec
/bin/zsh -lc 'set -euo pipefail
PID=$(lsof -t -iTCP:3000 -sTCP:LISTEN || true)
if [ -n "${PID:-}" ]; then
  kill "$PID" || true
  sleep 1
fi
NEXT_LOG="/tmp/usdt_blacklisted_web_next_dev.log"
DB_URL="postgres://postgres@localhost:54329/postgres"
ADDRESS_HASH_KEY="dev_hash_key"
set -a
source .env
set +a
(DATABASE_URL="$DB_URL" ADDRESS_HASH_KEY="$ADDRESS_HASH_KEY" pnpm dev >"$NEXT_LOG" 2>&1 &)
for i in {1..30}; do
  if lsof -iTCP:3000 -sTCP:LISTEN >/dev/null 2>&1; then break; fi
  sleep 1
done
lsof -iTCP:3000 -sTCP:LISTEN -n -P | head -n 2
' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 2.24s:
COMMAND   PID  USER   FD   TYPE            DEVICE SIZE/OFF NODE NAME
node    71753 chiko   13u  IPv6 0xd119fab15603d9b      0t0  TCP *:3000 (LISTEN)
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..23fbb8e377e5f4c495aa20396001d9b81dd66f44
--- a/middleware.ts
+++ b/middleware.ts
@@ -1,23 +1,23 @@
 import { NextResponse } from "next/server";
 import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
 
-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
+const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
 
 const isPublicRoute = createRouteMatcher([
   "/",
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
 
-const clerk = clerkMiddleware((auth, req) => {
+const clerk = clerkMiddleware(async (auth, req) => {
+  const { userId, redirectToSignIn } = await auth();
   if (isPublicRoute(req)) return;
-  return auth().then(({ userId, redirectToSignIn }) => {
-    if (!userId) return redirectToSignIn();
-    return undefined;
-  });
+  if (!userId) return redirectToSignIn();
+  return undefined;
 });
 
 export default clerkEnabled ? clerk : () => NextResponse.next();
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">

exec
/bin/zsh -lc "cd /Users/chiko/.codex/skills/dev-browser && npx tsx <<'EOF'
import { connect } from \"@/client.js\";

const client = await connect();
const page = await client.page(\"usdt-save-report\");

await page.goto(\"http://localhost:3000/\");
await page.waitForTimeout(800);

const userSettings = await page.evaluate(async () => {
  const res = await fetch('/api/user-settings', { credentials: 'include' });
  const json = await res.json().catch(() => null);
  return { status: res.status, json };
});

const analyze = await page.evaluate(async () => {
  const res = await fetch('/api/analyze', {
    method: 'POST',
    headers: { 'content-type': 'application/json', 'user-agent': 'dev-browser' },
    credentials: 'include',
    body: JSON.stringify({ address: 'T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb' }),
  });
  const json = await res.json().catch(() => null);
  return { status: res.status, authenticated: json?.access?.authenticated };
});

console.log({ userSettings, analyze });
await client.disconnect();
EOF" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 5.16s:
{
  userSettings: { status: 401, json: { error: 'Unauthorized.' } },
  analyze: { status: 200, authenticated: false }
}
(node:71913) ExperimentalWarning: CommonJS module /Users/chiko/.nvm/versions/node/v23.3.0/lib/node_modules/npm/node_modules/debug/src/node.js is loading ES Module /Users/chiko/.nvm/versions/node/v23.3.0/lib/node_modules/npm/node_modules/supports-color/index.js using require().
Support for loading ES Module in require() is an experimental feature and might change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..23fbb8e377e5f4c495aa20396001d9b81dd66f44
--- a/middleware.ts
+++ b/middleware.ts
@@ -1,23 +1,23 @@
 import { NextResponse } from "next/server";
 import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
 
-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
+const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
 
 const isPublicRoute = createRouteMatcher([
   "/",
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
 
-const clerk = clerkMiddleware((auth, req) => {
+const clerk = clerkMiddleware(async (auth, req) => {
+  const { userId, redirectToSignIn } = await auth();
   if (isPublicRoute(req)) return;
-  return auth().then(({ userId, redirectToSignIn }) => {
-    if (!userId) return redirectToSignIn();
-    return undefined;
-  });
+  if (!userId) return redirectToSignIn();
+  return undefined;
 });
 
 export default clerkEnabled ? clerk : () => NextResponse.next();
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">

exec
/bin/zsh -lc 'tail -n 200 /tmp/usdt_blacklisted_web_next_dev.log || true' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 63ms:

> usdt_blacklisted_web@0.1.0 dev /Users/chiko/side_projects/usdt_blacklisted_web
> next dev

▲ Next.js 16.1.4 (Turbopack)
- Local:         http://localhost:3000
- Network:       http://192.168.1.40:3000
- Environments: .env

✓ Starting...
✓ Ready in 654ms
 GET / 200 in 904ms (compile: 572ms, render: 332ms)
 GET / 200 in 911ms (compile: 521ms, render: 390ms)
 POST / 200 in 15ms (compile: 7ms, render: 8ms)
 POST / 200 in 37ms (compile: 4ms, render: 33ms)
 GET / 200 in 105ms (compile: 9ms, render: 95ms)
 POST / 200 in 5ms (compile: 1829µs, render: 3ms)
 GET /api/user-settings 401 in 206ms (compile: 189ms, render: 17ms)
 POST /api/analyze 200 in 2.8s (compile: 108ms, render: 2.7s)
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..23fbb8e377e5f4c495aa20396001d9b81dd66f44
--- a/middleware.ts
+++ b/middleware.ts
@@ -1,23 +1,23 @@
 import { NextResponse } from "next/server";
 import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
 
-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
+const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
 
 const isPublicRoute = createRouteMatcher([
   "/",
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
 
-const clerk = clerkMiddleware((auth, req) => {
+const clerk = clerkMiddleware(async (auth, req) => {
+  const { userId, redirectToSignIn } = await auth();
   if (isPublicRoute(req)) return;
-  return auth().then(({ userId, redirectToSignIn }) => {
-    if (!userId) return redirectToSignIn();
-    return undefined;
-  });
+  if (!userId) return redirectToSignIn();
+  return undefined;
 });
 
 export default clerkEnabled ? clerk : () => NextResponse.next();
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">

exec
/bin/zsh -lc "cd /Users/chiko/.codex/skills/dev-browser && npx tsx <<'EOF'
import fs from \"node:fs\";
import { connect, waitForPageLoad } from \"@/client.js\";

const client = await connect();
const page = await client.page(\"usdt-save-report\");

const ctx = page.context();
const savedCookies = await ctx.cookies(\"http://localhost:3000/\");
fs.writeFileSync(\"/tmp/usdt_cookies_backup.json\", JSON.stringify(savedCookies, null, 2));

await ctx.clearCookies();
await page.goto(\"http://localhost:3000/settings\");
await waitForPageLoad(page);
await page.waitForTimeout(500);
const urlAfter = page.url();

// restore
await ctx.addCookies(savedCookies);

console.log({ urlAfter });
await client.disconnect();
EOF" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 1.93s:
{ urlAfter: 'http://localhost:3000/settings' }
(node:72348) ExperimentalWarning: CommonJS module /Users/chiko/.nvm/versions/node/v23.3.0/lib/node_modules/npm/node_modules/debug/src/node.js is loading ES Module /Users/chiko/.nvm/versions/node/v23.3.0/lib/node_modules/npm/node_modules/supports-color/index.js using require().
Support for loading ES Module in require() is an experimental feature and might change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..23fbb8e377e5f4c495aa20396001d9b81dd66f44
--- a/middleware.ts
+++ b/middleware.ts
@@ -1,23 +1,23 @@
 import { NextResponse } from "next/server";
 import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
 
-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
+const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
 
 const isPublicRoute = createRouteMatcher([
   "/",
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
 
-const clerk = clerkMiddleware((auth, req) => {
+const clerk = clerkMiddleware(async (auth, req) => {
+  const { userId, redirectToSignIn } = await auth();
   if (isPublicRoute(req)) return;
-  return auth().then(({ userId, redirectToSignIn }) => {
-    if (!userId) return redirectToSignIn();
-    return undefined;
-  });
+  if (!userId) return redirectToSignIn();
+  return undefined;
 });
 
 export default clerkEnabled ? clerk : () => NextResponse.next();
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">





thinking
**Troubleshooting server configurations**

I'm considering that while in development mode, it might not load the configuration from the `.env` file for middleware. But by using `set -a; source .env` before starting the server, I can ensure that `process.env` is set correctly for Next.js. Since I did that, I'm puzzled why `clerkEnabled` shows false. It could be that I edited middleware without reloading the server. I need to verify if the environment variable exists in the server process by checking it through the API.
thinking
**Checking middleware configuration**

I'm unsure if the middleware is automatically including environment variables. However, variables prefixed with `NEXT_PUBLIC_` should work. I wonder if the `.env` file contains the publishable key but has extra spaces after something like `pk_test_...` that might still evaluate as true. It's possible the middleware code isn't executed because Next.js could be using a built output from an earlier compilation. I think I'll check if `/middleware.ts` is compiled and search in the `.next` directory for confirmation.
thinking
**Debugging authentication gating**

I realize our story needs authentication gating to function properly, and this debugging aims to fix that. It's possible the team disabled the Clerk middleware intentionally since the secret key can't be used in Vercel's edge environment. This could affect server-side authentication. They might depend solely on client-side methods like `SignedIn`, but that would cause issues for API routes needing user info. I wonder if they’re using `getAuthenticatedUserId()`, which returns null when keys aren't set. Since our environment has keys set, something else must be wrong.
thinking
**Verifying Clerk environment variables**

I think `@clerk/nextjs` may look for `NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY`. I wonder if our publishable key is misnamed for the middleware. It's possible that Clerk middleware might be reading `process.env.CLERK_PUBLISHABLE_KEY` rather than the one prefixed with `NEXT_PUBLIC_`. The documentation indicates that `CLERK_PUBLISHABLE_KEY` is used for servers, while `NEXT_PUBLIC` is meant for clients. I should check the `@clerk/nextjs` documentation and inspect the installed package to clarify which environment variables are being read.
exec
/bin/zsh -lc 'rg -n "CLERK_PUBLISHABLE_KEY|NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY|CLERK_SECRET_KEY" node_modules/.pnpm/@clerk+nextjs* -S | head -n 80' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 110ms:
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/cjs/types.js.map:1:{"version":3,"sources":["../../src/types.ts"],"sourcesContent":["import type { ClerkProviderProps } from '@clerk/clerk-react';\nimport type { Without } from '@clerk/types';\n\nexport type NextClerkProviderProps = Without<ClerkProviderProps, 'publishableKey'> & {\n  /**\n   * Used to override the default NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY env variable if needed.\n   * This is optional for NextJS as the ClerkProvider will automatically use the NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY env variable if it exists.\n   */\n  publishableKey?: string;\n  /**\n   * If set to true, the NextJS middleware will be invoked\n   * every time the client-side auth state changes (sign-out, sign-in, organization switch etc.).\n   * That way, any auth-dependent logic can be placed inside the middleware.\n   * Example: Configuring the middleware to force a redirect to `/sign-in` when the user signs out\n   *\n   * @default true\n   */\n  __unstable_invokeMiddlewareOnAuthStateChange?: boolean;\n  /**\n   * If set to true, ClerkProvider will opt into dynamic rendering and make auth data available to all wrapper components.\n   *\n   * @default false\n   */\n  dynamic?: boolean;\n};\n"],"mappings":";;;;;;;;;;;;;;AAAA;AAAA;","names":[]}
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/cjs/utils/mergeNextClerkPropsWithEnv.js.map:1:{"version":3,"sources":["../../../src/utils/mergeNextClerkPropsWithEnv.ts"],"sourcesContent":["import { isTruthy } from '@clerk/shared/underscore';\n\nimport { SDK_METADATA } from '../server/constants';\nimport type { NextClerkProviderProps } from '../types';\n\n// @ts-ignore - https://github.com/microsoft/TypeScript/issues/47663\nexport const mergeNextClerkPropsWithEnv = (props: Omit<NextClerkProviderProps, 'children'>): any => {\n  return {\n    ...props,\n    publishableKey: props.publishableKey || process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || '',\n    clerkJSUrl: props.clerkJSUrl || process.env.NEXT_PUBLIC_CLERK_JS_URL,\n    clerkJSVersion: props.clerkJSVersion || process.env.NEXT_PUBLIC_CLERK_JS_VERSION,\n    proxyUrl: props.proxyUrl || process.env.NEXT_PUBLIC_CLERK_PROXY_URL || '',\n    domain: props.domain || process.env.NEXT_PUBLIC_CLERK_DOMAIN || '',\n    isSatellite: props.isSatellite || isTruthy(process.env.NEXT_PUBLIC_CLERK_IS_SATELLITE),\n    signInUrl: props.signInUrl || process.env.NEXT_PUBLIC_CLERK_SIGN_IN_URL || '',\n    signUpUrl: props.signUpUrl || process.env.NEXT_PUBLIC_CLERK_SIGN_UP_URL || '',\n    signInForceRedirectUrl:\n      props.signInForceRedirectUrl || process.env.NEXT_PUBLIC_CLERK_SIGN_IN_FORCE_REDIRECT_URL || '',\n    signUpForceRedirectUrl:\n      props.signUpForceRedirectUrl || process.env.NEXT_PUBLIC_CLERK_SIGN_UP_FORCE_REDIRECT_URL || '',\n    signInFallbackRedirectUrl:\n      props.signInFallbackRedirectUrl || process.env.NEXT_PUBLIC_CLERK_SIGN_IN_FALLBACK_REDIRECT_URL || '',\n    signUpFallbackRedirectUrl:\n      props.signUpFallbackRedirectUrl || process.env.NEXT_PUBLIC_CLERK_SIGN_UP_FALLBACK_REDIRECT_URL || '',\n    afterSignInUrl: props.afterSignInUrl || process.env.NEXT_PUBLIC_CLERK_AFTER_SIGN_IN_URL || '',\n    afterSignUpUrl: props.afterSignUpUrl || process.env.NEXT_PUBLIC_CLERK_AFTER_SIGN_UP_URL || '',\n    newSubscriptionRedirectUrl:\n      props.newSubscriptionRedirectUrl || process.env.NEXT_PUBLIC_CLERK_CHECKOUT_CONTINUE_URL || '',\n    telemetry: props.telemetry ?? {\n      disabled: isTruthy(process.env.NEXT_PUBLIC_CLERK_TELEMETRY_DISABLED),\n      debug: isTruthy(process.env.NEXT_PUBLIC_CLERK_TELEMETRY_DEBUG),\n    },\n    sdkMetadata: SDK_METADATA,\n  };\n};\n"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBAAyB;AAEzB,uBAA6B;AAItB,MAAM,6BAA6B,CAAC,UAAyD;AANpG;AAOE,SAAO;AAAA,IACL,GAAG;AAAA,IACH,gBAAgB,MAAM,kBAAkB,QAAQ,IAAI,qCAAqC;AAAA,IACzF,YAAY,MAAM,cAAc,QAAQ,IAAI;AAAA,IAC5C,gBAAgB,MAAM,kBAAkB,QAAQ,IAAI;AAAA,IACpD,UAAU,MAAM,YAAY,QAAQ,IAAI,+BAA+B;AAAA,IACvE,QAAQ,MAAM,UAAU,QAAQ,IAAI,4BAA4B;AAAA,IAChE,aAAa,MAAM,mBAAe,4BAAS,QAAQ,IAAI,8BAA8B;AAAA,IACrF,WAAW,MAAM,aAAa,QAAQ,IAAI,iCAAiC;AAAA,IAC3E,WAAW,MAAM,aAAa,QAAQ,IAAI,iCAAiC;AAAA,IAC3E,wBACE,MAAM,0BAA0B,QAAQ,IAAI,gDAAgD;AAAA,IAC9F,wBACE,MAAM,0BAA0B,QAAQ,IAAI,gDAAgD;AAAA,IAC9F,2BACE,MAAM,6BAA6B,QAAQ,IAAI,mDAAmD;AAAA,IACpG,2BACE,MAAM,6BAA6B,QAAQ,IAAI,mDAAmD;AAAA,IACpG,gBAAgB,MAAM,kBAAkB,QAAQ,IAAI,uCAAuC;AAAA,IAC3F,gBAAgB,MAAM,kBAAkB,QAAQ,IAAI,uCAAuC;AAAA,IAC3F,4BACE,MAAM,8BAA8B,QAAQ,IAAI,2CAA2C;AAAA,IAC7F,YAAW,WAAM,cAAN,YAAmB;AAAA,MAC5B,cAAU,4BAAS,QAAQ,IAAI,oCAAoC;AAAA,MACnE,WAAO,4BAAS,QAAQ,IAAI,iCAAiC;AAAA,IAC/D;AAAA,IACA,aAAa;AAAA,EACf;AACF;","names":[]}
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/esm/utils/mergeNextClerkPropsWithEnv.js.map:1:{"version":3,"sources":["../../../src/utils/mergeNextClerkPropsWithEnv.ts"],"sourcesContent":["import { isTruthy } from '@clerk/shared/underscore';\n\nimport { SDK_METADATA } from '../server/constants';\nimport type { NextClerkProviderProps } from '../types';\n\n// @ts-ignore - https://github.com/microsoft/TypeScript/issues/47663\nexport const mergeNextClerkPropsWithEnv = (props: Omit<NextClerkProviderProps, 'children'>): any => {\n  return {\n    ...props,\n    publishableKey: props.publishableKey || process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || '',\n    clerkJSUrl: props.clerkJSUrl || process.env.NEXT_PUBLIC_CLERK_JS_URL,\n    clerkJSVersion: props.clerkJSVersion || process.env.NEXT_PUBLIC_CLERK_JS_VERSION,\n    proxyUrl: props.proxyUrl || process.env.NEXT_PUBLIC_CLERK_PROXY_URL || '',\n    domain: props.domain || process.env.NEXT_PUBLIC_CLERK_DOMAIN || '',\n    isSatellite: props.isSatellite || isTruthy(process.env.NEXT_PUBLIC_CLERK_IS_SATELLITE),\n    signInUrl: props.signInUrl || process.env.NEXT_PUBLIC_CLERK_SIGN_IN_URL || '',\n    signUpUrl: props.signUpUrl || process.env.NEXT_PUBLIC_CLERK_SIGN_UP_URL || '',\n    signInForceRedirectUrl:\n      props.signInForceRedirectUrl || process.env.NEXT_PUBLIC_CLERK_SIGN_IN_FORCE_REDIRECT_URL || '',\n    signUpForceRedirectUrl:\n      props.signUpForceRedirectUrl || process.env.NEXT_PUBLIC_CLERK_SIGN_UP_FORCE_REDIRECT_URL || '',\n    signInFallbackRedirectUrl:\n      props.signInFallbackRedirectUrl || process.env.NEXT_PUBLIC_CLERK_SIGN_IN_FALLBACK_REDIRECT_URL || '',\n    signUpFallbackRedirectUrl:\n      props.signUpFallbackRedirectUrl || process.env.NEXT_PUBLIC_CLERK_SIGN_UP_FALLBACK_REDIRECT_URL || '',\n    afterSignInUrl: props.afterSignInUrl || process.env.NEXT_PUBLIC_CLERK_AFTER_SIGN_IN_URL || '',\n    afterSignUpUrl: props.afterSignUpUrl || process.env.NEXT_PUBLIC_CLERK_AFTER_SIGN_UP_URL || '',\n    newSubscriptionRedirectUrl:\n      props.newSubscriptionRedirectUrl || process.env.NEXT_PUBLIC_CLERK_CHECKOUT_CONTINUE_URL || '',\n    telemetry: props.telemetry ?? {\n      disabled: isTruthy(process.env.NEXT_PUBLIC_CLERK_TELEMETRY_DISABLED),\n      debug: isTruthy(process.env.NEXT_PUBLIC_CLERK_TELEMETRY_DEBUG),\n    },\n    sdkMetadata: SDK_METADATA,\n  };\n};\n"],"mappings":";AAAA,SAAS,gBAAgB;AAEzB,SAAS,oBAAoB;AAItB,MAAM,6BAA6B,CAAC,UAAyD;AANpG;AAOE,SAAO;AAAA,IACL,GAAG;AAAA,IACH,gBAAgB,MAAM,kBAAkB,QAAQ,IAAI,qCAAqC;AAAA,IACzF,YAAY,MAAM,cAAc,QAAQ,IAAI;AAAA,IAC5C,gBAAgB,MAAM,kBAAkB,QAAQ,IAAI;AAAA,IACpD,UAAU,MAAM,YAAY,QAAQ,IAAI,+BAA+B;AAAA,IACvE,QAAQ,MAAM,UAAU,QAAQ,IAAI,4BAA4B;AAAA,IAChE,aAAa,MAAM,eAAe,SAAS,QAAQ,IAAI,8BAA8B;AAAA,IACrF,WAAW,MAAM,aAAa,QAAQ,IAAI,iCAAiC;AAAA,IAC3E,WAAW,MAAM,aAAa,QAAQ,IAAI,iCAAiC;AAAA,IAC3E,wBACE,MAAM,0BAA0B,QAAQ,IAAI,gDAAgD;AAAA,IAC9F,wBACE,MAAM,0BAA0B,QAAQ,IAAI,gDAAgD;AAAA,IAC9F,2BACE,MAAM,6BAA6B,QAAQ,IAAI,mDAAmD;AAAA,IACpG,2BACE,MAAM,6BAA6B,QAAQ,IAAI,mDAAmD;AAAA,IACpG,gBAAgB,MAAM,kBAAkB,QAAQ,IAAI,uCAAuC;AAAA,IAC3F,gBAAgB,MAAM,kBAAkB,QAAQ,IAAI,uCAAuC;AAAA,IAC3F,4BACE,MAAM,8BAA8B,QAAQ,IAAI,2CAA2C;AAAA,IAC7F,YAAW,WAAM,cAAN,YAAmB;AAAA,MAC5B,UAAU,SAAS,QAAQ,IAAI,oCAAoC;AAAA,MACnE,OAAO,SAAS,QAAQ,IAAI,iCAAiC;AAAA,IAC/D;AAAA,IACA,aAAa;AAAA,EACf;AACF;","names":[]}
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/cjs/utils/mergeNextClerkPropsWithEnv.js:30:    publishableKey: props.publishableKey || process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || "",
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/esm/utils/mergeNextClerkPropsWithEnv.js:8:    publishableKey: props.publishableKey || process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || "",
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/esm/server/keyless-telemetry.js:51:    const envPublishableKey = process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY;
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/esm/server/keyless-telemetry.js:52:    const envSecretKey = process.env.CLERK_SECRET_KEY;
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/cjs/server/keyless-telemetry.js:83:    const envPublishableKey = process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY;
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/cjs/server/keyless-telemetry.js:84:    const envSecretKey = process.env.CLERK_SECRET_KEY;
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/cjs/server/constants.js.map:1:{"version":3,"sources":["../../../src/server/constants.ts"],"sourcesContent":["import { apiUrlFromPublishableKey } from '@clerk/shared/apiUrlFromPublishableKey';\nimport { isTruthy } from '@clerk/shared/underscore';\n\nexport const CLERK_JS_VERSION = process.env.NEXT_PUBLIC_CLERK_JS_VERSION || '';\nexport const CLERK_JS_URL = process.env.NEXT_PUBLIC_CLERK_JS_URL || '';\nexport const API_VERSION = process.env.CLERK_API_VERSION || 'v1';\nexport const SECRET_KEY = process.env.CLERK_SECRET_KEY || '';\nexport const MACHINE_SECRET_KEY = process.env.CLERK_MACHINE_SECRET_KEY || '';\nexport const PUBLISHABLE_KEY = process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || '';\nexport const ENCRYPTION_KEY = process.env.CLERK_ENCRYPTION_KEY || '';\nexport const API_URL = process.env.CLERK_API_URL || apiUrlFromPublishableKey(PUBLISHABLE_KEY);\nexport const DOMAIN = process.env.NEXT_PUBLIC_CLERK_DOMAIN || '';\nexport const PROXY_URL = process.env.NEXT_PUBLIC_CLERK_PROXY_URL || '';\nexport const IS_SATELLITE = isTruthy(process.env.NEXT_PUBLIC_CLERK_IS_SATELLITE) || false;\nexport const SIGN_IN_URL = process.env.NEXT_PUBLIC_CLERK_SIGN_IN_URL || '';\nexport const SIGN_UP_URL = process.env.NEXT_PUBLIC_CLERK_SIGN_UP_URL || '';\nexport const SDK_METADATA = {\n  name: PACKAGE_NAME,\n  version: PACKAGE_VERSION,\n  environment: process.env.NODE_ENV,\n};\n\nexport const TELEMETRY_DISABLED = isTruthy(process.env.NEXT_PUBLIC_CLERK_TELEMETRY_DISABLED);\nexport const TELEMETRY_DEBUG = isTruthy(process.env.NEXT_PUBLIC_CLERK_TELEMETRY_DEBUG);\n\nexport const KEYLESS_DISABLED = isTruthy(process.env.NEXT_PUBLIC_CLERK_KEYLESS_DISABLED) || false;\n"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sCAAyC;AACzC,wBAAyB;AAElB,MAAM,mBAAmB,QAAQ,IAAI,gCAAgC;AACrE,MAAM,eAAe,QAAQ,IAAI,4BAA4B;AAC7D,MAAM,cAAc,QAAQ,IAAI,qBAAqB;AACrD,MAAM,aAAa,QAAQ,IAAI,oBAAoB;AACnD,MAAM,qBAAqB,QAAQ,IAAI,4BAA4B;AACnE,MAAM,kBAAkB,QAAQ,IAAI,qCAAqC;AACzE,MAAM,iBAAiB,QAAQ,IAAI,wBAAwB;AAC3D,MAAM,UAAU,QAAQ,IAAI,qBAAiB,0DAAyB,eAAe;AACrF,MAAM,SAAS,QAAQ,IAAI,4BAA4B;AACvD,MAAM,YAAY,QAAQ,IAAI,+BAA+B;AAC7D,MAAM,mBAAe,4BAAS,QAAQ,IAAI,8BAA8B,KAAK;AAC7E,MAAM,cAAc,QAAQ,IAAI,iCAAiC;AACjE,MAAM,cAAc,QAAQ,IAAI,iCAAiC;AACjE,MAAM,eAAe;AAAA,EAC1B,MAAM;AAAA,EACN,SAAS;AAAA,EACT,aAAa,QAAQ,IAAI;AAC3B;AAEO,MAAM,yBAAqB,4BAAS,QAAQ,IAAI,oCAAoC;AACpF,MAAM,sBAAkB,4BAAS,QAAQ,IAAI,iCAAiC;AAE9E,MAAM,uBAAmB,4BAAS,QAAQ,IAAI,kCAAkC,KAAK;","names":[]}
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/types/types.d.ts:5:     * Used to override the default NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY env variable if needed.
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/types/types.d.ts:6:     * This is optional for NextJS as the ClerkProvider will automatically use the NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY env variable if it exists.
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/esm/server/keyless-telemetry.js.map:1:{"version":3,"sources":["../../../src/server/keyless-telemetry.ts"],"sourcesContent":["import type { TelemetryEventRaw } from '@clerk/types';\n\nimport { canUseKeyless } from '../utils/feature-flags';\nimport { createClerkClientWithOptions } from './createClerkClient';\nimport { nodeFsOrThrow, nodePathOrThrow } from './fs/utils';\n\nconst EVENT_KEYLESS_ENV_DRIFT_DETECTED = 'KEYLESS_ENV_DRIFT_DETECTED';\nconst EVENT_SAMPLING_RATE = 1; // 100% sampling rate\nconst TELEMETRY_FLAG_FILE = '.clerk/.tmp/telemetry.json';\n\ntype EventKeylessEnvDriftPayload = {\n  publicKeyMatch: boolean;\n  secretKeyMatch: boolean;\n  envVarsMissing: boolean;\n  keylessFileHasKeys: boolean;\n  keylessPublishableKey: string;\n  envPublishableKey: string;\n};\n\n/**\n * Gets the absolute path to the telemetry flag file.\n *\n * This file is used to track whether telemetry events have already been fired\n * to prevent duplicate event reporting during the application lifecycle.\n *\n * @returns The absolute path to the telemetry flag file in the project's .clerk/.tmp directory\n */\nfunction getTelemetryFlagFilePath(): string {\n  const path = nodePathOrThrow();\n  return path.join(process.cwd(), TELEMETRY_FLAG_FILE);\n}\n\n/**\n * Attempts to create a telemetry flag file to mark that a telemetry event has been fired.\n *\n * This function uses the 'wx' flag to create the file atomically - it will only succeed\n * if the file doesn't already exist. This ensures that telemetry events are only fired\n * once per application lifecycle, preventing duplicate event reporting.\n *\n * @returns Promise<boolean> - Returns true if the flag file was successfully created (meaning\n *   the event should be fired), false if the file already exists (meaning the event was\n *   already fired) or if there was an error creating the file\n */\nfunction tryMarkTelemetryEventAsFired(): boolean {\n  try {\n    if (canUseKeyless) {\n      const { mkdirSync, writeFileSync } = nodeFsOrThrow();\n      const path = nodePathOrThrow();\n      const flagFilePath = getTelemetryFlagFilePath();\n      const flagDirectory = path.dirname(flagFilePath);\n\n      // Ensure the directory exists before attempting to write the file\n      mkdirSync(flagDirectory, { recursive: true });\n\n      const flagData = {\n        firedAt: new Date().toISOString(),\n        event: EVENT_KEYLESS_ENV_DRIFT_DETECTED,\n      };\n      writeFileSync(flagFilePath, JSON.stringify(flagData, null, 2), { flag: 'wx' });\n      return true;\n    } else {\n      return false;\n    }\n  } catch (error: unknown) {\n    if ((error as { code?: string })?.code === 'EEXIST') {\n      return false;\n    }\n    console.warn('Failed to create telemetry flag file:', error);\n    return false;\n  }\n}\n\n/**\n * Detects and reports environment drift between keyless configuration and environment variables.\n *\n * This function compares the Clerk keys stored in the keyless configuration file (.clerk/clerk.json)\n * with the keys set in environment variables (NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY and CLERK_SECRET_KEY).\n * It only reports drift when there's an actual mismatch between existing keys, not when keys are simply missing.\n *\n * The function handles several scenarios and only reports drift in specific cases:\n * - **Normal keyless mode**: env vars missing but keyless file has keys → no drift (expected)\n * - **No configuration**: neither env vars nor keyless file have keys → no drift (nothing to compare)\n * - **Actual drift**: env vars exist and don't match keyless file keys → drift detected\n * - **Empty keyless file**: keyless file exists but has no keys → no drift (nothing to compare)\n *\n * Drift is only detected when:\n * 1. Both environment variables and keyless file contain keys\n * 2. The keys in environment variables don't match the keys in the keyless file\n *\n * Telemetry events are only fired once per application lifecycle using a flag file mechanism\n * to prevent duplicate reporting.\n *\n * @returns Promise<void> - Function completes silently, errors are logged but don't throw\n */\nexport async function detectKeylessEnvDrift(): Promise<void> {\n  if (!canUseKeyless) {\n    return;\n  }\n  // Only run on server side\n  if (typeof window !== 'undefined') {\n    return;\n  }\n\n  try {\n    // Dynamically import server-side dependencies to avoid client-side issues\n    const { safeParseClerkFile } = await import('./keyless-node.js');\n\n    // Read the keyless configuration file\n    const keylessFile = safeParseClerkFile();\n\n    if (!keylessFile) {\n      return;\n    }\n\n    // Get environment variables\n    const envPublishableKey = process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY;\n    const envSecretKey = process.env.CLERK_SECRET_KEY;\n\n    // Check the state of environment variables and keyless file\n    const hasEnvVars = Boolean(envPublishableKey || envSecretKey);\n    const keylessFileHasKeys = Boolean(keylessFile?.publishableKey && keylessFile?.secretKey);\n    const envVarsMissing = !envPublishableKey && !envSecretKey;\n\n    // Early return conditions - no drift to detect in these scenarios:\n    if (!hasEnvVars && !keylessFileHasKeys) {\n      // Neither env vars nor keyless file have keys - nothing to compare\n      return;\n    }\n\n    if (envVarsMissing && keylessFileHasKeys) {\n      // Environment variables are missing but keyless file has keys - this is normal for keyless mode\n      return;\n    }\n\n    if (!keylessFileHasKeys) {\n      // Keyless file doesn't have keys, so no drift can be detected\n      return;\n    }\n\n    // Only proceed with drift detection if we have something meaningful to compare\n    if (!hasEnvVars) {\n      return;\n    }\n\n    // Compare keys only when both sides have values to compare\n    const publicKeyMatch = Boolean(\n      envPublishableKey && keylessFile.publishableKey && envPublishableKey === keylessFile.publishableKey,\n    );\n\n    const secretKeyMatch = Boolean(envSecretKey && keylessFile.secretKey && envSecretKey === keylessFile.secretKey);\n\n    // Determine if there's an actual drift:\n    // Drift occurs when we have env vars that don't match the keyless file keys\n    const hasActualDrift =\n      (envPublishableKey && keylessFile.publishableKey && !publicKeyMatch) ||\n      (envSecretKey && keylessFile.secretKey && !secretKeyMatch);\n\n    // Only fire telemetry if there's an actual drift (not just missing keys)\n    if (!hasActualDrift) {\n      return;\n    }\n\n    const payload: EventKeylessEnvDriftPayload = {\n      publicKeyMatch,\n      secretKeyMatch,\n      envVarsMissing,\n      keylessFileHasKeys,\n      keylessPublishableKey: keylessFile.publishableKey ?? '',\n      envPublishableKey: envPublishableKey ?? '',\n    };\n\n    // Create a clerk client to access telemetry\n    const clerkClient = createClerkClientWithOptions({\n      publishableKey: keylessFile.publishableKey,\n      secretKey: keylessFile.secretKey,\n      telemetry: {\n        samplingRate: 1,\n      },\n    });\n\n    const shouldFireEvent = tryMarkTelemetryEventAsFired();\n\n    if (shouldFireEvent) {\n      // Fire drift detected event only if we successfully created the flag\n      const driftDetectedEvent: TelemetryEventRaw<EventKeylessEnvDriftPayload> = {\n        event: EVENT_KEYLESS_ENV_DRIFT_DETECTED,\n        eventSamplingRate: EVENT_SAMPLING_RATE,\n        payload,\n      };\n\n      clerkClient.telemetry?.record(driftDetectedEvent);\n    }\n  } catch (error) {\n    // Silently handle errors to avoid breaking the application\n    console.warn('Failed to detect keyless environment drift:', error);\n  }\n}\n"],"mappings":";AAEA,SAAS,qBAAqB;AAC9B,SAAS,oCAAoC;AAC7C,SAAS,eAAe,uBAAuB;AAE/C,MAAM,mCAAmC;AACzC,MAAM,sBAAsB;AAC5B,MAAM,sBAAsB;AAmB5B,SAAS,2BAAmC;AAC1C,QAAM,OAAO,gBAAgB;AAC7B,SAAO,KAAK,KAAK,QAAQ,IAAI,GAAG,mBAAmB;AACrD;AAaA,SAAS,+BAAwC;AAC/C,MAAI;AACF,QAAI,eAAe;AACjB,YAAM,EAAE,WAAW,cAAc,IAAI,cAAc;AACnD,YAAM,OAAO,gBAAgB;AAC7B,YAAM,eAAe,yBAAyB;AAC9C,YAAM,gBAAgB,KAAK,QAAQ,YAAY;AAG/C,gBAAU,eAAe,EAAE,WAAW,KAAK,CAAC;AAE5C,YAAM,WAAW;AAAA,QACf,UAAS,oBAAI,KAAK,GAAE,YAAY;AAAA,QAChC,OAAO;AAAA,MACT;AACA,oBAAc,cAAc,KAAK,UAAU,UAAU,MAAM,CAAC,GAAG,EAAE,MAAM,KAAK,CAAC;AAC7E,aAAO;AAAA,IACT,OAAO;AACL,aAAO;AAAA,IACT;AAAA,EACF,SAAS,OAAgB;AACvB,SAAK,+BAA6B,UAAS,UAAU;AACnD,aAAO;AAAA,IACT;AACA,YAAQ,KAAK,yCAAyC,KAAK;AAC3D,WAAO;AAAA,EACT;AACF;AAwBA,eAAsB,wBAAuC;AA9F7D;AA+FE,MAAI,CAAC,eAAe;AAClB;AAAA,EACF;AAEA,MAAI,OAAO,WAAW,aAAa;AACjC;AAAA,EACF;AAEA,MAAI;AAEF,UAAM,EAAE,mBAAmB,IAAI,MAAM,OAAO,mBAAmB;AAG/D,UAAM,cAAc,mBAAmB;AAEvC,QAAI,CAAC,aAAa;AAChB;AAAA,IACF;AAGA,UAAM,oBAAoB,QAAQ,IAAI;AACtC,UAAM,eAAe,QAAQ,IAAI;AAGjC,UAAM,aAAa,QAAQ,qBAAqB,YAAY;AAC5D,UAAM,qBAAqB,SAAQ,2CAAa,oBAAkB,2CAAa,UAAS;AACxF,UAAM,iBAAiB,CAAC,qBAAqB,CAAC;AAG9C,QAAI,CAAC,cAAc,CAAC,oBAAoB;AAEtC;AAAA,IACF;AAEA,QAAI,kBAAkB,oBAAoB;AAExC;AAAA,IACF;AAEA,QAAI,CAAC,oBAAoB;AAEvB;AAAA,IACF;AAGA,QAAI,CAAC,YAAY;AACf;AAAA,IACF;AAGA,UAAM,iBAAiB;AAAA,MACrB,qBAAqB,YAAY,kBAAkB,sBAAsB,YAAY;AAAA,IACvF;AAEA,UAAM,iBAAiB,QAAQ,gBAAgB,YAAY,aAAa,iBAAiB,YAAY,SAAS;AAI9G,UAAM,iBACH,qBAAqB,YAAY,kBAAkB,CAAC,kBACpD,gBAAgB,YAAY,aAAa,CAAC;AAG7C,QAAI,CAAC,gBAAgB;AACnB;AAAA,IACF;AAEA,UAAM,UAAuC;AAAA,MAC3C;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,wBAAuB,iBAAY,mBAAZ,YAA8B;AAAA,MACrD,mBAAmB,gDAAqB;AAAA,IAC1C;AAGA,UAAM,cAAc,6BAA6B;AAAA,MAC/C,gBAAgB,YAAY;AAAA,MAC5B,WAAW,YAAY;AAAA,MACvB,WAAW;AAAA,QACT,cAAc;AAAA,MAChB;AAAA,IACF,CAAC;AAED,UAAM,kBAAkB,6BAA6B;AAErD,QAAI,iBAAiB;AAEnB,YAAM,qBAAqE;AAAA,QACzE,OAAO;AAAA,QACP,mBAAmB;AAAA,QACnB;AAAA,MACF;AAEA,wBAAY,cAAZ,mBAAuB,OAAO;AAAA,IAChC;AAAA,EACF,SAAS,OAAO;AAEd,YAAQ,KAAK,+CAA+C,KAAK;AAAA,EACnE;AACF;","names":[]}
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/cjs/server/keyless-telemetry.js.map:1:{"version":3,"sources":["../../../src/server/keyless-telemetry.ts"],"sourcesContent":["import type { TelemetryEventRaw } from '@clerk/types';\n\nimport { canUseKeyless } from '../utils/feature-flags';\nimport { createClerkClientWithOptions } from './createClerkClient';\nimport { nodeFsOrThrow, nodePathOrThrow } from './fs/utils';\n\nconst EVENT_KEYLESS_ENV_DRIFT_DETECTED = 'KEYLESS_ENV_DRIFT_DETECTED';\nconst EVENT_SAMPLING_RATE = 1; // 100% sampling rate\nconst TELEMETRY_FLAG_FILE = '.clerk/.tmp/telemetry.json';\n\ntype EventKeylessEnvDriftPayload = {\n  publicKeyMatch: boolean;\n  secretKeyMatch: boolean;\n  envVarsMissing: boolean;\n  keylessFileHasKeys: boolean;\n  keylessPublishableKey: string;\n  envPublishableKey: string;\n};\n\n/**\n * Gets the absolute path to the telemetry flag file.\n *\n * This file is used to track whether telemetry events have already been fired\n * to prevent duplicate event reporting during the application lifecycle.\n *\n * @returns The absolute path to the telemetry flag file in the project's .clerk/.tmp directory\n */\nfunction getTelemetryFlagFilePath(): string {\n  const path = nodePathOrThrow();\n  return path.join(process.cwd(), TELEMETRY_FLAG_FILE);\n}\n\n/**\n * Attempts to create a telemetry flag file to mark that a telemetry event has been fired.\n *\n * This function uses the 'wx' flag to create the file atomically - it will only succeed\n * if the file doesn't already exist. This ensures that telemetry events are only fired\n * once per application lifecycle, preventing duplicate event reporting.\n *\n * @returns Promise<boolean> - Returns true if the flag file was successfully created (meaning\n *   the event should be fired), false if the file already exists (meaning the event was\n *   already fired) or if there was an error creating the file\n */\nfunction tryMarkTelemetryEventAsFired(): boolean {\n  try {\n    if (canUseKeyless) {\n      const { mkdirSync, writeFileSync } = nodeFsOrThrow();\n      const path = nodePathOrThrow();\n      const flagFilePath = getTelemetryFlagFilePath();\n      const flagDirectory = path.dirname(flagFilePath);\n\n      // Ensure the directory exists before attempting to write the file\n      mkdirSync(flagDirectory, { recursive: true });\n\n      const flagData = {\n        firedAt: new Date().toISOString(),\n        event: EVENT_KEYLESS_ENV_DRIFT_DETECTED,\n      };\n      writeFileSync(flagFilePath, JSON.stringify(flagData, null, 2), { flag: 'wx' });\n      return true;\n    } else {\n      return false;\n    }\n  } catch (error: unknown) {\n    if ((error as { code?: string })?.code === 'EEXIST') {\n      return false;\n    }\n    console.warn('Failed to create telemetry flag file:', error);\n    return false;\n  }\n}\n\n/**\n * Detects and reports environment drift between keyless configuration and environment variables.\n *\n * This function compares the Clerk keys stored in the keyless configuration file (.clerk/clerk.json)\n * with the keys set in environment variables (NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY and CLERK_SECRET_KEY).\n * It only reports drift when there's an actual mismatch between existing keys, not when keys are simply missing.\n *\n * The function handles several scenarios and only reports drift in specific cases:\n * - **Normal keyless mode**: env vars missing but keyless file has keys → no drift (expected)\n * - **No configuration**: neither env vars nor keyless file have keys → no drift (nothing to compare)\n * - **Actual drift**: env vars exist and don't match keyless file keys → drift detected\n * - **Empty keyless file**: keyless file exists but has no keys → no drift (nothing to compare)\n *\n * Drift is only detected when:\n * 1. Both environment variables and keyless file contain keys\n * 2. The keys in environment variables don't match the keys in the keyless file\n *\n * Telemetry events are only fired once per application lifecycle using a flag file mechanism\n * to prevent duplicate reporting.\n *\n * @returns Promise<void> - Function completes silently, errors are logged but don't throw\n */\nexport async function detectKeylessEnvDrift(): Promise<void> {\n  if (!canUseKeyless) {\n    return;\n  }\n  // Only run on server side\n  if (typeof window !== 'undefined') {\n    return;\n  }\n\n  try {\n    // Dynamically import server-side dependencies to avoid client-side issues\n    const { safeParseClerkFile } = await import('./keyless-node.js');\n\n    // Read the keyless configuration file\n    const keylessFile = safeParseClerkFile();\n\n    if (!keylessFile) {\n      return;\n    }\n\n    // Get environment variables\n    const envPublishableKey = process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY;\n    const envSecretKey = process.env.CLERK_SECRET_KEY;\n\n    // Check the state of environment variables and keyless file\n    const hasEnvVars = Boolean(envPublishableKey || envSecretKey);\n    const keylessFileHasKeys = Boolean(keylessFile?.publishableKey && keylessFile?.secretKey);\n    const envVarsMissing = !envPublishableKey && !envSecretKey;\n\n    // Early return conditions - no drift to detect in these scenarios:\n    if (!hasEnvVars && !keylessFileHasKeys) {\n      // Neither env vars nor keyless file have keys - nothing to compare\n      return;\n    }\n\n    if (envVarsMissing && keylessFileHasKeys) {\n      // Environment variables are missing but keyless file has keys - this is normal for keyless mode\n      return;\n    }\n\n    if (!keylessFileHasKeys) {\n      // Keyless file doesn't have keys, so no drift can be detected\n      return;\n    }\n\n    // Only proceed with drift detection if we have something meaningful to compare\n    if (!hasEnvVars) {\n      return;\n    }\n\n    // Compare keys only when both sides have values to compare\n    const publicKeyMatch = Boolean(\n      envPublishableKey && keylessFile.publishableKey && envPublishableKey === keylessFile.publishableKey,\n    );\n\n    const secretKeyMatch = Boolean(envSecretKey && keylessFile.secretKey && envSecretKey === keylessFile.secretKey);\n\n    // Determine if there's an actual drift:\n    // Drift occurs when we have env vars that don't match the keyless file keys\n    const hasActualDrift =\n      (envPublishableKey && keylessFile.publishableKey && !publicKeyMatch) ||\n      (envSecretKey && keylessFile.secretKey && !secretKeyMatch);\n\n    // Only fire telemetry if there's an actual drift (not just missing keys)\n    if (!hasActualDrift) {\n      return;\n    }\n\n    const payload: EventKeylessEnvDriftPayload = {\n      publicKeyMatch,\n      secretKeyMatch,\n      envVarsMissing,\n      keylessFileHasKeys,\n      keylessPublishableKey: keylessFile.publishableKey ?? '',\n      envPublishableKey: envPublishableKey ?? '',\n    };\n\n    // Create a clerk client to access telemetry\n    const clerkClient = createClerkClientWithOptions({\n      publishableKey: keylessFile.publishableKey,\n      secretKey: keylessFile.secretKey,\n      telemetry: {\n        samplingRate: 1,\n      },\n    });\n\n    const shouldFireEvent = tryMarkTelemetryEventAsFired();\n\n    if (shouldFireEvent) {\n      // Fire drift detected event only if we successfully created the flag\n      const driftDetectedEvent: TelemetryEventRaw<EventKeylessEnvDriftPayload> = {\n        event: EVENT_KEYLESS_ENV_DRIFT_DETECTED,\n        eventSamplingRate: EVENT_SAMPLING_RATE,\n        payload,\n      };\n\n      clerkClient.telemetry?.record(driftDetectedEvent);\n    }\n  } catch (error) {\n    // Silently handle errors to avoid breaking the application\n    console.warn('Failed to detect keyless environment drift:', error);\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA,2BAA8B;AAC9B,+BAA6C;AAC7C,mBAA+C;AAE/C,MAAM,mCAAmC;AACzC,MAAM,sBAAsB;AAC5B,MAAM,sBAAsB;AAmB5B,SAAS,2BAAmC;AAC1C,QAAM,WAAO,8BAAgB;AAC7B,SAAO,KAAK,KAAK,QAAQ,IAAI,GAAG,mBAAmB;AACrD;AAaA,SAAS,+BAAwC;AAC/C,MAAI;AACF,QAAI,oCAAe;AACjB,YAAM,EAAE,WAAW,cAAc,QAAI,4BAAc;AACnD,YAAM,WAAO,8BAAgB;AAC7B,YAAM,eAAe,yBAAyB;AAC9C,YAAM,gBAAgB,KAAK,QAAQ,YAAY;AAG/C,gBAAU,eAAe,EAAE,WAAW,KAAK,CAAC;AAE5C,YAAM,WAAW;AAAA,QACf,UAAS,oBAAI,KAAK,GAAE,YAAY;AAAA,QAChC,OAAO;AAAA,MACT;AACA,oBAAc,cAAc,KAAK,UAAU,UAAU,MAAM,CAAC,GAAG,EAAE,MAAM,KAAK,CAAC;AAC7E,aAAO;AAAA,IACT,OAAO;AACL,aAAO;AAAA,IACT;AAAA,EACF,SAAS,OAAgB;AACvB,SAAK,+BAA6B,UAAS,UAAU;AACnD,aAAO;AAAA,IACT;AACA,YAAQ,KAAK,yCAAyC,KAAK;AAC3D,WAAO;AAAA,EACT;AACF;AAwBA,eAAsB,wBAAuC;AA9F7D;AA+FE,MAAI,CAAC,oCAAe;AAClB;AAAA,EACF;AAEA,MAAI,OAAO,WAAW,aAAa;AACjC;AAAA,EACF;AAEA,MAAI;AAEF,UAAM,EAAE,mBAAmB,IAAI,MAAM,OAAO,mBAAmB;AAG/D,UAAM,cAAc,mBAAmB;AAEvC,QAAI,CAAC,aAAa;AAChB;AAAA,IACF;AAGA,UAAM,oBAAoB,QAAQ,IAAI;AACtC,UAAM,eAAe,QAAQ,IAAI;AAGjC,UAAM,aAAa,QAAQ,qBAAqB,YAAY;AAC5D,UAAM,qBAAqB,SAAQ,2CAAa,oBAAkB,2CAAa,UAAS;AACxF,UAAM,iBAAiB,CAAC,qBAAqB,CAAC;AAG9C,QAAI,CAAC,cAAc,CAAC,oBAAoB;AAEtC;AAAA,IACF;AAEA,QAAI,kBAAkB,oBAAoB;AAExC;AAAA,IACF;AAEA,QAAI,CAAC,oBAAoB;AAEvB;AAAA,IACF;AAGA,QAAI,CAAC,YAAY;AACf;AAAA,IACF;AAGA,UAAM,iBAAiB;AAAA,MACrB,qBAAqB,YAAY,kBAAkB,sBAAsB,YAAY;AAAA,IACvF;AAEA,UAAM,iBAAiB,QAAQ,gBAAgB,YAAY,aAAa,iBAAiB,YAAY,SAAS;AAI9G,UAAM,iBACH,qBAAqB,YAAY,kBAAkB,CAAC,kBACpD,gBAAgB,YAAY,aAAa,CAAC;AAG7C,QAAI,CAAC,gBAAgB;AACnB;AAAA,IACF;AAEA,UAAM,UAAuC;AAAA,MAC3C;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,wBAAuB,iBAAY,mBAAZ,YAA8B;AAAA,MACrD,mBAAmB,gDAAqB;AAAA,IAC1C;AAGA,UAAM,kBAAc,uDAA6B;AAAA,MAC/C,gBAAgB,YAAY;AAAA,MAC5B,WAAW,YAAY;AAAA,MACvB,WAAW;AAAA,QACT,cAAc;AAAA,MAChB;AAAA,IACF,CAAC;AAED,UAAM,kBAAkB,6BAA6B;AAErD,QAAI,iBAAiB;AAEnB,YAAM,qBAAqE;AAAA,QACzE,OAAO;AAAA,QACP,mBAAmB;AAAA,QACnB;AAAA,MACF;AAEA,wBAAY,cAAZ,mBAAuB,OAAO;AAAA,IAChC;AAAA,EACF,SAAS,OAAO;AAEd,YAAQ,KAAK,+CAA+C,KAAK;AAAA,EACnE;AACF;","names":[]}
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/cjs/server/createGetAuth.js.map:1:{"version":3,"sources":["../../../src/server/createGetAuth.ts"],"sourcesContent":["import type { AuthObject } from '@clerk/backend';\nimport { constants, type SignedInAuthObject, type SignedOutAuthObject } from '@clerk/backend/internal';\nimport { isTruthy } from '@clerk/shared/underscore';\nimport type { PendingSessionOptions } from '@clerk/types';\n\nimport { withLogger } from '../utils/debugLogger';\nimport { isNextWithUnstableServerActions } from '../utils/sdk-versions';\nimport type { GetAuthDataFromRequestOptions } from './data/getAuthDataFromRequest';\nimport {\n  getAuthDataFromRequest as getAuthDataFromRequestOriginal,\n  getSessionAuthDataFromRequest as getSessionAuthDataFromRequestOriginal,\n} from './data/getAuthDataFromRequest';\nimport { getAuthAuthHeaderMissing } from './errors';\nimport { detectClerkMiddleware, getHeader } from './headers-utils';\nimport type { RequestLike } from './types';\nimport { assertAuthStatus } from './utils';\n\nexport type GetAuthOptions = {\n  acceptsToken?: GetAuthDataFromRequestOptions['acceptsToken'];\n} & PendingSessionOptions;\n\n/**\n * The async variant of our old `createGetAuth` allows for asynchronous code inside its callback.\n * Should be used with function like `auth()` that are already asynchronous.\n */\nexport const createAsyncGetAuth = ({\n  debugLoggerName,\n  noAuthStatusMessage,\n}: {\n  debugLoggerName: string;\n  noAuthStatusMessage: string;\n}) =>\n  withLogger(debugLoggerName, logger => {\n    return async (req: RequestLike, opts?: { secretKey?: string } & GetAuthOptions): Promise<AuthObject> => {\n      if (isTruthy(getHeader(req, constants.Headers.EnableDebug))) {\n        logger.enable();\n      }\n\n      if (!detectClerkMiddleware(req)) {\n        // Keep the same behaviour for versions that may have issues with bundling `node:fs`\n        if (isNextWithUnstableServerActions) {\n          assertAuthStatus(req, noAuthStatusMessage);\n        }\n\n        const missConfiguredMiddlewareLocation = await import('./fs/middleware-location.js')\n          .then(m => m.suggestMiddlewareLocation())\n          .catch(() => undefined);\n\n        if (missConfiguredMiddlewareLocation) {\n          throw new Error(missConfiguredMiddlewareLocation);\n        }\n\n        // still throw there is no suggested move location\n        assertAuthStatus(req, noAuthStatusMessage);\n      }\n\n      const getAuthDataFromRequest = (req: RequestLike, opts: GetAuthDataFromRequestOptions = {}) => {\n        return getAuthDataFromRequestOriginal(req, { ...opts, logger, acceptsToken: opts?.acceptsToken });\n      };\n\n      return getAuthDataFromRequest(req, { ...opts, logger, acceptsToken: opts?.acceptsToken });\n    };\n  });\n\n/**\n * Previous known as `createGetAuth`. We needed to create a sync and async variant in order to allow for improvements\n * that required dynamic imports (using `require` would not work).\n * It powers the synchronous top-level api `getAuth()`.\n */\nexport const createSyncGetAuth = ({\n  debugLoggerName,\n  noAuthStatusMessage,\n}: {\n  debugLoggerName: string;\n  noAuthStatusMessage: string;\n}) =>\n  withLogger(debugLoggerName, logger => {\n    return (\n      req: RequestLike,\n      opts?: { secretKey?: string } & GetAuthOptions,\n    ): SignedInAuthObject | SignedOutAuthObject => {\n      if (isTruthy(getHeader(req, constants.Headers.EnableDebug))) {\n        logger.enable();\n      }\n\n      assertAuthStatus(req, noAuthStatusMessage);\n\n      const getAuthDataFromRequest = (req: RequestLike, opts: GetAuthDataFromRequestOptions = {}) => {\n        return getSessionAuthDataFromRequestOriginal(req, { ...opts, logger, acceptsToken: opts?.acceptsToken });\n      };\n\n      return getAuthDataFromRequest(req, { ...opts, logger, acceptsToken: opts?.acceptsToken });\n    };\n  });\n\n/**\n * The `getAuth()` helper retrieves authentication state from the request object.\n *\n * > [!NOTE]\n * > If you are using App Router, use the [`auth()` helper](https://clerk.com/docs/reference/nextjs/app-router/auth) instead.\n *\n * @param req - The Next.js request object.\n * @param [options] - An optional object that can be used to configure the behavior of the `getAuth()` function.\n * @param [options.secretKey] - A string that represents the Secret Key used to sign the session token. If not provided, the Secret Key is retrieved from the environment variable `CLERK_SECRET_KEY`.\n * @returns The `Auth` object. See the [Auth reference](https://clerk.com/docs/reference/backend/types/auth-object) for more information.\n *\n * @example\n * ### Protect API routes\n *\n * The following example demonstrates how to protect an API route by checking if the `userId` is present in the `getAuth()` response.\n *\n * ```tsx {{ filename: 'app/api/example/route.ts' }}\n * import { getAuth } from '@clerk/nextjs/server'\n * import type { NextApiRequest, NextApiResponse } from 'next'\n *\n * export default async function handler(req: NextApiRequest, res: NextApiResponse) {\n *   const { userId } = getAuth(req)\n *\n *   if (!userId) {\n *     return res.status(401).json({ error: 'Not authenticated' })\n *   }\n *\n *   // Add logic that retrieves the data for the API route\n *\n *   return res.status(200).json({ userId: userId })\n * }\n * ```\n *\n * @example\n * ### Usage with `getToken()`\n *\n * `getAuth()` returns [`getToken()`](https://clerk.com/docs/reference/backend/types/auth-object#get-token), which is a method that returns the current user's session token or a custom JWT template.\n *\n * ```tsx {{ filename: 'app/api/example/route.ts' }}\n * import { getAuth } from '@clerk/nextjs/server'\n * import type { NextApiRequest, NextApiResponse } from 'next'\n *\n * export default async function handler(req: NextApiRequest, res: NextApiResponse) {\n *   const { getToken } = getAuth(req)\n *\n *   const token = await getToken({ template: 'supabase' })\n *\n *   // Add logic that retrieves the data\n *   // from your database using the token\n *\n *   return res.status(200).json({})\n * }\n * ```\n *\n * @example\n * ### Usage with `clerkClient`\n *\n * `clerkClient` is used to access the [Backend SDK](https://clerk.com/docs/reference/backend/overview), which exposes Clerk's Backend API resources. You can use `getAuth()` to pass authentication information that many of the Backend SDK methods require, like the user's ID.\n *\n * ```tsx {{ filename: 'app/api/example/route.ts' }}\n * import { clerkClient, getAuth } from '@clerk/nextjs/server'\n * import type { NextApiRequest, NextApiResponse } from 'next'\n *\n * export default async function handler(req: NextApiRequest, res: NextApiResponse) {\n *   const { userId } = getAuth(req)\n *\n *   const client = await clerkClient()\n *\n *   const user = userId ? await client.users.getUser(userId) : null\n *\n *   return res.status(200).json({})\n * }\n * ```\n */\nexport const getAuth = createSyncGetAuth({\n  debugLoggerName: 'getAuth()',\n  noAuthStatusMessage: getAuthAuthHeaderMissing(),\n});\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,sBAA6E;AAC7E,wBAAyB;AAGzB,yBAA2B;AAC3B,0BAAgD;AAEhD,oCAGO;AACP,oBAAyC;AACzC,2BAAiD;AAEjD,mBAAiC;AAU1B,MAAM,qBAAqB,CAAC;AAAA,EACjC;AAAA,EACA;AACF,UAIE,+BAAW,iBAAiB,YAAU;AACpC,SAAO,OAAO,KAAkB,SAAwE;AACtG,YAAI,gCAAS,gCAAU,KAAK,0BAAU,QAAQ,WAAW,CAAC,GAAG;AAC3D,aAAO,OAAO;AAAA,IAChB;AAEA,QAAI,KAAC,4CAAsB,GAAG,GAAG;AAE/B,UAAI,qDAAiC;AACnC,2CAAiB,KAAK,mBAAmB;AAAA,MAC3C;AAEA,YAAM,mCAAmC,MAAM,OAAO,6BAA6B,EAChF,KAAK,OAAK,EAAE,0BAA0B,CAAC,EACvC,MAAM,MAAM,MAAS;AAExB,UAAI,kCAAkC;AACpC,cAAM,IAAI,MAAM,gCAAgC;AAAA,MAClD;AAGA,yCAAiB,KAAK,mBAAmB;AAAA,IAC3C;AAEA,UAAM,yBAAyB,CAACA,MAAkBC,QAAsC,CAAC,MAAM;AAC7F,iBAAO,8BAAAC,wBAA+BF,MAAK,EAAE,GAAGC,OAAM,QAAQ,cAAcA,SAAA,gBAAAA,MAAM,aAAa,CAAC;AAAA,IAClG;AAEA,WAAO,uBAAuB,KAAK,EAAE,GAAG,MAAM,QAAQ,cAAc,6BAAM,aAAa,CAAC;AAAA,EAC1F;AACF,CAAC;AAOI,MAAM,oBAAoB,CAAC;AAAA,EAChC;AAAA,EACA;AACF,UAIE,+BAAW,iBAAiB,YAAU;AACpC,SAAO,CACL,KACA,SAC6C;AAC7C,YAAI,gCAAS,gCAAU,KAAK,0BAAU,QAAQ,WAAW,CAAC,GAAG;AAC3D,aAAO,OAAO;AAAA,IAChB;AAEA,uCAAiB,KAAK,mBAAmB;AAEzC,UAAM,yBAAyB,CAACD,MAAkBC,QAAsC,CAAC,MAAM;AAC7F,iBAAO,8BAAAE,+BAAsCH,MAAK,EAAE,GAAGC,OAAM,QAAQ,cAAcA,SAAA,gBAAAA,MAAM,aAAa,CAAC;AAAA,IACzG;AAEA,WAAO,uBAAuB,KAAK,EAAE,GAAG,MAAM,QAAQ,cAAc,6BAAM,aAAa,CAAC;AAAA,EAC1F;AACF,CAAC;AA4EI,MAAM,UAAU,kBAAkB;AAAA,EACvC,iBAAiB;AAAA,EACjB,yBAAqB,wCAAyB;AAChD,CAAC;","names":["req","opts","getAuthDataFromRequestOriginal","getSessionAuthDataFromRequestOriginal"]}
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/esm/server/createGetAuth.js.map:1:{"version":3,"sources":["../../../src/server/createGetAuth.ts"],"sourcesContent":["import type { AuthObject } from '@clerk/backend';\nimport { constants, type SignedInAuthObject, type SignedOutAuthObject } from '@clerk/backend/internal';\nimport { isTruthy } from '@clerk/shared/underscore';\nimport type { PendingSessionOptions } from '@clerk/types';\n\nimport { withLogger } from '../utils/debugLogger';\nimport { isNextWithUnstableServerActions } from '../utils/sdk-versions';\nimport type { GetAuthDataFromRequestOptions } from './data/getAuthDataFromRequest';\nimport {\n  getAuthDataFromRequest as getAuthDataFromRequestOriginal,\n  getSessionAuthDataFromRequest as getSessionAuthDataFromRequestOriginal,\n} from './data/getAuthDataFromRequest';\nimport { getAuthAuthHeaderMissing } from './errors';\nimport { detectClerkMiddleware, getHeader } from './headers-utils';\nimport type { RequestLike } from './types';\nimport { assertAuthStatus } from './utils';\n\nexport type GetAuthOptions = {\n  acceptsToken?: GetAuthDataFromRequestOptions['acceptsToken'];\n} & PendingSessionOptions;\n\n/**\n * The async variant of our old `createGetAuth` allows for asynchronous code inside its callback.\n * Should be used with function like `auth()` that are already asynchronous.\n */\nexport const createAsyncGetAuth = ({\n  debugLoggerName,\n  noAuthStatusMessage,\n}: {\n  debugLoggerName: string;\n  noAuthStatusMessage: string;\n}) =>\n  withLogger(debugLoggerName, logger => {\n    return async (req: RequestLike, opts?: { secretKey?: string } & GetAuthOptions): Promise<AuthObject> => {\n      if (isTruthy(getHeader(req, constants.Headers.EnableDebug))) {\n        logger.enable();\n      }\n\n      if (!detectClerkMiddleware(req)) {\n        // Keep the same behaviour for versions that may have issues with bundling `node:fs`\n        if (isNextWithUnstableServerActions) {\n          assertAuthStatus(req, noAuthStatusMessage);\n        }\n\n        const missConfiguredMiddlewareLocation = await import('./fs/middleware-location.js')\n          .then(m => m.suggestMiddlewareLocation())\n          .catch(() => undefined);\n\n        if (missConfiguredMiddlewareLocation) {\n          throw new Error(missConfiguredMiddlewareLocation);\n        }\n\n        // still throw there is no suggested move location\n        assertAuthStatus(req, noAuthStatusMessage);\n      }\n\n      const getAuthDataFromRequest = (req: RequestLike, opts: GetAuthDataFromRequestOptions = {}) => {\n        return getAuthDataFromRequestOriginal(req, { ...opts, logger, acceptsToken: opts?.acceptsToken });\n      };\n\n      return getAuthDataFromRequest(req, { ...opts, logger, acceptsToken: opts?.acceptsToken });\n    };\n  });\n\n/**\n * Previous known as `createGetAuth`. We needed to create a sync and async variant in order to allow for improvements\n * that required dynamic imports (using `require` would not work).\n * It powers the synchronous top-level api `getAuth()`.\n */\nexport const createSyncGetAuth = ({\n  debugLoggerName,\n  noAuthStatusMessage,\n}: {\n  debugLoggerName: string;\n  noAuthStatusMessage: string;\n}) =>\n  withLogger(debugLoggerName, logger => {\n    return (\n      req: RequestLike,\n      opts?: { secretKey?: string } & GetAuthOptions,\n    ): SignedInAuthObject | SignedOutAuthObject => {\n      if (isTruthy(getHeader(req, constants.Headers.EnableDebug))) {\n        logger.enable();\n      }\n\n      assertAuthStatus(req, noAuthStatusMessage);\n\n      const getAuthDataFromRequest = (req: RequestLike, opts: GetAuthDataFromRequestOptions = {}) => {\n        return getSessionAuthDataFromRequestOriginal(req, { ...opts, logger, acceptsToken: opts?.acceptsToken });\n      };\n\n      return getAuthDataFromRequest(req, { ...opts, logger, acceptsToken: opts?.acceptsToken });\n    };\n  });\n\n/**\n * The `getAuth()` helper retrieves authentication state from the request object.\n *\n * > [!NOTE]\n * > If you are using App Router, use the [`auth()` helper](https://clerk.com/docs/reference/nextjs/app-router/auth) instead.\n *\n * @param req - The Next.js request object.\n * @param [options] - An optional object that can be used to configure the behavior of the `getAuth()` function.\n * @param [options.secretKey] - A string that represents the Secret Key used to sign the session token. If not provided, the Secret Key is retrieved from the environment variable `CLERK_SECRET_KEY`.\n * @returns The `Auth` object. See the [Auth reference](https://clerk.com/docs/reference/backend/types/auth-object) for more information.\n *\n * @example\n * ### Protect API routes\n *\n * The following example demonstrates how to protect an API route by checking if the `userId` is present in the `getAuth()` response.\n *\n * ```tsx {{ filename: 'app/api/example/route.ts' }}\n * import { getAuth } from '@clerk/nextjs/server'\n * import type { NextApiRequest, NextApiResponse } from 'next'\n *\n * export default async function handler(req: NextApiRequest, res: NextApiResponse) {\n *   const { userId } = getAuth(req)\n *\n *   if (!userId) {\n *     return res.status(401).json({ error: 'Not authenticated' })\n *   }\n *\n *   // Add logic that retrieves the data for the API route\n *\n *   return res.status(200).json({ userId: userId })\n * }\n * ```\n *\n * @example\n * ### Usage with `getToken()`\n *\n * `getAuth()` returns [`getToken()`](https://clerk.com/docs/reference/backend/types/auth-object#get-token), which is a method that returns the current user's session token or a custom JWT template.\n *\n * ```tsx {{ filename: 'app/api/example/route.ts' }}\n * import { getAuth } from '@clerk/nextjs/server'\n * import type { NextApiRequest, NextApiResponse } from 'next'\n *\n * export default async function handler(req: NextApiRequest, res: NextApiResponse) {\n *   const { getToken } = getAuth(req)\n *\n *   const token = await getToken({ template: 'supabase' })\n *\n *   // Add logic that retrieves the data\n *   // from your database using the token\n *\n *   return res.status(200).json({})\n * }\n * ```\n *\n * @example\n * ### Usage with `clerkClient`\n *\n * `clerkClient` is used to access the [Backend SDK](https://clerk.com/docs/reference/backend/overview), which exposes Clerk's Backend API resources. You can use `getAuth()` to pass authentication information that many of the Backend SDK methods require, like the user's ID.\n *\n * ```tsx {{ filename: 'app/api/example/route.ts' }}\n * import { clerkClient, getAuth } from '@clerk/nextjs/server'\n * import type { NextApiRequest, NextApiResponse } from 'next'\n *\n * export default async function handler(req: NextApiRequest, res: NextApiResponse) {\n *   const { userId } = getAuth(req)\n *\n *   const client = await clerkClient()\n *\n *   const user = userId ? await client.users.getUser(userId) : null\n *\n *   return res.status(200).json({})\n * }\n * ```\n */\nexport const getAuth = createSyncGetAuth({\n  debugLoggerName: 'getAuth()',\n  noAuthStatusMessage: getAuthAuthHeaderMissing(),\n});\n"],"mappings":";AACA,SAAS,iBAAoE;AAC7E,SAAS,gBAAgB;AAGzB,SAAS,kBAAkB;AAC3B,SAAS,uCAAuC;AAEhD;AAAA,EACE,0BAA0B;AAAA,EAC1B,iCAAiC;AAAA,OAC5B;AACP,SAAS,gCAAgC;AACzC,SAAS,uBAAuB,iBAAiB;AAEjD,SAAS,wBAAwB;AAU1B,MAAM,qBAAqB,CAAC;AAAA,EACjC;AAAA,EACA;AACF,MAIE,WAAW,iBAAiB,YAAU;AACpC,SAAO,OAAO,KAAkB,SAAwE;AACtG,QAAI,SAAS,UAAU,KAAK,UAAU,QAAQ,WAAW,CAAC,GAAG;AAC3D,aAAO,OAAO;AAAA,IAChB;AAEA,QAAI,CAAC,sBAAsB,GAAG,GAAG;AAE/B,UAAI,iCAAiC;AACnC,yBAAiB,KAAK,mBAAmB;AAAA,MAC3C;AAEA,YAAM,mCAAmC,MAAM,OAAO,6BAA6B,EAChF,KAAK,OAAK,EAAE,0BAA0B,CAAC,EACvC,MAAM,MAAM,MAAS;AAExB,UAAI,kCAAkC;AACpC,cAAM,IAAI,MAAM,gCAAgC;AAAA,MAClD;AAGA,uBAAiB,KAAK,mBAAmB;AAAA,IAC3C;AAEA,UAAM,yBAAyB,CAACA,MAAkBC,QAAsC,CAAC,MAAM;AAC7F,aAAO,+BAA+BD,MAAK,EAAE,GAAGC,OAAM,QAAQ,cAAcA,SAAA,gBAAAA,MAAM,aAAa,CAAC;AAAA,IAClG;AAEA,WAAO,uBAAuB,KAAK,EAAE,GAAG,MAAM,QAAQ,cAAc,6BAAM,aAAa,CAAC;AAAA,EAC1F;AACF,CAAC;AAOI,MAAM,oBAAoB,CAAC;AAAA,EAChC;AAAA,EACA;AACF,MAIE,WAAW,iBAAiB,YAAU;AACpC,SAAO,CACL,KACA,SAC6C;AAC7C,QAAI,SAAS,UAAU,KAAK,UAAU,QAAQ,WAAW,CAAC,GAAG;AAC3D,aAAO,OAAO;AAAA,IAChB;AAEA,qBAAiB,KAAK,mBAAmB;AAEzC,UAAM,yBAAyB,CAACD,MAAkBC,QAAsC,CAAC,MAAM;AAC7F,aAAO,sCAAsCD,MAAK,EAAE,GAAGC,OAAM,QAAQ,cAAcA,SAAA,gBAAAA,MAAM,aAAa,CAAC;AAAA,IACzG;AAEA,WAAO,uBAAuB,KAAK,EAAE,GAAG,MAAM,QAAQ,cAAc,6BAAM,aAAa,CAAC;AAAA,EAC1F;AACF,CAAC;AA4EI,MAAM,UAAU,kBAAkB;AAAA,EACvC,iBAAiB;AAAA,EACjB,qBAAqB,yBAAyB;AAChD,CAAC;","names":["req","opts"]}
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/esm/server/constants.js.map:1:{"version":3,"sources":["../../../src/server/constants.ts"],"sourcesContent":["import { apiUrlFromPublishableKey } from '@clerk/shared/apiUrlFromPublishableKey';\nimport { isTruthy } from '@clerk/shared/underscore';\n\nexport const CLERK_JS_VERSION = process.env.NEXT_PUBLIC_CLERK_JS_VERSION || '';\nexport const CLERK_JS_URL = process.env.NEXT_PUBLIC_CLERK_JS_URL || '';\nexport const API_VERSION = process.env.CLERK_API_VERSION || 'v1';\nexport const SECRET_KEY = process.env.CLERK_SECRET_KEY || '';\nexport const MACHINE_SECRET_KEY = process.env.CLERK_MACHINE_SECRET_KEY || '';\nexport const PUBLISHABLE_KEY = process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || '';\nexport const ENCRYPTION_KEY = process.env.CLERK_ENCRYPTION_KEY || '';\nexport const API_URL = process.env.CLERK_API_URL || apiUrlFromPublishableKey(PUBLISHABLE_KEY);\nexport const DOMAIN = process.env.NEXT_PUBLIC_CLERK_DOMAIN || '';\nexport const PROXY_URL = process.env.NEXT_PUBLIC_CLERK_PROXY_URL || '';\nexport const IS_SATELLITE = isTruthy(process.env.NEXT_PUBLIC_CLERK_IS_SATELLITE) || false;\nexport const SIGN_IN_URL = process.env.NEXT_PUBLIC_CLERK_SIGN_IN_URL || '';\nexport const SIGN_UP_URL = process.env.NEXT_PUBLIC_CLERK_SIGN_UP_URL || '';\nexport const SDK_METADATA = {\n  name: PACKAGE_NAME,\n  version: PACKAGE_VERSION,\n  environment: process.env.NODE_ENV,\n};\n\nexport const TELEMETRY_DISABLED = isTruthy(process.env.NEXT_PUBLIC_CLERK_TELEMETRY_DISABLED);\nexport const TELEMETRY_DEBUG = isTruthy(process.env.NEXT_PUBLIC_CLERK_TELEMETRY_DEBUG);\n\nexport const KEYLESS_DISABLED = isTruthy(process.env.NEXT_PUBLIC_CLERK_KEYLESS_DISABLED) || false;\n"],"mappings":";AAAA,SAAS,gCAAgC;AACzC,SAAS,gBAAgB;AAElB,MAAM,mBAAmB,QAAQ,IAAI,gCAAgC;AACrE,MAAM,eAAe,QAAQ,IAAI,4BAA4B;AAC7D,MAAM,cAAc,QAAQ,IAAI,qBAAqB;AACrD,MAAM,aAAa,QAAQ,IAAI,oBAAoB;AACnD,MAAM,qBAAqB,QAAQ,IAAI,4BAA4B;AACnE,MAAM,kBAAkB,QAAQ,IAAI,qCAAqC;AACzE,MAAM,iBAAiB,QAAQ,IAAI,wBAAwB;AAC3D,MAAM,UAAU,QAAQ,IAAI,iBAAiB,yBAAyB,eAAe;AACrF,MAAM,SAAS,QAAQ,IAAI,4BAA4B;AACvD,MAAM,YAAY,QAAQ,IAAI,+BAA+B;AAC7D,MAAM,eAAe,SAAS,QAAQ,IAAI,8BAA8B,KAAK;AAC7E,MAAM,cAAc,QAAQ,IAAI,iCAAiC;AACjE,MAAM,cAAc,QAAQ,IAAI,iCAAiC;AACjE,MAAM,eAAe;AAAA,EAC1B,MAAM;AAAA,EACN,SAAS;AAAA,EACT,aAAa,QAAQ,IAAI;AAC3B;AAEO,MAAM,qBAAqB,SAAS,QAAQ,IAAI,oCAAoC;AACpF,MAAM,kBAAkB,SAAS,QAAQ,IAAI,iCAAiC;AAE9E,MAAM,mBAAmB,SAAS,QAAQ,IAAI,kCAAkC,KAAK;","names":[]}
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/cjs/server/constants.js:45:const SECRET_KEY = process.env.CLERK_SECRET_KEY || "";
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/cjs/server/constants.js:47:const PUBLISHABLE_KEY = process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || "";
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/esm/server/constants.js:7:const SECRET_KEY = process.env.CLERK_SECRET_KEY || "";
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..23fbb8e377e5f4c495aa20396001d9b81dd66f44
--- a/middleware.ts
+++ b/middleware.ts
@@ -1,23 +1,23 @@
 import { NextResponse } from "next/server";
 import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
 
-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
+const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
 
 const isPublicRoute = createRouteMatcher([
   "/",
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
 
-const clerk = clerkMiddleware((auth, req) => {
+const clerk = clerkMiddleware(async (auth, req) => {
+  const { userId, redirectToSignIn } = await auth();
   if (isPublicRoute(req)) return;
-  return auth().then(({ userId, redirectToSignIn }) => {
-    if (!userId) return redirectToSignIn();
-    return undefined;
-  });
+  if (!userId) return redirectToSignIn();
+  return undefined;
 });
 
 export default clerkEnabled ? clerk : () => NextResponse.next();
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">

exec
/bin/zsh -lc "curl -s -o /dev/null -D - http://localhost:3000/settings | sed -n '1,30p'" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 130ms:
HTTP/1.1 200 OK
Content-Security-Policy: default-src 'self'; base-uri 'self'; form-action 'self'; frame-ancestors 'none'; object-src 'none'; script-src 'self' 'unsafe-inline' https://*.clerk.accounts.dev 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data: blob: https:; font-src 'self' data:; connect-src 'self' https://*.clerk.accounts.dev https://api.clerk.com; frame-src 'self' https://*.clerk.accounts.dev; worker-src 'self' blob:
Referrer-Policy: strict-origin-when-cross-origin
X-Frame-Options: DENY
X-Content-Type-Options: nosniff
Permissions-Policy: camera=(), microphone=(), geolocation=(), payment=()
Cross-Origin-Opener-Policy: same-origin
Cross-Origin-Resource-Policy: same-site
Vary: rsc, next-router-state-tree, next-router-prefetch, next-router-segment-prefetch, Accept-Encoding
link: </_next/static/media/797e433ab948586e-s.p.dbea232f.woff2>; rel=preload; as="font"; crossorigin=""; type="font/woff2", </_next/static/media/caa3a2e1cccd8315-s.p.853070df.woff2>; rel=preload; as="font"; crossorigin=""; type="font/woff2"
Cache-Control: no-store, must-revalidate
X-Powered-By: Next.js
Content-Type: text/html; charset=utf-8
Date: Fri, 23 Jan 2026 14:15:24 GMT
Connection: keep-alive
Keep-Alive: timeout=5
Transfer-Encoding: chunked

file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..23fbb8e377e5f4c495aa20396001d9b81dd66f44
--- a/middleware.ts
+++ b/middleware.ts
@@ -1,23 +1,23 @@
 import { NextResponse } from "next/server";
 import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
 
-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
+const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
 
 const isPublicRoute = createRouteMatcher([
   "/",
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
 
-const clerk = clerkMiddleware((auth, req) => {
+const clerk = clerkMiddleware(async (auth, req) => {
+  const { userId, redirectToSignIn } = await auth();
   if (isPublicRoute(req)) return;
-  return auth().then(({ userId, redirectToSignIn }) => {
-    if (!userId) return redirectToSignIn();
-    return undefined;
-  });
+  if (!userId) return redirectToSignIn();
+  return undefined;
 });
 
 export default clerkEnabled ? clerk : () => NextResponse.next();
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">


thinking
**Exploring process commands**

I think I can use the `lsof -p` command to check details about open files associated with a specific process. But then again, I wonder if `ps eww PID` might provide some useful information about the environment of that process. It seems exploring these commands could really help me understand what's going on with the specified process. Let me give them a try to see what information they reveal!
exec
/bin/zsh -lc 'PID=$(lsof -t -iTCP:3000 -sTCP:LISTEN)
ps eww -p "$PID" | head -n 5' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 106ms:
  PID   TT  STAT      TIME COMMAND
71753   ??  SN     0:04.98 next-server (v16.1.4) 
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..23fbb8e377e5f4c495aa20396001d9b81dd66f44
--- a/middleware.ts
+++ b/middleware.ts
@@ -1,23 +1,23 @@
 import { NextResponse } from "next/server";
 import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
 
-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
+const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
 
 const isPublicRoute = createRouteMatcher([
   "/",
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
 
-const clerk = clerkMiddleware((auth, req) => {
+const clerk = clerkMiddleware(async (auth, req) => {
+  const { userId, redirectToSignIn } = await auth();
   if (isPublicRoute(req)) return;
-  return auth().then(({ userId, redirectToSignIn }) => {
-    if (!userId) return redirectToSignIn();
-    return undefined;
-  });
+  if (!userId) return redirectToSignIn();
+  return undefined;
 });
 
 export default clerkEnabled ? clerk : () => NextResponse.next();
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">


thinking
**Investigating process commands**

I'm looking into how to use the `ps` command on Mac. It seems like `ps eww` didn't show the environment as expected. I wonder if I need to use `-E` instead? Actually, `ps e` might show environment details, but I'm not entirely sure. I’ll try `ps -p PID -E` next and see if that works. There’s definitely some exploration left to do on this!
exec
/bin/zsh -lc 'PID=$(lsof -t -iTCP:3000 -sTCP:LISTEN)
ps e -p "$PID" | head -n 5' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 89ms:
  PID   TT  STAT      TIME COMMAND
71753   ??  SN     0:04.99 next-server (v16.1.4) 
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..23fbb8e377e5f4c495aa20396001d9b81dd66f44
--- a/middleware.ts
+++ b/middleware.ts
@@ -1,23 +1,23 @@
 import { NextResponse } from "next/server";
 import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
 
-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
+const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
 
 const isPublicRoute = createRouteMatcher([
   "/",
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
 
-const clerk = clerkMiddleware((auth, req) => {
+const clerk = clerkMiddleware(async (auth, req) => {
+  const { userId, redirectToSignIn } = await auth();
   if (isPublicRoute(req)) return;
-  return auth().then(({ userId, redirectToSignIn }) => {
-    if (!userId) return redirectToSignIn();
-    return undefined;
-  });
+  if (!userId) return redirectToSignIn();
+  return undefined;
 });
 
 export default clerkEnabled ? clerk : () => NextResponse.next();
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">


thinking
**Inspecting middleware issues**

I’m considering that the middleware file being outside the `src/` directory could be causing some issues since Next expects it at the root level. I wonder if there's a configuration option to disable this middleware. Maybe `next.config.ts` could include something like `experimental: { instrumentationHook }`, but it seems that's not the case. I guess I should take a closer look at what’s in `next.config.ts` to figure this out.
exec
/bin/zsh -lc "sed -n '1,220p' next.config.ts" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 54ms:
import type { NextConfig } from "next";
import { fileURLToPath } from "node:url";

const isProd = process.env.NODE_ENV === "production";
const projectRoot = fileURLToPath(new URL(".", import.meta.url));

const csp = [
  "default-src 'self'",
  "base-uri 'self'",
  "form-action 'self'",
  "frame-ancestors 'none'",
  "object-src 'none'",
  `script-src 'self' 'unsafe-inline' https://*.clerk.accounts.dev${isProd ? "" : " 'unsafe-eval'"}`,
  "style-src 'self' 'unsafe-inline'",
  "img-src 'self' data: blob: https:",
  "font-src 'self' data:",
  "connect-src 'self' https://*.clerk.accounts.dev https://api.clerk.com",
  "frame-src 'self' https://*.clerk.accounts.dev",
  "worker-src 'self' blob:",
].join("; ");
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..23fbb8e377e5f4c495aa20396001d9b81dd66f44
--- a/middleware.ts
+++ b/middleware.ts
@@ -1,23 +1,23 @@
 import { NextResponse } from "next/server";
 import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
 
-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
+const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
 
 const isPublicRoute = createRouteMatcher([
   "/",
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
 
-const clerk = clerkMiddleware((auth, req) => {
+const clerk = clerkMiddleware(async (auth, req) => {
+  const { userId, redirectToSignIn } = await auth();
   if (isPublicRoute(req)) return;
-  return auth().then(({ userId, redirectToSignIn }) => {
-    if (!userId) return redirectToSignIn();
-    return undefined;
-  });
+  if (!userId) return redirectToSignIn();
+  return undefined;
 });
 
 export default clerkEnabled ? clerk : () => NextResponse.next();
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">

exec
/bin/zsh -lc 'rg -n "export function clerkMiddleware" node_modules/.pnpm/@clerk+nextjs@*/node_modules/@clerk/nextjs/dist/esm/server/middleware.js | head -n 50' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 63ms:
zsh:1: no matches found: node_modules/.pnpm/@clerk+nextjs@*/node_modules/@clerk/nextjs/dist/esm/server/middleware.js
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..23fbb8e377e5f4c495aa20396001d9b81dd66f44
--- a/middleware.ts
+++ b/middleware.ts
@@ -1,23 +1,23 @@
 import { NextResponse } from "next/server";
 import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
 
-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
+const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
 
 const isPublicRoute = createRouteMatcher([
   "/",
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
 
-const clerk = clerkMiddleware((auth, req) => {
+const clerk = clerkMiddleware(async (auth, req) => {
+  const { userId, redirectToSignIn } = await auth();
   if (isPublicRoute(req)) return;
-  return auth().then(({ userId, redirectToSignIn }) => {
-    if (!userId) return redirectToSignIn();
-    return undefined;
-  });
+  if (!userId) return redirectToSignIn();
+  return undefined;
 });
 
 export default clerkEnabled ? clerk : () => NextResponse.next();
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">


thinking
**Searching for a specific file**

I’m focusing on using Zsh globbing to expand my search. I think I need quotes or perhaps I can use `rg` to locate the file instead. I’ll try running a command like `rg --files node_modules/.pnpm/@clerk+nextjs* | rg "middleware" | head` to narrow down the results. It’s important to ensure I’m capturing exactly what I’m looking for! Let’s see what this yields.
exec
/bin/zsh -lc "rg --files node_modules/.pnpm | rg \"@clerk\\+nextjs@\" | rg \"middleware\" | head -n 50" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 145ms:
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/types/server/fs/middleware-location.d.ts.map
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/types/server/fs/middleware-location.d.ts
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/types/server/middleware-storage.d.ts.map
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/types/server/middleware-storage.d.ts
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/cjs/server/fs/middleware-location.js
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/cjs/server/fs/middleware-location.js.map
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/cjs/server/middleware-storage.js
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/cjs/server/middleware-storage.js.map
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/esm/server/fs/middleware-location.js
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/esm/server/fs/middleware-location.js.map
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/esm/server/middleware-storage.js
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/esm/server/middleware-storage.js.map
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..23fbb8e377e5f4c495aa20396001d9b81dd66f44
--- a/middleware.ts
+++ b/middleware.ts
@@ -1,23 +1,23 @@
 import { NextResponse } from "next/server";
 import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
 
-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
+const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
 
 const isPublicRoute = createRouteMatcher([
   "/",
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
 
-const clerk = clerkMiddleware((auth, req) => {
+const clerk = clerkMiddleware(async (auth, req) => {
+  const { userId, redirectToSignIn } = await auth();
   if (isPublicRoute(req)) return;
-  return auth().then(({ userId, redirectToSignIn }) => {
-    if (!userId) return redirectToSignIn();
-    return undefined;
-  });
+  if (!userId) return redirectToSignIn();
+  return undefined;
 });
 
 export default clerkEnabled ? clerk : () => NextResponse.next();
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">


thinking
**Investigating clerkMiddleware**

I notice there's no direct `clerkMiddleware` file, which makes me think it might be related to tree shaking. It's probably referenced in some index file. I'm planning to search within the package for the string "clerkMiddleware(" to see where it's used. This approach might lead me to understand its context better and clarify any confusion around its implementation. Let's see where it takes me!
exec
/bin/zsh -lc "rg -n \"clerkMiddleware\\(\" node_modules/.pnpm/@clerk+nextjs@6.36.9*/node_modules/@clerk/nextjs/dist -S | head -n 40" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 85ms:
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/cjs/server/fs/middleware-location.js:35:  const suggestionMessage = (extension, to, from) => `Clerk: clerkMiddleware() was not run, your middleware file might be misplaced. Move your middleware file to ./${to}middleware.${extension}. Currently located at ./${from}middleware.${extension}`;
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/cjs/server/fs/middleware-location.js.map:1:{"version":3,"sources":["../../../../src/server/fs/middleware-location.ts"],"sourcesContent":["import { nodeCwdOrThrow, nodeFsOrThrow, nodePathOrThrow } from './utils';\n\nfunction hasSrcAppDir() {\n  const { existsSync } = nodeFsOrThrow();\n  const path = nodePathOrThrow();\n  const cwd = nodeCwdOrThrow();\n\n  const projectWithAppSrc = path.join(cwd(), 'src', 'app');\n\n  return !!existsSync(projectWithAppSrc);\n}\n\nfunction suggestMiddlewareLocation() {\n  const fileExtensions = ['ts', 'js'] as const;\n  const suggestionMessage = (\n    extension: (typeof fileExtensions)[number],\n    to: 'src/' | '',\n    from: 'src/app/' | 'app/' | '',\n  ) =>\n    `Clerk: clerkMiddleware() was not run, your middleware file might be misplaced. Move your middleware file to ./${to}middleware.${extension}. Currently located at ./${from}middleware.${extension}`;\n\n  const { existsSync } = nodeFsOrThrow();\n  const path = nodePathOrThrow();\n  const cwd = nodeCwdOrThrow();\n\n  const projectWithAppSrcPath = path.join(cwd(), 'src', 'app');\n  const projectWithAppPath = path.join(cwd(), 'app');\n\n  const checkMiddlewareLocation = (\n    basePath: string,\n    to: 'src/' | '',\n    from: 'src/app/' | 'app/' | '',\n  ): string | undefined => {\n    for (const fileExtension of fileExtensions) {\n      if (existsSync(path.join(basePath, `middleware.${fileExtension}`))) {\n        return suggestionMessage(fileExtension, to, from);\n      }\n    }\n    return undefined;\n  };\n\n  if (existsSync(projectWithAppSrcPath)) {\n    return (\n      checkMiddlewareLocation(projectWithAppSrcPath, 'src/', 'src/app/') || checkMiddlewareLocation(cwd(), 'src/', '')\n    );\n  }\n\n  if (existsSync(projectWithAppPath)) {\n    return checkMiddlewareLocation(projectWithAppPath, '', 'app/');\n  }\n\n  return undefined;\n}\n\nexport { suggestMiddlewareLocation, hasSrcAppDir };\n"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAA+D;AAE/D,SAAS,eAAe;AACtB,QAAM,EAAE,WAAW,QAAI,4BAAc;AACrC,QAAM,WAAO,8BAAgB;AAC7B,QAAM,UAAM,6BAAe;AAE3B,QAAM,oBAAoB,KAAK,KAAK,IAAI,GAAG,OAAO,KAAK;AAEvD,SAAO,CAAC,CAAC,WAAW,iBAAiB;AACvC;AAEA,SAAS,4BAA4B;AACnC,QAAM,iBAAiB,CAAC,MAAM,IAAI;AAClC,QAAM,oBAAoB,CACxB,WACA,IACA,SAEA,iHAAiH,EAAE,cAAc,SAAS,4BAA4B,IAAI,cAAc,SAAS;AAEnM,QAAM,EAAE,WAAW,QAAI,4BAAc;AACrC,QAAM,WAAO,8BAAgB;AAC7B,QAAM,UAAM,6BAAe;AAE3B,QAAM,wBAAwB,KAAK,KAAK,IAAI,GAAG,OAAO,KAAK;AAC3D,QAAM,qBAAqB,KAAK,KAAK,IAAI,GAAG,KAAK;AAEjD,QAAM,0BAA0B,CAC9B,UACA,IACA,SACuB;AACvB,eAAW,iBAAiB,gBAAgB;AAC1C,UAAI,WAAW,KAAK,KAAK,UAAU,cAAc,aAAa,EAAE,CAAC,GAAG;AAClE,eAAO,kBAAkB,eAAe,IAAI,IAAI;AAAA,MAClD;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAEA,MAAI,WAAW,qBAAqB,GAAG;AACrC,WACE,wBAAwB,uBAAuB,QAAQ,UAAU,KAAK,wBAAwB,IAAI,GAAG,QAAQ,EAAE;AAAA,EAEnH;AAEA,MAAI,WAAW,kBAAkB,GAAG;AAClC,WAAO,wBAAwB,oBAAoB,IAAI,MAAM;AAAA,EAC/D;AAEA,SAAO;AACT;","names":[]}
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/cjs/server/errors.js.map:1:{"version":3,"sources":["../../../src/server/errors.ts"],"sourcesContent":["export const missingDomainAndProxy = `\nMissing domain and proxyUrl. A satellite application needs to specify a domain or a proxyUrl.\n\n1) With middleware\n   e.g. export default clerkMiddleware({domain:'YOUR_DOMAIN',isSatellite:true});\n2) With environment variables e.g.\n   NEXT_PUBLIC_CLERK_DOMAIN='YOUR_DOMAIN'\n   NEXT_PUBLIC_CLERK_IS_SATELLITE='true'\n   `;\n\nexport const missingSignInUrlInDev = `\nInvalid signInUrl. A satellite application requires a signInUrl for development instances.\nCheck if signInUrl is missing from your configuration or if it is not an absolute URL\n\n1) With middleware\n   e.g. export default clerkMiddleware({signInUrl:'SOME_URL', isSatellite:true});\n2) With environment variables e.g.\n   NEXT_PUBLIC_CLERK_SIGN_IN_URL='SOME_URL'\n   NEXT_PUBLIC_CLERK_IS_SATELLITE='true'`;\n\nexport const getAuthAuthHeaderMissing = () => authAuthHeaderMissing('getAuth');\n\nexport const authAuthHeaderMissing = (helperName = 'auth', prefixSteps?: string[]) =>\n  `Clerk: ${helperName}() was called but Clerk can't detect usage of clerkMiddleware(). Please ensure the following:\n- ${prefixSteps ? [...prefixSteps, ''].join('\\n- ') : ' '}clerkMiddleware() is used in your Next.js Middleware.\n- Your Middleware matcher is configured to match this route or page.\n- If you are using the src directory, make sure the Middleware file is inside of it.\n\nFor more details, see https://clerk.com/err/auth-middleware\n`;\n\nexport const authSignatureInvalid = `Clerk: Unable to verify request, this usually means the Clerk middleware did not run. Ensure Clerk's middleware is properly integrated and matches the current route. For more information, see: https://clerk.com/docs/reference/nextjs/clerk-middleware. (code=auth_signature_invalid)`;\n\nexport const encryptionKeyInvalid = `Clerk: Unable to decrypt request data, this usually means the encryption key is invalid. Ensure the encryption key is properly set. For more information, see: https://clerk.com/docs/reference/nextjs/clerk-middleware#dynamic-keys. (code=encryption_key_invalid)`;\n\nexport const encryptionKeyInvalidDev = `Clerk: Unable to decrypt request data.\\n\\nRefresh the page if your .env file was just updated. If the issue persists, ensure the encryption key is valid and properly set.\\n\\nFor more information, see: https://clerk.com/docs/reference/nextjs/clerk-middleware#dynamic-keys. (code=encryption_key_invalid)`;\n"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAO,MAAM,wBAAwB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAU9B,MAAM,wBAAwB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAU9B,MAAM,2BAA2B,MAAM,sBAAsB,SAAS;AAEtE,MAAM,wBAAwB,CAAC,aAAa,QAAQ,gBACzD,UAAU,UAAU;AAAA,IAClB,cAAc,CAAC,GAAG,aAAa,EAAE,EAAE,KAAK,MAAM,IAAI,GAAG;AAAA;AAAA;AAAA;AAAA;AAAA;AAOlD,MAAM,uBAAuB;AAE7B,MAAM,uBAAuB;AAE7B,MAAM,0BAA0B;AAAA;AAAA;AAAA;AAAA;","names":[]}
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/cjs/server/errors.js:34:   e.g. export default clerkMiddleware({domain:'YOUR_DOMAIN',isSatellite:true});
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/cjs/server/errors.js:44:   e.g. export default clerkMiddleware({signInUrl:'SOME_URL', isSatellite:true});
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/cjs/server/errors.js:49:const authAuthHeaderMissing = (helperName = "auth", prefixSteps) => `Clerk: ${helperName}() was called but Clerk can't detect usage of clerkMiddleware(). Please ensure the following:
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/cjs/server/errors.js:50:- ${prefixSteps ? [...prefixSteps, ""].join("\n- ") : " "}clerkMiddleware() is used in your Next.js Middleware.
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/cjs/app-router/server/auth.js.map:1:{"version":3,"sources":["../../../../src/app-router/server/auth.ts"],"sourcesContent":["import type { SessionAuthObject } from '@clerk/backend';\nimport type { AuthOptions, GetAuthFnNoRequest, RedirectFun } from '@clerk/backend/internal';\nimport { constants, createClerkRequest, createRedirect, TokenType } from '@clerk/backend/internal';\nimport { notFound, redirect } from 'next/navigation';\n\nimport { PUBLISHABLE_KEY, SIGN_IN_URL, SIGN_UP_URL } from '../../server/constants';\nimport { createAsyncGetAuth } from '../../server/createGetAuth';\nimport { authAuthHeaderMissing } from '../../server/errors';\nimport { getAuthKeyFromRequest, getHeader } from '../../server/headers-utils';\nimport { unauthorized } from '../../server/nextErrors';\nimport type { AuthProtect } from '../../server/protect';\nimport { createProtect } from '../../server/protect';\nimport { decryptClerkRequestData } from '../../server/utils';\nimport { isNextWithUnstableServerActions } from '../../utils/sdk-versions';\nimport { buildRequestLike } from './utils';\n\n/**\n * `Auth` object of the currently active user and the `redirectToSignIn()` method.\n */\nexport type SessionAuthWithRedirect = SessionAuthObject & {\n  /**\n   * The `auth()` helper returns the `redirectToSignIn()` method, which you can use to redirect the user to the sign-in page.\n   *\n   * @param [returnBackUrl] {string | URL} - The URL to redirect the user back to after they sign in.\n   *\n   * > [!NOTE]\n   * > `auth()` on the server-side can only access redirect URLs defined via [environment variables](https://clerk.com/docs/guides/development/clerk-environment-variables#sign-in-and-sign-up-redirects) or [`clerkMiddleware` dynamic keys](https://clerk.com/docs/reference/nextjs/clerk-middleware#dynamic-keys).\n   */\n  redirectToSignIn: RedirectFun<ReturnType<typeof redirect>>;\n\n  /**\n   * The `auth()` helper returns the `redirectToSignUp()` method, which you can use to redirect the user to the sign-up page.\n   *\n   * @param [returnBackUrl] {string | URL} - The URL to redirect the user back to after they sign up.\n   *\n   * > [!NOTE]\n   * > `auth()` on the server-side can only access redirect URLs defined via [environment variables](https://clerk.com/docs/guides/development/clerk-environment-variables#sign-in-and-sign-up-redirects) or [`clerkMiddleware` dynamic keys](https://clerk.com/docs/reference/nextjs/clerk-middleware#dynamic-keys).\n   */\n  redirectToSignUp: RedirectFun<ReturnType<typeof redirect>>;\n};\n\nexport type AuthFn = GetAuthFnNoRequest<SessionAuthWithRedirect, true> & {\n  /**\n   * `auth` includes a single property, the `protect()` method, which you can use in two ways:\n   * - to check if a user is authenticated (signed in)\n   * - to check if a user is authorized (has the correct roles or permissions) to access something, such as a component or a route handler\n   *\n   * The following table describes how auth.protect() behaves based on user authentication or authorization status:\n   *\n   * | Authenticated | Authorized | `auth.protect()` will |\n   * | - | - | - |\n   * | Yes | Yes | Return the [`Auth`](https://clerk.com/docs/reference/backend/types/auth-object) object. |\n   * | Yes | No | Return a `404` error. |\n   * | No | No | Redirect the user to the sign-in page\\*. |\n   *\n   * > [!IMPORTANT]\n   * > \\*For non-document requests, such as API requests, `auth.protect()` returns a `404` error to users who aren't authenticated.\n   *\n   * `auth.protect()` can be used to check if a user is authenticated or authorized to access certain parts of your application or even entire routes. See detailed examples in the [dedicated guide](https://clerk.com/docs/organizations/verify-user-permissions).\n   */\n  protect: AuthProtect;\n};\n\n/**\n * The `auth()` helper returns the [`Auth`](https://clerk.com/docs/reference/backend/types/auth-object) object of the currently active user, as well as the [`redirectToSignIn()`](https://clerk.com/docs/reference/nextjs/app-router/auth#redirect-to-sign-in) method.\n *\n * - Only available for App Router.\n * - Only works on the server-side, such as in Server Components, Route Handlers, and Server Actions.\n * - Requires [`clerkMiddleware()`](https://clerk.com/docs/reference/nextjs/clerk-middleware) to be configured.\n */\nexport const auth: AuthFn = (async (options?: AuthOptions) => {\n  // eslint-disable-next-line @typescript-eslint/no-require-imports\n  require('server-only');\n\n  const request = await buildRequestLike();\n\n  const stepsBasedOnSrcDirectory = async () => {\n    if (isNextWithUnstableServerActions) {\n      return [];\n    }\n\n    try {\n      const isSrcAppDir = await import('../../server/fs/middleware-location.js').then(m => m.hasSrcAppDir());\n      return [`Your Middleware exists at ./${isSrcAppDir ? 'src/' : ''}middleware.(ts|js)`];\n    } catch {\n      return [];\n    }\n  };\n  const authObject = await createAsyncGetAuth({\n    debugLoggerName: 'auth()',\n    noAuthStatusMessage: authAuthHeaderMissing('auth', await stepsBasedOnSrcDirectory()),\n  })(request, {\n    treatPendingAsSignedOut: options?.treatPendingAsSignedOut,\n    acceptsToken: options?.acceptsToken ?? TokenType.SessionToken,\n  });\n\n  const clerkUrl = getAuthKeyFromRequest(request, 'ClerkUrl');\n\n  const createRedirectForRequest = (...args: Parameters<RedirectFun<never>>) => {\n    const { returnBackUrl } = args[0] || {};\n    const clerkRequest = createClerkRequest(request);\n    const devBrowserToken =\n      clerkRequest.clerkUrl.searchParams.get(constants.QueryParameters.DevBrowser) ||\n      clerkRequest.cookies.get(constants.Cookies.DevBrowser);\n\n    const encryptedRequestData = getHeader(request, constants.Headers.ClerkRequestData);\n    const decryptedRequestData = decryptClerkRequestData(encryptedRequestData);\n    return [\n      createRedirect({\n        redirectAdapter: redirect,\n        devBrowserToken: devBrowserToken,\n        baseUrl: clerkRequest.clerkUrl.toString(),\n        publishableKey: decryptedRequestData.publishableKey || PUBLISHABLE_KEY,\n        signInUrl: decryptedRequestData.signInUrl || SIGN_IN_URL,\n        signUpUrl: decryptedRequestData.signUpUrl || SIGN_UP_URL,\n        sessionStatus: authObject.tokenType === TokenType.SessionToken ? authObject.sessionStatus : null,\n      }),\n      returnBackUrl === null ? '' : returnBackUrl || clerkUrl?.toString(),\n    ] as const;\n  };\n\n  const redirectToSignIn: RedirectFun<never> = (opts = {}) => {\n    const [r, returnBackUrl] = createRedirectForRequest(opts);\n    return r.redirectToSignIn({\n      returnBackUrl,\n    });\n  };\n\n  const redirectToSignUp: RedirectFun<never> = (opts = {}) => {\n    const [r, returnBackUrl] = createRedirectForRequest(opts);\n    return r.redirectToSignUp({\n      returnBackUrl,\n    });\n  };\n\n  if (authObject.tokenType === TokenType.SessionToken) {\n    return Object.assign(authObject, { redirectToSignIn, redirectToSignUp });\n  }\n\n  return authObject;\n}) as AuthFn;\n\nauth.protect = async (...args: any[]) => {\n  // eslint-disable-next-line @typescript-eslint/no-require-imports\n  require('server-only');\n\n  const request = await buildRequestLike();\n  const requestedToken = args?.[0]?.token || args?.[1]?.token || TokenType.SessionToken;\n  const authObject = await auth({ acceptsToken: requestedToken });\n\n  const protect = createProtect({\n    request,\n    authObject,\n    redirectToSignIn: authObject.redirectToSignIn,\n    notFound,\n    redirect,\n    unauthorized,\n  });\n\n  return protect(...args);\n};\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA,sBAAyE;AACzE,wBAAmC;AAEnC,uBAA0D;AAC1D,2BAAmC;AACnC,oBAAsC;AACtC,2BAAiD;AACjD,wBAA6B;AAE7B,qBAA8B;AAC9B,mBAAwC;AACxC,0BAAgD;AAChD,IAAAA,gBAAiC;AAwD1B,MAAM,QAAgB,OAAO,YAA0B;AAtE9D;AAwEE,UAAQ,aAAa;AAErB,QAAM,UAAU,UAAM,gCAAiB;AAEvC,QAAM,2BAA2B,YAAY;AAC3C,QAAI,qDAAiC;AACnC,aAAO,CAAC;AAAA,IACV;AAEA,QAAI;AACF,YAAM,cAAc,MAAM,OAAO,wCAAwC,EAAE,KAAK,OAAK,EAAE,aAAa,CAAC;AACrG,aAAO,CAAC,+BAA+B,cAAc,SAAS,EAAE,oBAAoB;AAAA,IACtF,QAAQ;AACN,aAAO,CAAC;AAAA,IACV;AAAA,EACF;AACA,QAAM,aAAa,UAAM,yCAAmB;AAAA,IAC1C,iBAAiB;AAAA,IACjB,yBAAqB,qCAAsB,QAAQ,MAAM,yBAAyB,CAAC;AAAA,EACrF,CAAC,EAAE,SAAS;AAAA,IACV,yBAAyB,mCAAS;AAAA,IAClC,eAAc,wCAAS,iBAAT,YAAyB,0BAAU;AAAA,EACnD,CAAC;AAED,QAAM,eAAW,4CAAsB,SAAS,UAAU;AAE1D,QAAM,2BAA2B,IAAI,SAAyC;AAC5E,UAAM,EAAE,cAAc,IAAI,KAAK,CAAC,KAAK,CAAC;AACtC,UAAM,mBAAe,oCAAmB,OAAO;AAC/C,UAAM,kBACJ,aAAa,SAAS,aAAa,IAAI,0BAAU,gBAAgB,UAAU,KAC3E,aAAa,QAAQ,IAAI,0BAAU,QAAQ,UAAU;AAEvD,UAAM,2BAAuB,gCAAU,SAAS,0BAAU,QAAQ,gBAAgB;AAClF,UAAM,2BAAuB,sCAAwB,oBAAoB;AACzE,WAAO;AAAA,UACL,gCAAe;AAAA,QACb,iBAAiB;AAAA,QACjB;AAAA,QACA,SAAS,aAAa,SAAS,SAAS;AAAA,QACxC,gBAAgB,qBAAqB,kBAAkB;AAAA,QACvD,WAAW,qBAAqB,aAAa;AAAA,QAC7C,WAAW,qBAAqB,aAAa;AAAA,QAC7C,eAAe,WAAW,cAAc,0BAAU,eAAe,WAAW,gBAAgB;AAAA,MAC9F,CAAC;AAAA,MACD,kBAAkB,OAAO,KAAK,kBAAiB,qCAAU;AAAA,IAC3D;AAAA,EACF;AAEA,QAAM,mBAAuC,CAAC,OAAO,CAAC,MAAM;AAC1D,UAAM,CAAC,GAAG,aAAa,IAAI,yBAAyB,IAAI;AACxD,WAAO,EAAE,iBAAiB;AAAA,MACxB;AAAA,IACF,CAAC;AAAA,EACH;AAEA,QAAM,mBAAuC,CAAC,OAAO,CAAC,MAAM;AAC1D,UAAM,CAAC,GAAG,aAAa,IAAI,yBAAyB,IAAI;AACxD,WAAO,EAAE,iBAAiB;AAAA,MACxB;AAAA,IACF,CAAC;AAAA,EACH;AAEA,MAAI,WAAW,cAAc,0BAAU,cAAc;AACnD,WAAO,OAAO,OAAO,YAAY,EAAE,kBAAkB,iBAAiB,CAAC;AAAA,EACzE;AAEA,SAAO;AACT;AAEA,KAAK,UAAU,UAAU,SAAgB;AA9IzC;AAgJE,UAAQ,aAAa;AAErB,QAAM,UAAU,UAAM,gCAAiB;AACvC,QAAM,mBAAiB,kCAAO,OAAP,mBAAW,YAAS,kCAAO,OAAP,mBAAW,UAAS,0BAAU;AACzE,QAAM,aAAa,MAAM,KAAK,EAAE,cAAc,eAAe,CAAC;AAE9D,QAAM,cAAU,8BAAc;AAAA,IAC5B;AAAA,IACA;AAAA,IACA,kBAAkB,WAAW;AAAA,IAC7B;AAAA,IACA;AAAA,IACA;AAAA,EACF,CAAC;AAED,SAAO,QAAQ,GAAG,IAAI;AACxB;","names":["import_utils"]}
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/cjs/server/clerkMiddleware.js.map:1:{"version":3,"sources":["../../../src/server/clerkMiddleware.ts"],"sourcesContent":["import type { AuthObject, ClerkClient } from '@clerk/backend';\nimport type {\n  AuthenticatedState,\n  AuthenticateRequestOptions,\n  ClerkRequest,\n  RedirectFun,\n  RequestState,\n  SignedInAuthObject,\n  SignedOutAuthObject,\n  UnauthenticatedState,\n} from '@clerk/backend/internal';\nimport {\n  AuthStatus,\n  constants,\n  createClerkRequest,\n  createRedirect,\n  getAuthObjectForAcceptedToken,\n  isMachineTokenByPrefix,\n  isTokenTypeAccepted,\n  makeAuthObjectSerializable,\n  TokenType,\n} from '@clerk/backend/internal';\nimport { parsePublishableKey } from '@clerk/shared/keys';\nimport { notFound as nextjsNotFound } from 'next/navigation';\nimport type { NextMiddleware, NextRequest } from 'next/server';\nimport { NextResponse } from 'next/server';\n\nimport type { AuthFn } from '../app-router/server/auth';\nimport type { GetAuthOptions } from '../server/createGetAuth';\nimport { isRedirect, serverRedirectWithAuth, setHeader } from '../utils';\nimport { withLogger } from '../utils/debugLogger';\nimport { canUseKeyless } from '../utils/feature-flags';\nimport { clerkClient } from './clerkClient';\nimport { PUBLISHABLE_KEY, SECRET_KEY, SIGN_IN_URL, SIGN_UP_URL } from './constants';\nimport { type ContentSecurityPolicyOptions, createContentSecurityPolicyHeaders } from './content-security-policy';\nimport { errorThrower } from './errorThrower';\nimport { getHeader } from './headers-utils';\nimport { getKeylessCookieValue } from './keyless';\nimport { clerkMiddlewareRequestDataStorage, clerkMiddlewareRequestDataStore } from './middleware-storage';\nimport {\n  isNextjsNotFoundError,\n  isNextjsRedirectError,\n  isNextjsUnauthorizedError,\n  isRedirectToSignInError,\n  isRedirectToSignUpError,\n  nextjsRedirectError,\n  redirectToSignInError,\n  redirectToSignUpError,\n  unauthorized,\n} from './nextErrors';\nimport type { AuthProtect } from './protect';\nimport { createProtect } from './protect';\nimport type { NextMiddlewareEvtParam, NextMiddlewareRequestParam, NextMiddlewareReturn } from './types';\nimport {\n  assertKey,\n  decorateRequest,\n  handleMultiDomainAndProxy,\n  redirectAdapter,\n  setRequestHeadersOnNextResponse,\n} from './utils';\n\nexport type ClerkMiddlewareSessionAuthObject = (SignedInAuthObject | SignedOutAuthObject) & {\n  redirectToSignIn: RedirectFun<Response>;\n  redirectToSignUp: RedirectFun<Response>;\n};\n\n/**\n * @deprecated Use `ClerkMiddlewareSessionAuthObject` instead.\n */\nexport type ClerkMiddlewareAuthObject = ClerkMiddlewareSessionAuthObject;\n\nexport type ClerkMiddlewareAuth = AuthFn;\n\ntype ClerkMiddlewareHandler = (\n  auth: ClerkMiddlewareAuth,\n  request: NextMiddlewareRequestParam,\n  event: NextMiddlewareEvtParam,\n) => NextMiddlewareReturn;\n\ntype AuthenticateAnyRequestOptions = Omit<AuthenticateRequestOptions, 'acceptsToken'>;\n\n/**\n * The `clerkMiddleware()` function accepts an optional object. The following options are available.\n * @interface\n */\nexport interface ClerkMiddlewareOptions extends AuthenticateAnyRequestOptions {\n  /**\n   * If true, additional debug information will be logged to the console.\n   */\n  debug?: boolean;\n\n  /**\n   * When set, automatically injects a Content-Security-Policy header(s) compatible with Clerk.\n   */\n  contentSecurityPolicy?: ContentSecurityPolicyOptions;\n}\n\ntype ClerkMiddlewareOptionsCallback = (req: NextRequest) => ClerkMiddlewareOptions | Promise<ClerkMiddlewareOptions>;\n\n/**\n * Middleware for Next.js that handles authentication and authorization with Clerk.\n * For more details, please refer to the docs: https://clerk.com/docs/reference/nextjs/clerk-middleware\n */\ninterface ClerkMiddleware {\n  /**\n   * @example\n   * export default clerkMiddleware((auth, request, event) => { ... }, options);\n   */\n  (handler: ClerkMiddlewareHandler, options?: ClerkMiddlewareOptions): NextMiddleware;\n\n  /**\n   * @example\n   * export default clerkMiddleware((auth, request, event) => { ... }, (req) => options);\n   */\n  (handler: ClerkMiddlewareHandler, options?: ClerkMiddlewareOptionsCallback): NextMiddleware;\n\n  /**\n   * @example\n   * export default clerkMiddleware(options);\n   */\n  (options?: ClerkMiddlewareOptions): NextMiddleware;\n\n  /**\n   * @example\n   * export default clerkMiddleware;\n   */\n  (request: NextMiddlewareRequestParam, event: NextMiddlewareEvtParam): NextMiddlewareReturn;\n}\n\n/**\n * The `clerkMiddleware()` helper integrates Clerk authentication into your Next.js application through Middleware. `clerkMiddleware()` is compatible with both the App and Pages routers.\n */\nexport const clerkMiddleware = ((...args: unknown[]): NextMiddleware | NextMiddlewareReturn => {\n  const [request, event] = parseRequestAndEvent(args);\n  const [handler, params] = parseHandlerAndOptions(args);\n\n  const middleware = clerkMiddlewareRequestDataStorage.run(clerkMiddlewareRequestDataStore, () => {\n    const baseNextMiddleware: NextMiddleware = withLogger('clerkMiddleware', logger => async (request, event) => {\n      // Handles the case where `options` is a callback function to dynamically access `NextRequest`\n      const resolvedParams = typeof params === 'function' ? await params(request) : params;\n\n      const keyless = await getKeylessCookieValue(name => request.cookies.get(name)?.value);\n\n      const publishableKey = assertKey(\n        resolvedParams.publishableKey || PUBLISHABLE_KEY || keyless?.publishableKey,\n        () => errorThrower.throwMissingPublishableKeyError(),\n      );\n\n      const secretKey = assertKey(resolvedParams.secretKey || SECRET_KEY || keyless?.secretKey, () =>\n        errorThrower.throwMissingSecretKeyError(),\n      );\n      const signInUrl = resolvedParams.signInUrl || SIGN_IN_URL;\n      const signUpUrl = resolvedParams.signUpUrl || SIGN_UP_URL;\n\n      const options = {\n        publishableKey,\n        secretKey,\n        signInUrl,\n        signUpUrl,\n        ...resolvedParams,\n      };\n\n      // Propagates the request data to be accessed on the server application runtime from helpers such as `clerkClient`\n      clerkMiddlewareRequestDataStore.set('requestData', options);\n      const resolvedClerkClient = await clerkClient();\n\n      if (options.debug) {\n        logger.enable();\n      }\n      const clerkRequest = createClerkRequest(request);\n      logger.debug('options', options);\n      logger.debug('url', () => clerkRequest.toJSON());\n\n      const authHeader = request.headers.get(constants.Headers.Authorization);\n      if (authHeader && authHeader.startsWith('Basic ')) {\n        logger.debug('Basic Auth detected');\n      }\n\n      const cspHeader = request.headers.get(constants.Headers.ContentSecurityPolicy);\n      if (cspHeader) {\n        logger.debug('Content-Security-Policy detected', () => ({\n          value: cspHeader,\n        }));\n      }\n\n      const requestState = await resolvedClerkClient.authenticateRequest(\n        clerkRequest,\n        createAuthenticateRequestOptions(clerkRequest, options),\n      );\n\n      logger.debug('requestState', () => ({\n        status: requestState.status,\n        headers: JSON.stringify(Object.fromEntries(requestState.headers)),\n        reason: requestState.reason,\n      }));\n\n      const locationHeader = requestState.headers.get(constants.Headers.Location);\n      if (locationHeader) {\n        const res = NextResponse.redirect(locationHeader);\n        requestState.headers.forEach((value, key) => {\n          if (key === constants.Headers.Location) {\n            return;\n          }\n          res.headers.append(key, value);\n        });\n        return res;\n      } else if (requestState.status === AuthStatus.Handshake) {\n        throw new Error('Clerk: handshake status without redirect');\n      }\n\n      const authObject = requestState.toAuth();\n      logger.debug('auth', () => ({ auth: authObject, debug: authObject.debug() }));\n\n      const redirectToSignIn = createMiddlewareRedirectToSignIn(clerkRequest);\n      const redirectToSignUp = createMiddlewareRedirectToSignUp(clerkRequest);\n      const protect = await createMiddlewareProtect(clerkRequest, authObject, redirectToSignIn);\n\n      const authHandler = createMiddlewareAuthHandler(requestState, redirectToSignIn, redirectToSignUp);\n      authHandler.protect = protect;\n\n      let handlerResult: Response = NextResponse.next();\n      try {\n        const userHandlerResult = await clerkMiddlewareRequestDataStorage.run(\n          clerkMiddlewareRequestDataStore,\n          async () => handler?.(authHandler, request, event),\n        );\n        handlerResult = userHandlerResult || handlerResult;\n      } catch (e: any) {\n        handlerResult = handleControlFlowErrors(e, clerkRequest, request, requestState);\n      }\n      if (options.contentSecurityPolicy) {\n        const { headers } = createContentSecurityPolicyHeaders(\n          (parsePublishableKey(publishableKey)?.frontendApi ?? '').replace('$', ''),\n          options.contentSecurityPolicy,\n        );\n\n        headers.forEach(([key, value]) => {\n          setHeader(handlerResult, key, value);\n        });\n\n        logger.debug('Clerk generated CSP', () => ({\n          headers,\n        }));\n      }\n\n      // TODO @nikos: we need to make this more generic\n      // and move the logic in clerk/backend\n      if (requestState.headers) {\n        requestState.headers.forEach((value, key) => {\n          if (key === constants.Headers.ContentSecurityPolicy) {\n            logger.debug('Content-Security-Policy detected', () => ({\n              value,\n            }));\n          }\n          handlerResult.headers.append(key, value);\n        });\n      }\n\n      if (isRedirect(handlerResult)) {\n        logger.debug('handlerResult is redirect');\n        return serverRedirectWithAuth(clerkRequest, handlerResult, options);\n      }\n\n      if (options.debug) {\n        setRequestHeadersOnNextResponse(handlerResult, clerkRequest, { [constants.Headers.EnableDebug]: 'true' });\n      }\n\n      const keylessKeysForRequestData =\n        // Only pass keyless credentials when there are no explicit keys\n        secretKey === keyless?.secretKey\n          ? {\n              publishableKey: keyless?.publishableKey,\n              secretKey: keyless?.secretKey,\n            }\n          : {};\n\n      decorateRequest(\n        clerkRequest,\n        handlerResult,\n        requestState,\n        resolvedParams,\n        keylessKeysForRequestData,\n        authObject.tokenType === 'session_token' ? null : makeAuthObjectSerializable(authObject),\n      );\n\n      return handlerResult;\n    });\n\n    const keylessMiddleware: NextMiddleware = async (request, event) => {\n      /**\n       * This mechanism replaces a full-page reload. Ensures that middleware will re-run and authenticate the request properly without the secret key or publishable key to be missing.\n       */\n      if (isKeylessSyncRequest(request)) {\n        return returnBackFromKeylessSync(request);\n      }\n\n      const resolvedParams = typeof params === 'function' ? await params(request) : params;\n      const keyless = await getKeylessCookieValue(name => request.cookies.get(name)?.value);\n\n      const isMissingPublishableKey = !(resolvedParams.publishableKey || PUBLISHABLE_KEY || keyless?.publishableKey);\n      const authHeader = getHeader(request, constants.Headers.Authorization)?.replace('Bearer ', '') ?? '';\n\n      /**\n       * In keyless mode, if the publishable key is missing, let the request through, to render `<ClerkProvider/>` that will resume the flow gracefully.\n       */\n      if (isMissingPublishableKey && !isMachineTokenByPrefix(authHeader)) {\n        const res = NextResponse.next();\n        setRequestHeadersOnNextResponse(res, request, {\n          [constants.Headers.AuthStatus]: 'signed-out',\n        });\n        return res;\n      }\n\n      return baseNextMiddleware(request, event);\n    };\n\n    const nextMiddleware: NextMiddleware = async (request, event) => {\n      if (canUseKeyless) {\n        return keylessMiddleware(request, event);\n      }\n\n      return baseNextMiddleware(request, event);\n    };\n\n    // If we have a request and event, we're being called as a middleware directly\n    // eg, export default clerkMiddleware;\n    if (request && event) {\n      return nextMiddleware(request, event);\n    }\n\n    // Otherwise, return a middleware that can be called with a request and event\n    // eg, export default clerkMiddleware(auth => { ... });\n    return nextMiddleware;\n  });\n\n  return middleware;\n}) as ClerkMiddleware;\n\nconst parseRequestAndEvent = (args: unknown[]) => {\n  return [args[0] instanceof Request ? args[0] : undefined, args[0] instanceof Request ? args[1] : undefined] as [\n    NextMiddlewareRequestParam | undefined,\n    NextMiddlewareEvtParam | undefined,\n  ];\n};\n\nconst parseHandlerAndOptions = (args: unknown[]) => {\n  return [\n    typeof args[0] === 'function' ? args[0] : undefined,\n    (args.length === 2 ? args[1] : typeof args[0] === 'function' ? {} : args[0]) || {},\n  ] as [ClerkMiddlewareHandler | undefined, ClerkMiddlewareOptions | ClerkMiddlewareOptionsCallback];\n};\n\nconst isKeylessSyncRequest = (request: NextMiddlewareRequestParam) =>\n  request.nextUrl.pathname === '/clerk-sync-keyless';\n\nconst returnBackFromKeylessSync = (request: NextMiddlewareRequestParam) => {\n  const returnUrl = request.nextUrl.searchParams.get('returnUrl');\n  const url = new URL(request.url);\n  url.pathname = '';\n\n  return NextResponse.redirect(returnUrl || url.toString());\n};\n\ntype AuthenticateRequest = Pick<ClerkClient, 'authenticateRequest'>['authenticateRequest'];\n\nexport const createAuthenticateRequestOptions = (\n  clerkRequest: ClerkRequest,\n  options: ClerkMiddlewareOptions,\n): Parameters<AuthenticateRequest>[1] => {\n  return {\n    ...options,\n    ...handleMultiDomainAndProxy(clerkRequest, options),\n    // TODO: Leaving the acceptsToken as 'any' opens up the possibility of\n    // an economic attack. We should revisit this and only verify a token\n    // when auth() or auth.protect() is invoked.\n    acceptsToken: 'any',\n  };\n};\n\nconst createMiddlewareRedirectToSignIn = (\n  clerkRequest: ClerkRequest,\n): ClerkMiddlewareSessionAuthObject['redirectToSignIn'] => {\n  return (opts = {}) => {\n    const url = clerkRequest.clerkUrl.toString();\n    redirectToSignInError(url, opts.returnBackUrl);\n  };\n};\n\nconst createMiddlewareRedirectToSignUp = (\n  clerkRequest: ClerkRequest,\n): ClerkMiddlewareSessionAuthObject['redirectToSignUp'] => {\n  return (opts = {}) => {\n    const url = clerkRequest.clerkUrl.toString();\n    redirectToSignUpError(url, opts.returnBackUrl);\n  };\n};\n\nconst createMiddlewareProtect = (\n  clerkRequest: ClerkRequest,\n  rawAuthObject: AuthObject,\n  redirectToSignIn: RedirectFun<Response>,\n) => {\n  return (async (params: any, options: any) => {\n    const notFound = () => nextjsNotFound();\n\n    const redirect = (url: string) =>\n      nextjsRedirectError(url, {\n        redirectUrl: url,\n      });\n\n    const requestedToken = params?.token || options?.token || TokenType.SessionToken;\n    const authObject = getAuthObjectForAcceptedToken({ authObject: rawAuthObject, acceptsToken: requestedToken });\n\n    return createProtect({\n      request: clerkRequest,\n      redirect,\n      notFound,\n      unauthorized,\n      authObject,\n      redirectToSignIn,\n    })(params, options);\n  }) as unknown as Promise<AuthProtect>;\n};\n\n/**\n * Modifies the auth object based on the token type.\n * - For session tokens: adds redirect functions to the auth object\n * - For machine tokens: validates token type and returns appropriate auth object\n */\nconst createMiddlewareAuthHandler = (\n  requestState: AuthenticatedState<'session_token'> | UnauthenticatedState<'session_token'>,\n  redirectToSignIn: RedirectFun<Response>,\n  redirectToSignUp: RedirectFun<Response>,\n): ClerkMiddlewareAuth => {\n  const authHandler = async (options?: GetAuthOptions) => {\n    const rawAuthObject = requestState.toAuth({ treatPendingAsSignedOut: options?.treatPendingAsSignedOut });\n    const acceptsToken = options?.acceptsToken ?? TokenType.SessionToken;\n\n    const authObject = getAuthObjectForAcceptedToken({\n      authObject: rawAuthObject,\n      acceptsToken,\n    });\n\n    if (authObject.tokenType === TokenType.SessionToken && isTokenTypeAccepted(TokenType.SessionToken, acceptsToken)) {\n      return Object.assign(authObject, {\n        redirectToSignIn,\n        redirectToSignUp,\n      });\n    }\n\n    return authObject;\n  };\n\n  return authHandler as ClerkMiddlewareAuth;\n};\n\n// Handle errors thrown by protect() and redirectToSignIn() calls,\n// as we want to align the APIs between middleware, pages and route handlers\n// Normally, middleware requires to explicitly return a response, but we want to\n// avoid discrepancies between the APIs as it's easy to miss the `return` statement\n// especially when copy-pasting code from one place to another.\n// This function handles the known errors thrown by the APIs described above,\n// and returns the appropriate response.\nconst handleControlFlowErrors = (\n  e: any,\n  clerkRequest: ClerkRequest,\n  nextRequest: NextRequest,\n  requestState: RequestState,\n): Response => {\n  if (isNextjsUnauthorizedError(e)) {\n    const response = new NextResponse(null, { status: 401 });\n\n    // RequestState.toAuth() returns a session_token type by default.\n    // We need to cast it to the correct type to check for OAuth tokens.\n    const authObject = (requestState as RequestState<TokenType>).toAuth();\n    if (authObject && authObject.tokenType === TokenType.OAuthToken) {\n      // Following MCP spec, we return WWW-Authenticate header on 401 responses\n      // to enable OAuth 2.0 authorization server discovery (RFC9728).\n      // See https://modelcontextprotocol.io/specification/draft/basic/authorization#2-3-1-authorization-server-location\n      const publishableKey = parsePublishableKey(requestState.publishableKey);\n      return setHeader(\n        response,\n        'WWW-Authenticate',\n        `Bearer resource_metadata=\"https://${publishableKey?.frontendApi}/.well-known/oauth-protected-resource\"`,\n      );\n    }\n\n    return response;\n  }\n\n  if (isNextjsNotFoundError(e)) {\n    // Rewrite to a bogus URL to force not found error\n    return setHeader(\n      // This is an internal rewrite purely to trigger a not found error. We do not want Next.js to think that the\n      // destination URL is a valid page, so we use `nextRequest.url` as the base for the fake URL, which Next.js\n      // understands is an internal URL and won't run middleware against the request.\n      NextResponse.rewrite(new URL(`/clerk_${Date.now()}`, nextRequest.url)),\n      constants.Headers.AuthReason,\n      'protect-rewrite',\n    );\n  }\n\n  const isRedirectToSignIn = isRedirectToSignInError(e);\n  const isRedirectToSignUp = isRedirectToSignUpError(e);\n\n  if (isRedirectToSignIn || isRedirectToSignUp) {\n    const redirect = createRedirect({\n      redirectAdapter,\n      baseUrl: clerkRequest.clerkUrl,\n      signInUrl: requestState.signInUrl,\n      signUpUrl: requestState.signUpUrl,\n      publishableKey: requestState.publishableKey,\n      sessionStatus: requestState.toAuth()?.sessionStatus,\n    });\n\n    const { returnBackUrl } = e;\n    return redirect[isRedirectToSignIn ? 'redirectToSignIn' : 'redirectToSignUp']({ returnBackUrl });\n  }\n\n  if (isNextjsRedirectError(e)) {\n    return redirectAdapter(e.redirectUrl);\n  }\n\n  throw e;\n};\n"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA,sBAUO;AACP,kBAAoC;AACpC,wBAA2C;AAE3C,oBAA6B;AAI7B,mBAA8D;AAC9D,yBAA2B;AAC3B,2BAA8B;AAC9B,yBAA4B;AAC5B,uBAAsE;AACtE,qCAAsF;AACtF,0BAA6B;AAC7B,2BAA0B;AAC1B,qBAAsC;AACtC,gCAAmF;AACnF,wBAUO;AAEP,qBAA8B;AAE9B,IAAAA,gBAMO;AAyEA,MAAM,mBAAmB,IAAI,SAA2D;AAC7F,QAAM,CAAC,SAAS,KAAK,IAAI,qBAAqB,IAAI;AAClD,QAAM,CAAC,SAAS,MAAM,IAAI,uBAAuB,IAAI;AAErD,QAAM,aAAa,4DAAkC,IAAI,2DAAiC,MAAM;AAC9F,UAAM,yBAAqC,+BAAW,mBAAmB,YAAU,OAAOC,UAASC,WAAU;AAzIjH;AA2IM,YAAM,iBAAiB,OAAO,WAAW,aAAa,MAAM,OAAOD,QAAO,IAAI;AAE9E,YAAM,UAAU,UAAM,sCAAsB,UAAK;AA7IvD,YAAAE;AA6I0D,gBAAAA,MAAAF,SAAQ,QAAQ,IAAI,IAAI,MAAxB,gBAAAE,IAA2B;AAAA,OAAK;AAEpF,YAAM,qBAAiB;AAAA,QACrB,eAAe,kBAAkB,qCAAmB,mCAAS;AAAA,QAC7D,MAAM,iCAAa,gCAAgC;AAAA,MACrD;AAEA,YAAM,gBAAY;AAAA,QAAU,eAAe,aAAa,gCAAc,mCAAS;AAAA,QAAW,MACxF,iCAAa,2BAA2B;AAAA,MAC1C;AACA,YAAM,YAAY,eAAe,aAAa;AAC9C,YAAM,YAAY,eAAe,aAAa;AAE9C,YAAM,UAAU;AAAA,QACd;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA,GAAG;AAAA,MACL;AAGA,gEAAgC,IAAI,eAAe,OAAO;AAC1D,YAAM,sBAAsB,UAAM,gCAAY;AAE9C,UAAI,QAAQ,OAAO;AACjB,eAAO,OAAO;AAAA,MAChB;AACA,YAAM,mBAAe,oCAAmBF,QAAO;AAC/C,aAAO,MAAM,WAAW,OAAO;AAC/B,aAAO,MAAM,OAAO,MAAM,aAAa,OAAO,CAAC;AAE/C,YAAM,aAAaA,SAAQ,QAAQ,IAAI,0BAAU,QAAQ,aAAa;AACtE,UAAI,cAAc,WAAW,WAAW,QAAQ,GAAG;AACjD,eAAO,MAAM,qBAAqB;AAAA,MACpC;AAEA,YAAM,YAAYA,SAAQ,QAAQ,IAAI,0BAAU,QAAQ,qBAAqB;AAC7E,UAAI,WAAW;AACb,eAAO,MAAM,oCAAoC,OAAO;AAAA,UACtD,OAAO;AAAA,QACT,EAAE;AAAA,MACJ;AAEA,YAAM,eAAe,MAAM,oBAAoB;AAAA,QAC7C;AAAA,QACA,iCAAiC,cAAc,OAAO;AAAA,MACxD;AAEA,aAAO,MAAM,gBAAgB,OAAO;AAAA,QAClC,QAAQ,aAAa;AAAA,QACrB,SAAS,KAAK,UAAU,OAAO,YAAY,aAAa,OAAO,CAAC;AAAA,QAChE,QAAQ,aAAa;AAAA,MACvB,EAAE;AAEF,YAAM,iBAAiB,aAAa,QAAQ,IAAI,0BAAU,QAAQ,QAAQ;AAC1E,UAAI,gBAAgB;AAClB,cAAM,MAAM,2BAAa,SAAS,cAAc;AAChD,qBAAa,QAAQ,QAAQ,CAAC,OAAO,QAAQ;AAC3C,cAAI,QAAQ,0BAAU,QAAQ,UAAU;AACtC;AAAA,UACF;AACA,cAAI,QAAQ,OAAO,KAAK,KAAK;AAAA,QAC/B,CAAC;AACD,eAAO;AAAA,MACT,WAAW,aAAa,WAAW,2BAAW,WAAW;AACvD,cAAM,IAAI,MAAM,0CAA0C;AAAA,MAC5D;AAEA,YAAM,aAAa,aAAa,OAAO;AACvC,aAAO,MAAM,QAAQ,OAAO,EAAE,MAAM,YAAY,OAAO,WAAW,MAAM,EAAE,EAAE;AAE5E,YAAM,mBAAmB,iCAAiC,YAAY;AACtE,YAAM,mBAAmB,iCAAiC,YAAY;AACtE,YAAM,UAAU,MAAM,wBAAwB,cAAc,YAAY,gBAAgB;AAExF,YAAM,cAAc,4BAA4B,cAAc,kBAAkB,gBAAgB;AAChG,kBAAY,UAAU;AAEtB,UAAI,gBAA0B,2BAAa,KAAK;AAChD,UAAI;AACF,cAAM,oBAAoB,MAAM,4DAAkC;AAAA,UAChE;AAAA,UACA,YAAY,mCAAU,aAAaA,UAASC;AAAA,QAC9C;AACA,wBAAgB,qBAAqB;AAAA,MACvC,SAAS,GAAQ;AACf,wBAAgB,wBAAwB,GAAG,cAAcD,UAAS,YAAY;AAAA,MAChF;AACA,UAAI,QAAQ,uBAAuB;AACjC,cAAM,EAAE,QAAQ,QAAI;AAAA,YACjB,gDAAoB,cAAc,MAAlC,mBAAqC,gBAArC,YAAoD,IAAI,QAAQ,KAAK,EAAE;AAAA,UACxE,QAAQ;AAAA,QACV;AAEA,gBAAQ,QAAQ,CAAC,CAAC,KAAK,KAAK,MAAM;AAChC,sCAAU,eAAe,KAAK,KAAK;AAAA,QACrC,CAAC;AAED,eAAO,MAAM,uBAAuB,OAAO;AAAA,UACzC;AAAA,QACF,EAAE;AAAA,MACJ;AAIA,UAAI,aAAa,SAAS;AACxB,qBAAa,QAAQ,QAAQ,CAAC,OAAO,QAAQ;AAC3C,cAAI,QAAQ,0BAAU,QAAQ,uBAAuB;AACnD,mBAAO,MAAM,oCAAoC,OAAO;AAAA,cACtD;AAAA,YACF,EAAE;AAAA,UACJ;AACA,wBAAc,QAAQ,OAAO,KAAK,KAAK;AAAA,QACzC,CAAC;AAAA,MACH;AAEA,cAAI,yBAAW,aAAa,GAAG;AAC7B,eAAO,MAAM,2BAA2B;AACxC,mBAAO,qCAAuB,cAAc,eAAe,OAAO;AAAA,MACpE;AAEA,UAAI,QAAQ,OAAO;AACjB,2DAAgC,eAAe,cAAc,EAAE,CAAC,0BAAU,QAAQ,WAAW,GAAG,OAAO,CAAC;AAAA,MAC1G;AAEA,YAAM;AAAA;AAAA,QAEJ,eAAc,mCAAS,aACnB;AAAA,UACE,gBAAgB,mCAAS;AAAA,UACzB,WAAW,mCAAS;AAAA,QACtB,IACA,CAAC;AAAA;AAEP;AAAA,QACE;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA,WAAW,cAAc,kBAAkB,WAAO,4CAA2B,UAAU;AAAA,MACzF;AAEA,aAAO;AAAA,IACT,CAAC;AAED,UAAM,oBAAoC,OAAOA,UAASC,WAAU;AAhSxE;AAoSM,UAAI,qBAAqBD,QAAO,GAAG;AACjC,eAAO,0BAA0BA,QAAO;AAAA,MAC1C;AAEA,YAAM,iBAAiB,OAAO,WAAW,aAAa,MAAM,OAAOA,QAAO,IAAI;AAC9E,YAAM,UAAU,UAAM,sCAAsB,UAAK;AAzSvD,YAAAE;AAyS0D,gBAAAA,MAAAF,SAAQ,QAAQ,IAAI,IAAI,MAAxB,gBAAAE,IAA2B;AAAA,OAAK;AAEpF,YAAM,0BAA0B,EAAE,eAAe,kBAAkB,qCAAmB,mCAAS;AAC/F,YAAM,cAAa,+CAAUF,UAAS,0BAAU,QAAQ,aAAa,MAAlD,mBAAqD,QAAQ,WAAW,QAAxE,YAA+E;AAKlG,UAAI,2BAA2B,KAAC,wCAAuB,UAAU,GAAG;AAClE,cAAM,MAAM,2BAAa,KAAK;AAC9B,2DAAgC,KAAKA,UAAS;AAAA,UAC5C,CAAC,0BAAU,QAAQ,UAAU,GAAG;AAAA,QAClC,CAAC;AACD,eAAO;AAAA,MACT;AAEA,aAAO,mBAAmBA,UAASC,MAAK;AAAA,IAC1C;AAEA,UAAM,iBAAiC,OAAOD,UAASC,WAAU;AAC/D,UAAI,oCAAe;AACjB,eAAO,kBAAkBD,UAASC,MAAK;AAAA,MACzC;AAEA,aAAO,mBAAmBD,UAASC,MAAK;AAAA,IAC1C;AAIA,QAAI,WAAW,OAAO;AACpB,aAAO,eAAe,SAAS,KAAK;AAAA,IACtC;AAIA,WAAO;AAAA,EACT,CAAC;AAED,SAAO;AACT;AAEA,MAAM,uBAAuB,CAAC,SAAoB;AAChD,SAAO,CAAC,KAAK,CAAC,aAAa,UAAU,KAAK,CAAC,IAAI,QAAW,KAAK,CAAC,aAAa,UAAU,KAAK,CAAC,IAAI,MAAS;AAI5G;AAEA,MAAM,yBAAyB,CAAC,SAAoB;AAClD,SAAO;AAAA,IACL,OAAO,KAAK,CAAC,MAAM,aAAa,KAAK,CAAC,IAAI;AAAA,KACzC,KAAK,WAAW,IAAI,KAAK,CAAC,IAAI,OAAO,KAAK,CAAC,MAAM,aAAa,CAAC,IAAI,KAAK,CAAC,MAAM,CAAC;AAAA,EACnF;AACF;AAEA,MAAM,uBAAuB,CAAC,YAC5B,QAAQ,QAAQ,aAAa;AAE/B,MAAM,4BAA4B,CAAC,YAAwC;AACzE,QAAM,YAAY,QAAQ,QAAQ,aAAa,IAAI,WAAW;AAC9D,QAAM,MAAM,IAAI,IAAI,QAAQ,GAAG;AAC/B,MAAI,WAAW;AAEf,SAAO,2BAAa,SAAS,aAAa,IAAI,SAAS,CAAC;AAC1D;AAIO,MAAM,mCAAmC,CAC9C,cACA,YACuC;AACvC,SAAO;AAAA,IACL,GAAG;AAAA,IACH,OAAG,yCAA0B,cAAc,OAAO;AAAA;AAAA;AAAA;AAAA,IAIlD,cAAc;AAAA,EAChB;AACF;AAEA,MAAM,mCAAmC,CACvC,iBACyD;AACzD,SAAO,CAAC,OAAO,CAAC,MAAM;AACpB,UAAM,MAAM,aAAa,SAAS,SAAS;AAC3C,iDAAsB,KAAK,KAAK,aAAa;AAAA,EAC/C;AACF;AAEA,MAAM,mCAAmC,CACvC,iBACyD;AACzD,SAAO,CAAC,OAAO,CAAC,MAAM;AACpB,UAAM,MAAM,aAAa,SAAS,SAAS;AAC3C,iDAAsB,KAAK,KAAK,aAAa;AAAA,EAC/C;AACF;AAEA,MAAM,0BAA0B,CAC9B,cACA,eACA,qBACG;AACH,UAAQ,OAAO,QAAa,YAAiB;AAC3C,UAAM,WAAW,UAAM,kBAAAE,UAAe;AAEtC,UAAM,WAAW,CAAC,YAChB,uCAAoB,KAAK;AAAA,MACvB,aAAa;AAAA,IACf,CAAC;AAEH,UAAM,kBAAiB,iCAAQ,WAAS,mCAAS,UAAS,0BAAU;AACpE,UAAM,iBAAa,+CAA8B,EAAE,YAAY,eAAe,cAAc,eAAe,CAAC;AAE5G,eAAO,8BAAc;AAAA,MACnB,SAAS;AAAA,MACT;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF,CAAC,EAAE,QAAQ,OAAO;AAAA,EACpB;AACF;AAOA,MAAM,8BAA8B,CAClC,cACA,kBACA,qBACwB;AACxB,QAAM,cAAc,OAAO,YAA6B;AAlb1D;AAmbI,UAAM,gBAAgB,aAAa,OAAO,EAAE,yBAAyB,mCAAS,wBAAwB,CAAC;AACvG,UAAM,gBAAe,wCAAS,iBAAT,YAAyB,0BAAU;AAExD,UAAM,iBAAa,+CAA8B;AAAA,MAC/C,YAAY;AAAA,MACZ;AAAA,IACF,CAAC;AAED,QAAI,WAAW,cAAc,0BAAU,oBAAgB,qCAAoB,0BAAU,cAAc,YAAY,GAAG;AAChH,aAAO,OAAO,OAAO,YAAY;AAAA,QAC/B;AAAA,QACA;AAAA,MACF,CAAC;AAAA,IACH;AAEA,WAAO;AAAA,EACT;AAEA,SAAO;AACT;AASA,MAAM,0BAA0B,CAC9B,GACA,cACA,aACA,iBACa;AApdf;AAqdE,UAAI,6CAA0B,CAAC,GAAG;AAChC,UAAM,WAAW,IAAI,2BAAa,MAAM,EAAE,QAAQ,IAAI,CAAC;AAIvD,UAAM,aAAc,aAAyC,OAAO;AACpE,QAAI,cAAc,WAAW,cAAc,0BAAU,YAAY;AAI/D,YAAM,qBAAiB,iCAAoB,aAAa,cAAc;AACtE,iBAAO;AAAA,QACL;AAAA,QACA;AAAA,QACA,qCAAqC,iDAAgB,WAAW;AAAA,MAClE;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAEA,UAAI,yCAAsB,CAAC,GAAG;AAE5B,eAAO;AAAA;AAAA;AAAA;AAAA,MAIL,2BAAa,QAAQ,IAAI,IAAI,UAAU,KAAK,IAAI,CAAC,IAAI,YAAY,GAAG,CAAC;AAAA,MACrE,0BAAU,QAAQ;AAAA,MAClB;AAAA,IACF;AAAA,EACF;AAEA,QAAM,yBAAqB,2CAAwB,CAAC;AACpD,QAAM,yBAAqB,2CAAwB,CAAC;AAEpD,MAAI,sBAAsB,oBAAoB;AAC5C,UAAM,eAAW,gCAAe;AAAA,MAC9B;AAAA,MACA,SAAS,aAAa;AAAA,MACtB,WAAW,aAAa;AAAA,MACxB,WAAW,aAAa;AAAA,MACxB,gBAAgB,aAAa;AAAA,MAC7B,gBAAe,kBAAa,OAAO,MAApB,mBAAuB;AAAA,IACxC,CAAC;AAED,UAAM,EAAE,cAAc,IAAI;AAC1B,WAAO,SAAS,qBAAqB,qBAAqB,kBAAkB,EAAE,EAAE,cAAc,CAAC;AAAA,EACjG;AAEA,UAAI,yCAAsB,CAAC,GAAG;AAC5B,eAAO,+BAAgB,EAAE,WAAW;AAAA,EACtC;AAEA,QAAM;AACR;","names":["import_utils","request","event","_a","nextjsNotFound"]}
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/esm/server/errors.js:6:   e.g. export default clerkMiddleware({domain:'YOUR_DOMAIN',isSatellite:true});
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/esm/server/errors.js:16:   e.g. export default clerkMiddleware({signInUrl:'SOME_URL', isSatellite:true});
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/esm/server/errors.js:21:const authAuthHeaderMissing = (helperName = "auth", prefixSteps) => `Clerk: ${helperName}() was called but Clerk can't detect usage of clerkMiddleware(). Please ensure the following:
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/esm/server/errors.js:22:- ${prefixSteps ? [...prefixSteps, ""].join("\n- ") : " "}clerkMiddleware() is used in your Next.js Middleware.
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/esm/server/clerkMiddleware.js.map:1:{"version":3,"sources":["../../../src/server/clerkMiddleware.ts"],"sourcesContent":["import type { AuthObject, ClerkClient } from '@clerk/backend';\nimport type {\n  AuthenticatedState,\n  AuthenticateRequestOptions,\n  ClerkRequest,\n  RedirectFun,\n  RequestState,\n  SignedInAuthObject,\n  SignedOutAuthObject,\n  UnauthenticatedState,\n} from '@clerk/backend/internal';\nimport {\n  AuthStatus,\n  constants,\n  createClerkRequest,\n  createRedirect,\n  getAuthObjectForAcceptedToken,\n  isMachineTokenByPrefix,\n  isTokenTypeAccepted,\n  makeAuthObjectSerializable,\n  TokenType,\n} from '@clerk/backend/internal';\nimport { parsePublishableKey } from '@clerk/shared/keys';\nimport { notFound as nextjsNotFound } from 'next/navigation';\nimport type { NextMiddleware, NextRequest } from 'next/server';\nimport { NextResponse } from 'next/server';\n\nimport type { AuthFn } from '../app-router/server/auth';\nimport type { GetAuthOptions } from '../server/createGetAuth';\nimport { isRedirect, serverRedirectWithAuth, setHeader } from '../utils';\nimport { withLogger } from '../utils/debugLogger';\nimport { canUseKeyless } from '../utils/feature-flags';\nimport { clerkClient } from './clerkClient';\nimport { PUBLISHABLE_KEY, SECRET_KEY, SIGN_IN_URL, SIGN_UP_URL } from './constants';\nimport { type ContentSecurityPolicyOptions, createContentSecurityPolicyHeaders } from './content-security-policy';\nimport { errorThrower } from './errorThrower';\nimport { getHeader } from './headers-utils';\nimport { getKeylessCookieValue } from './keyless';\nimport { clerkMiddlewareRequestDataStorage, clerkMiddlewareRequestDataStore } from './middleware-storage';\nimport {\n  isNextjsNotFoundError,\n  isNextjsRedirectError,\n  isNextjsUnauthorizedError,\n  isRedirectToSignInError,\n  isRedirectToSignUpError,\n  nextjsRedirectError,\n  redirectToSignInError,\n  redirectToSignUpError,\n  unauthorized,\n} from './nextErrors';\nimport type { AuthProtect } from './protect';\nimport { createProtect } from './protect';\nimport type { NextMiddlewareEvtParam, NextMiddlewareRequestParam, NextMiddlewareReturn } from './types';\nimport {\n  assertKey,\n  decorateRequest,\n  handleMultiDomainAndProxy,\n  redirectAdapter,\n  setRequestHeadersOnNextResponse,\n} from './utils';\n\nexport type ClerkMiddlewareSessionAuthObject = (SignedInAuthObject | SignedOutAuthObject) & {\n  redirectToSignIn: RedirectFun<Response>;\n  redirectToSignUp: RedirectFun<Response>;\n};\n\n/**\n * @deprecated Use `ClerkMiddlewareSessionAuthObject` instead.\n */\nexport type ClerkMiddlewareAuthObject = ClerkMiddlewareSessionAuthObject;\n\nexport type ClerkMiddlewareAuth = AuthFn;\n\ntype ClerkMiddlewareHandler = (\n  auth: ClerkMiddlewareAuth,\n  request: NextMiddlewareRequestParam,\n  event: NextMiddlewareEvtParam,\n) => NextMiddlewareReturn;\n\ntype AuthenticateAnyRequestOptions = Omit<AuthenticateRequestOptions, 'acceptsToken'>;\n\n/**\n * The `clerkMiddleware()` function accepts an optional object. The following options are available.\n * @interface\n */\nexport interface ClerkMiddlewareOptions extends AuthenticateAnyRequestOptions {\n  /**\n   * If true, additional debug information will be logged to the console.\n   */\n  debug?: boolean;\n\n  /**\n   * When set, automatically injects a Content-Security-Policy header(s) compatible with Clerk.\n   */\n  contentSecurityPolicy?: ContentSecurityPolicyOptions;\n}\n\ntype ClerkMiddlewareOptionsCallback = (req: NextRequest) => ClerkMiddlewareOptions | Promise<ClerkMiddlewareOptions>;\n\n/**\n * Middleware for Next.js that handles authentication and authorization with Clerk.\n * For more details, please refer to the docs: https://clerk.com/docs/reference/nextjs/clerk-middleware\n */\ninterface ClerkMiddleware {\n  /**\n   * @example\n   * export default clerkMiddleware((auth, request, event) => { ... }, options);\n   */\n  (handler: ClerkMiddlewareHandler, options?: ClerkMiddlewareOptions): NextMiddleware;\n\n  /**\n   * @example\n   * export default clerkMiddleware((auth, request, event) => { ... }, (req) => options);\n   */\n  (handler: ClerkMiddlewareHandler, options?: ClerkMiddlewareOptionsCallback): NextMiddleware;\n\n  /**\n   * @example\n   * export default clerkMiddleware(options);\n   */\n  (options?: ClerkMiddlewareOptions): NextMiddleware;\n\n  /**\n   * @example\n   * export default clerkMiddleware;\n   */\n  (request: NextMiddlewareRequestParam, event: NextMiddlewareEvtParam): NextMiddlewareReturn;\n}\n\n/**\n * The `clerkMiddleware()` helper integrates Clerk authentication into your Next.js application through Middleware. `clerkMiddleware()` is compatible with both the App and Pages routers.\n */\nexport const clerkMiddleware = ((...args: unknown[]): NextMiddleware | NextMiddlewareReturn => {\n  const [request, event] = parseRequestAndEvent(args);\n  const [handler, params] = parseHandlerAndOptions(args);\n\n  const middleware = clerkMiddlewareRequestDataStorage.run(clerkMiddlewareRequestDataStore, () => {\n    const baseNextMiddleware: NextMiddleware = withLogger('clerkMiddleware', logger => async (request, event) => {\n      // Handles the case where `options` is a callback function to dynamically access `NextRequest`\n      const resolvedParams = typeof params === 'function' ? await params(request) : params;\n\n      const keyless = await getKeylessCookieValue(name => request.cookies.get(name)?.value);\n\n      const publishableKey = assertKey(\n        resolvedParams.publishableKey || PUBLISHABLE_KEY || keyless?.publishableKey,\n        () => errorThrower.throwMissingPublishableKeyError(),\n      );\n\n      const secretKey = assertKey(resolvedParams.secretKey || SECRET_KEY || keyless?.secretKey, () =>\n        errorThrower.throwMissingSecretKeyError(),\n      );\n      const signInUrl = resolvedParams.signInUrl || SIGN_IN_URL;\n      const signUpUrl = resolvedParams.signUpUrl || SIGN_UP_URL;\n\n      const options = {\n        publishableKey,\n        secretKey,\n        signInUrl,\n        signUpUrl,\n        ...resolvedParams,\n      };\n\n      // Propagates the request data to be accessed on the server application runtime from helpers such as `clerkClient`\n      clerkMiddlewareRequestDataStore.set('requestData', options);\n      const resolvedClerkClient = await clerkClient();\n\n      if (options.debug) {\n        logger.enable();\n      }\n      const clerkRequest = createClerkRequest(request);\n      logger.debug('options', options);\n      logger.debug('url', () => clerkRequest.toJSON());\n\n      const authHeader = request.headers.get(constants.Headers.Authorization);\n      if (authHeader && authHeader.startsWith('Basic ')) {\n        logger.debug('Basic Auth detected');\n      }\n\n      const cspHeader = request.headers.get(constants.Headers.ContentSecurityPolicy);\n      if (cspHeader) {\n        logger.debug('Content-Security-Policy detected', () => ({\n          value: cspHeader,\n        }));\n      }\n\n      const requestState = await resolvedClerkClient.authenticateRequest(\n        clerkRequest,\n        createAuthenticateRequestOptions(clerkRequest, options),\n      );\n\n      logger.debug('requestState', () => ({\n        status: requestState.status,\n        headers: JSON.stringify(Object.fromEntries(requestState.headers)),\n        reason: requestState.reason,\n      }));\n\n      const locationHeader = requestState.headers.get(constants.Headers.Location);\n      if (locationHeader) {\n        const res = NextResponse.redirect(locationHeader);\n        requestState.headers.forEach((value, key) => {\n          if (key === constants.Headers.Location) {\n            return;\n          }\n          res.headers.append(key, value);\n        });\n        return res;\n      } else if (requestState.status === AuthStatus.Handshake) {\n        throw new Error('Clerk: handshake status without redirect');\n      }\n\n      const authObject = requestState.toAuth();\n      logger.debug('auth', () => ({ auth: authObject, debug: authObject.debug() }));\n\n      const redirectToSignIn = createMiddlewareRedirectToSignIn(clerkRequest);\n      const redirectToSignUp = createMiddlewareRedirectToSignUp(clerkRequest);\n      const protect = await createMiddlewareProtect(clerkRequest, authObject, redirectToSignIn);\n\n      const authHandler = createMiddlewareAuthHandler(requestState, redirectToSignIn, redirectToSignUp);\n      authHandler.protect = protect;\n\n      let handlerResult: Response = NextResponse.next();\n      try {\n        const userHandlerResult = await clerkMiddlewareRequestDataStorage.run(\n          clerkMiddlewareRequestDataStore,\n          async () => handler?.(authHandler, request, event),\n        );\n        handlerResult = userHandlerResult || handlerResult;\n      } catch (e: any) {\n        handlerResult = handleControlFlowErrors(e, clerkRequest, request, requestState);\n      }\n      if (options.contentSecurityPolicy) {\n        const { headers } = createContentSecurityPolicyHeaders(\n          (parsePublishableKey(publishableKey)?.frontendApi ?? '').replace('$', ''),\n          options.contentSecurityPolicy,\n        );\n\n        headers.forEach(([key, value]) => {\n          setHeader(handlerResult, key, value);\n        });\n\n        logger.debug('Clerk generated CSP', () => ({\n          headers,\n        }));\n      }\n\n      // TODO @nikos: we need to make this more generic\n      // and move the logic in clerk/backend\n      if (requestState.headers) {\n        requestState.headers.forEach((value, key) => {\n          if (key === constants.Headers.ContentSecurityPolicy) {\n            logger.debug('Content-Security-Policy detected', () => ({\n              value,\n            }));\n          }\n          handlerResult.headers.append(key, value);\n        });\n      }\n\n      if (isRedirect(handlerResult)) {\n        logger.debug('handlerResult is redirect');\n        return serverRedirectWithAuth(clerkRequest, handlerResult, options);\n      }\n\n      if (options.debug) {\n        setRequestHeadersOnNextResponse(handlerResult, clerkRequest, { [constants.Headers.EnableDebug]: 'true' });\n      }\n\n      const keylessKeysForRequestData =\n        // Only pass keyless credentials when there are no explicit keys\n        secretKey === keyless?.secretKey\n          ? {\n              publishableKey: keyless?.publishableKey,\n              secretKey: keyless?.secretKey,\n            }\n          : {};\n\n      decorateRequest(\n        clerkRequest,\n        handlerResult,\n        requestState,\n        resolvedParams,\n        keylessKeysForRequestData,\n        authObject.tokenType === 'session_token' ? null : makeAuthObjectSerializable(authObject),\n      );\n\n      return handlerResult;\n    });\n\n    const keylessMiddleware: NextMiddleware = async (request, event) => {\n      /**\n       * This mechanism replaces a full-page reload. Ensures that middleware will re-run and authenticate the request properly without the secret key or publishable key to be missing.\n       */\n      if (isKeylessSyncRequest(request)) {\n        return returnBackFromKeylessSync(request);\n      }\n\n      const resolvedParams = typeof params === 'function' ? await params(request) : params;\n      const keyless = await getKeylessCookieValue(name => request.cookies.get(name)?.value);\n\n      const isMissingPublishableKey = !(resolvedParams.publishableKey || PUBLISHABLE_KEY || keyless?.publishableKey);\n      const authHeader = getHeader(request, constants.Headers.Authorization)?.replace('Bearer ', '') ?? '';\n\n      /**\n       * In keyless mode, if the publishable key is missing, let the request through, to render `<ClerkProvider/>` that will resume the flow gracefully.\n       */\n      if (isMissingPublishableKey && !isMachineTokenByPrefix(authHeader)) {\n        const res = NextResponse.next();\n        setRequestHeadersOnNextResponse(res, request, {\n          [constants.Headers.AuthStatus]: 'signed-out',\n        });\n        return res;\n      }\n\n      return baseNextMiddleware(request, event);\n    };\n\n    const nextMiddleware: NextMiddleware = async (request, event) => {\n      if (canUseKeyless) {\n        return keylessMiddleware(request, event);\n      }\n\n      return baseNextMiddleware(request, event);\n    };\n\n    // If we have a request and event, we're being called as a middleware directly\n    // eg, export default clerkMiddleware;\n    if (request && event) {\n      return nextMiddleware(request, event);\n    }\n\n    // Otherwise, return a middleware that can be called with a request and event\n    // eg, export default clerkMiddleware(auth => { ... });\n    return nextMiddleware;\n  });\n\n  return middleware;\n}) as ClerkMiddleware;\n\nconst parseRequestAndEvent = (args: unknown[]) => {\n  return [args[0] instanceof Request ? args[0] : undefined, args[0] instanceof Request ? args[1] : undefined] as [\n    NextMiddlewareRequestParam | undefined,\n    NextMiddlewareEvtParam | undefined,\n  ];\n};\n\nconst parseHandlerAndOptions = (args: unknown[]) => {\n  return [\n    typeof args[0] === 'function' ? args[0] : undefined,\n    (args.length === 2 ? args[1] : typeof args[0] === 'function' ? {} : args[0]) || {},\n  ] as [ClerkMiddlewareHandler | undefined, ClerkMiddlewareOptions | ClerkMiddlewareOptionsCallback];\n};\n\nconst isKeylessSyncRequest = (request: NextMiddlewareRequestParam) =>\n  request.nextUrl.pathname === '/clerk-sync-keyless';\n\nconst returnBackFromKeylessSync = (request: NextMiddlewareRequestParam) => {\n  const returnUrl = request.nextUrl.searchParams.get('returnUrl');\n  const url = new URL(request.url);\n  url.pathname = '';\n\n  return NextResponse.redirect(returnUrl || url.toString());\n};\n\ntype AuthenticateRequest = Pick<ClerkClient, 'authenticateRequest'>['authenticateRequest'];\n\nexport const createAuthenticateRequestOptions = (\n  clerkRequest: ClerkRequest,\n  options: ClerkMiddlewareOptions,\n): Parameters<AuthenticateRequest>[1] => {\n  return {\n    ...options,\n    ...handleMultiDomainAndProxy(clerkRequest, options),\n    // TODO: Leaving the acceptsToken as 'any' opens up the possibility of\n    // an economic attack. We should revisit this and only verify a token\n    // when auth() or auth.protect() is invoked.\n    acceptsToken: 'any',\n  };\n};\n\nconst createMiddlewareRedirectToSignIn = (\n  clerkRequest: ClerkRequest,\n): ClerkMiddlewareSessionAuthObject['redirectToSignIn'] => {\n  return (opts = {}) => {\n    const url = clerkRequest.clerkUrl.toString();\n    redirectToSignInError(url, opts.returnBackUrl);\n  };\n};\n\nconst createMiddlewareRedirectToSignUp = (\n  clerkRequest: ClerkRequest,\n): ClerkMiddlewareSessionAuthObject['redirectToSignUp'] => {\n  return (opts = {}) => {\n    const url = clerkRequest.clerkUrl.toString();\n    redirectToSignUpError(url, opts.returnBackUrl);\n  };\n};\n\nconst createMiddlewareProtect = (\n  clerkRequest: ClerkRequest,\n  rawAuthObject: AuthObject,\n  redirectToSignIn: RedirectFun<Response>,\n) => {\n  return (async (params: any, options: any) => {\n    const notFound = () => nextjsNotFound();\n\n    const redirect = (url: string) =>\n      nextjsRedirectError(url, {\n        redirectUrl: url,\n      });\n\n    const requestedToken = params?.token || options?.token || TokenType.SessionToken;\n    const authObject = getAuthObjectForAcceptedToken({ authObject: rawAuthObject, acceptsToken: requestedToken });\n\n    return createProtect({\n      request: clerkRequest,\n      redirect,\n      notFound,\n      unauthorized,\n      authObject,\n      redirectToSignIn,\n    })(params, options);\n  }) as unknown as Promise<AuthProtect>;\n};\n\n/**\n * Modifies the auth object based on the token type.\n * - For session tokens: adds redirect functions to the auth object\n * - For machine tokens: validates token type and returns appropriate auth object\n */\nconst createMiddlewareAuthHandler = (\n  requestState: AuthenticatedState<'session_token'> | UnauthenticatedState<'session_token'>,\n  redirectToSignIn: RedirectFun<Response>,\n  redirectToSignUp: RedirectFun<Response>,\n): ClerkMiddlewareAuth => {\n  const authHandler = async (options?: GetAuthOptions) => {\n    const rawAuthObject = requestState.toAuth({ treatPendingAsSignedOut: options?.treatPendingAsSignedOut });\n    const acceptsToken = options?.acceptsToken ?? TokenType.SessionToken;\n\n    const authObject = getAuthObjectForAcceptedToken({\n      authObject: rawAuthObject,\n      acceptsToken,\n    });\n\n    if (authObject.tokenType === TokenType.SessionToken && isTokenTypeAccepted(TokenType.SessionToken, acceptsToken)) {\n      return Object.assign(authObject, {\n        redirectToSignIn,\n        redirectToSignUp,\n      });\n    }\n\n    return authObject;\n  };\n\n  return authHandler as ClerkMiddlewareAuth;\n};\n\n// Handle errors thrown by protect() and redirectToSignIn() calls,\n// as we want to align the APIs between middleware, pages and route handlers\n// Normally, middleware requires to explicitly return a response, but we want to\n// avoid discrepancies between the APIs as it's easy to miss the `return` statement\n// especially when copy-pasting code from one place to another.\n// This function handles the known errors thrown by the APIs described above,\n// and returns the appropriate response.\nconst handleControlFlowErrors = (\n  e: any,\n  clerkRequest: ClerkRequest,\n  nextRequest: NextRequest,\n  requestState: RequestState,\n): Response => {\n  if (isNextjsUnauthorizedError(e)) {\n    const response = new NextResponse(null, { status: 401 });\n\n    // RequestState.toAuth() returns a session_token type by default.\n    // We need to cast it to the correct type to check for OAuth tokens.\n    const authObject = (requestState as RequestState<TokenType>).toAuth();\n    if (authObject && authObject.tokenType === TokenType.OAuthToken) {\n      // Following MCP spec, we return WWW-Authenticate header on 401 responses\n      // to enable OAuth 2.0 authorization server discovery (RFC9728).\n      // See https://modelcontextprotocol.io/specification/draft/basic/authorization#2-3-1-authorization-server-location\n      const publishableKey = parsePublishableKey(requestState.publishableKey);\n      return setHeader(\n        response,\n        'WWW-Authenticate',\n        `Bearer resource_metadata=\"https://${publishableKey?.frontendApi}/.well-known/oauth-protected-resource\"`,\n      );\n    }\n\n    return response;\n  }\n\n  if (isNextjsNotFoundError(e)) {\n    // Rewrite to a bogus URL to force not found error\n    return setHeader(\n      // This is an internal rewrite purely to trigger a not found error. We do not want Next.js to think that the\n      // destination URL is a valid page, so we use `nextRequest.url` as the base for the fake URL, which Next.js\n      // understands is an internal URL and won't run middleware against the request.\n      NextResponse.rewrite(new URL(`/clerk_${Date.now()}`, nextRequest.url)),\n      constants.Headers.AuthReason,\n      'protect-rewrite',\n    );\n  }\n\n  const isRedirectToSignIn = isRedirectToSignInError(e);\n  const isRedirectToSignUp = isRedirectToSignUpError(e);\n\n  if (isRedirectToSignIn || isRedirectToSignUp) {\n    const redirect = createRedirect({\n      redirectAdapter,\n      baseUrl: clerkRequest.clerkUrl,\n      signInUrl: requestState.signInUrl,\n      signUpUrl: requestState.signUpUrl,\n      publishableKey: requestState.publishableKey,\n      sessionStatus: requestState.toAuth()?.sessionStatus,\n    });\n\n    const { returnBackUrl } = e;\n    return redirect[isRedirectToSignIn ? 'redirectToSignIn' : 'redirectToSignUp']({ returnBackUrl });\n  }\n\n  if (isNextjsRedirectError(e)) {\n    return redirectAdapter(e.redirectUrl);\n  }\n\n  throw e;\n};\n"],"mappings":";AAWA;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AACP,SAAS,2BAA2B;AACpC,SAAS,YAAY,sBAAsB;AAE3C,SAAS,oBAAoB;AAI7B,SAAS,YAAY,wBAAwB,iBAAiB;AAC9D,SAAS,kBAAkB;AAC3B,SAAS,qBAAqB;AAC9B,SAAS,mBAAmB;AAC5B,SAAS,iBAAiB,YAAY,aAAa,mBAAmB;AACtE,SAA4C,0CAA0C;AACtF,SAAS,oBAAoB;AAC7B,SAAS,iBAAiB;AAC1B,SAAS,6BAA6B;AACtC,SAAS,mCAAmC,uCAAuC;AACnF;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAEP,SAAS,qBAAqB;AAE9B;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAyEA,MAAM,mBAAmB,IAAI,SAA2D;AAC7F,QAAM,CAAC,SAAS,KAAK,IAAI,qBAAqB,IAAI;AAClD,QAAM,CAAC,SAAS,MAAM,IAAI,uBAAuB,IAAI;AAErD,QAAM,aAAa,kCAAkC,IAAI,iCAAiC,MAAM;AAC9F,UAAM,qBAAqC,WAAW,mBAAmB,YAAU,OAAOA,UAASC,WAAU;AAzIjH;AA2IM,YAAM,iBAAiB,OAAO,WAAW,aAAa,MAAM,OAAOD,QAAO,IAAI;AAE9E,YAAM,UAAU,MAAM,sBAAsB,UAAK;AA7IvD,YAAAE;AA6I0D,gBAAAA,MAAAF,SAAQ,QAAQ,IAAI,IAAI,MAAxB,gBAAAE,IAA2B;AAAA,OAAK;AAEpF,YAAM,iBAAiB;AAAA,QACrB,eAAe,kBAAkB,oBAAmB,mCAAS;AAAA,QAC7D,MAAM,aAAa,gCAAgC;AAAA,MACrD;AAEA,YAAM,YAAY;AAAA,QAAU,eAAe,aAAa,eAAc,mCAAS;AAAA,QAAW,MACxF,aAAa,2BAA2B;AAAA,MAC1C;AACA,YAAM,YAAY,eAAe,aAAa;AAC9C,YAAM,YAAY,eAAe,aAAa;AAE9C,YAAM,UAAU;AAAA,QACd;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA,GAAG;AAAA,MACL;AAGA,sCAAgC,IAAI,eAAe,OAAO;AAC1D,YAAM,sBAAsB,MAAM,YAAY;AAE9C,UAAI,QAAQ,OAAO;AACjB,eAAO,OAAO;AAAA,MAChB;AACA,YAAM,eAAe,mBAAmBF,QAAO;AAC/C,aAAO,MAAM,WAAW,OAAO;AAC/B,aAAO,MAAM,OAAO,MAAM,aAAa,OAAO,CAAC;AAE/C,YAAM,aAAaA,SAAQ,QAAQ,IAAI,UAAU,QAAQ,aAAa;AACtE,UAAI,cAAc,WAAW,WAAW,QAAQ,GAAG;AACjD,eAAO,MAAM,qBAAqB;AAAA,MACpC;AAEA,YAAM,YAAYA,SAAQ,QAAQ,IAAI,UAAU,QAAQ,qBAAqB;AAC7E,UAAI,WAAW;AACb,eAAO,MAAM,oCAAoC,OAAO;AAAA,UACtD,OAAO;AAAA,QACT,EAAE;AAAA,MACJ;AAEA,YAAM,eAAe,MAAM,oBAAoB;AAAA,QAC7C;AAAA,QACA,iCAAiC,cAAc,OAAO;AAAA,MACxD;AAEA,aAAO,MAAM,gBAAgB,OAAO;AAAA,QAClC,QAAQ,aAAa;AAAA,QACrB,SAAS,KAAK,UAAU,OAAO,YAAY,aAAa,OAAO,CAAC;AAAA,QAChE,QAAQ,aAAa;AAAA,MACvB,EAAE;AAEF,YAAM,iBAAiB,aAAa,QAAQ,IAAI,UAAU,QAAQ,QAAQ;AAC1E,UAAI,gBAAgB;AAClB,cAAM,MAAM,aAAa,SAAS,cAAc;AAChD,qBAAa,QAAQ,QAAQ,CAAC,OAAO,QAAQ;AAC3C,cAAI,QAAQ,UAAU,QAAQ,UAAU;AACtC;AAAA,UACF;AACA,cAAI,QAAQ,OAAO,KAAK,KAAK;AAAA,QAC/B,CAAC;AACD,eAAO;AAAA,MACT,WAAW,aAAa,WAAW,WAAW,WAAW;AACvD,cAAM,IAAI,MAAM,0CAA0C;AAAA,MAC5D;AAEA,YAAM,aAAa,aAAa,OAAO;AACvC,aAAO,MAAM,QAAQ,OAAO,EAAE,MAAM,YAAY,OAAO,WAAW,MAAM,EAAE,EAAE;AAE5E,YAAM,mBAAmB,iCAAiC,YAAY;AACtE,YAAM,mBAAmB,iCAAiC,YAAY;AACtE,YAAM,UAAU,MAAM,wBAAwB,cAAc,YAAY,gBAAgB;AAExF,YAAM,cAAc,4BAA4B,cAAc,kBAAkB,gBAAgB;AAChG,kBAAY,UAAU;AAEtB,UAAI,gBAA0B,aAAa,KAAK;AAChD,UAAI;AACF,cAAM,oBAAoB,MAAM,kCAAkC;AAAA,UAChE;AAAA,UACA,YAAY,mCAAU,aAAaA,UAASC;AAAA,QAC9C;AACA,wBAAgB,qBAAqB;AAAA,MACvC,SAAS,GAAQ;AACf,wBAAgB,wBAAwB,GAAG,cAAcD,UAAS,YAAY;AAAA,MAChF;AACA,UAAI,QAAQ,uBAAuB;AACjC,cAAM,EAAE,QAAQ,IAAI;AAAA,YACjB,+BAAoB,cAAc,MAAlC,mBAAqC,gBAArC,YAAoD,IAAI,QAAQ,KAAK,EAAE;AAAA,UACxE,QAAQ;AAAA,QACV;AAEA,gBAAQ,QAAQ,CAAC,CAAC,KAAK,KAAK,MAAM;AAChC,oBAAU,eAAe,KAAK,KAAK;AAAA,QACrC,CAAC;AAED,eAAO,MAAM,uBAAuB,OAAO;AAAA,UACzC;AAAA,QACF,EAAE;AAAA,MACJ;AAIA,UAAI,aAAa,SAAS;AACxB,qBAAa,QAAQ,QAAQ,CAAC,OAAO,QAAQ;AAC3C,cAAI,QAAQ,UAAU,QAAQ,uBAAuB;AACnD,mBAAO,MAAM,oCAAoC,OAAO;AAAA,cACtD;AAAA,YACF,EAAE;AAAA,UACJ;AACA,wBAAc,QAAQ,OAAO,KAAK,KAAK;AAAA,QACzC,CAAC;AAAA,MACH;AAEA,UAAI,WAAW,aAAa,GAAG;AAC7B,eAAO,MAAM,2BAA2B;AACxC,eAAO,uBAAuB,cAAc,eAAe,OAAO;AAAA,MACpE;AAEA,UAAI,QAAQ,OAAO;AACjB,wCAAgC,eAAe,cAAc,EAAE,CAAC,UAAU,QAAQ,WAAW,GAAG,OAAO,CAAC;AAAA,MAC1G;AAEA,YAAM;AAAA;AAAA,QAEJ,eAAc,mCAAS,aACnB;AAAA,UACE,gBAAgB,mCAAS;AAAA,UACzB,WAAW,mCAAS;AAAA,QACtB,IACA,CAAC;AAAA;AAEP;AAAA,QACE;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA,WAAW,cAAc,kBAAkB,OAAO,2BAA2B,UAAU;AAAA,MACzF;AAEA,aAAO;AAAA,IACT,CAAC;AAED,UAAM,oBAAoC,OAAOA,UAASC,WAAU;AAhSxE;AAoSM,UAAI,qBAAqBD,QAAO,GAAG;AACjC,eAAO,0BAA0BA,QAAO;AAAA,MAC1C;AAEA,YAAM,iBAAiB,OAAO,WAAW,aAAa,MAAM,OAAOA,QAAO,IAAI;AAC9E,YAAM,UAAU,MAAM,sBAAsB,UAAK;AAzSvD,YAAAE;AAyS0D,gBAAAA,MAAAF,SAAQ,QAAQ,IAAI,IAAI,MAAxB,gBAAAE,IAA2B;AAAA,OAAK;AAEpF,YAAM,0BAA0B,EAAE,eAAe,kBAAkB,oBAAmB,mCAAS;AAC/F,YAAM,cAAa,qBAAUF,UAAS,UAAU,QAAQ,aAAa,MAAlD,mBAAqD,QAAQ,WAAW,QAAxE,YAA+E;AAKlG,UAAI,2BAA2B,CAAC,uBAAuB,UAAU,GAAG;AAClE,cAAM,MAAM,aAAa,KAAK;AAC9B,wCAAgC,KAAKA,UAAS;AAAA,UAC5C,CAAC,UAAU,QAAQ,UAAU,GAAG;AAAA,QAClC,CAAC;AACD,eAAO;AAAA,MACT;AAEA,aAAO,mBAAmBA,UAASC,MAAK;AAAA,IAC1C;AAEA,UAAM,iBAAiC,OAAOD,UAASC,WAAU;AAC/D,UAAI,eAAe;AACjB,eAAO,kBAAkBD,UAASC,MAAK;AAAA,MACzC;AAEA,aAAO,mBAAmBD,UAASC,MAAK;AAAA,IAC1C;AAIA,QAAI,WAAW,OAAO;AACpB,aAAO,eAAe,SAAS,KAAK;AAAA,IACtC;AAIA,WAAO;AAAA,EACT,CAAC;AAED,SAAO;AACT;AAEA,MAAM,uBAAuB,CAAC,SAAoB;AAChD,SAAO,CAAC,KAAK,CAAC,aAAa,UAAU,KAAK,CAAC,IAAI,QAAW,KAAK,CAAC,aAAa,UAAU,KAAK,CAAC,IAAI,MAAS;AAI5G;AAEA,MAAM,yBAAyB,CAAC,SAAoB;AAClD,SAAO;AAAA,IACL,OAAO,KAAK,CAAC,MAAM,aAAa,KAAK,CAAC,IAAI;AAAA,KACzC,KAAK,WAAW,IAAI,KAAK,CAAC,IAAI,OAAO,KAAK,CAAC,MAAM,aAAa,CAAC,IAAI,KAAK,CAAC,MAAM,CAAC;AAAA,EACnF;AACF;AAEA,MAAM,uBAAuB,CAAC,YAC5B,QAAQ,QAAQ,aAAa;AAE/B,MAAM,4BAA4B,CAAC,YAAwC;AACzE,QAAM,YAAY,QAAQ,QAAQ,aAAa,IAAI,WAAW;AAC9D,QAAM,MAAM,IAAI,IAAI,QAAQ,GAAG;AAC/B,MAAI,WAAW;AAEf,SAAO,aAAa,SAAS,aAAa,IAAI,SAAS,CAAC;AAC1D;AAIO,MAAM,mCAAmC,CAC9C,cACA,YACuC;AACvC,SAAO;AAAA,IACL,GAAG;AAAA,IACH,GAAG,0BAA0B,cAAc,OAAO;AAAA;AAAA;AAAA;AAAA,IAIlD,cAAc;AAAA,EAChB;AACF;AAEA,MAAM,mCAAmC,CACvC,iBACyD;AACzD,SAAO,CAAC,OAAO,CAAC,MAAM;AACpB,UAAM,MAAM,aAAa,SAAS,SAAS;AAC3C,0BAAsB,KAAK,KAAK,aAAa;AAAA,EAC/C;AACF;AAEA,MAAM,mCAAmC,CACvC,iBACyD;AACzD,SAAO,CAAC,OAAO,CAAC,MAAM;AACpB,UAAM,MAAM,aAAa,SAAS,SAAS;AAC3C,0BAAsB,KAAK,KAAK,aAAa;AAAA,EAC/C;AACF;AAEA,MAAM,0BAA0B,CAC9B,cACA,eACA,qBACG;AACH,UAAQ,OAAO,QAAa,YAAiB;AAC3C,UAAM,WAAW,MAAM,eAAe;AAEtC,UAAM,WAAW,CAAC,QAChB,oBAAoB,KAAK;AAAA,MACvB,aAAa;AAAA,IACf,CAAC;AAEH,UAAM,kBAAiB,iCAAQ,WAAS,mCAAS,UAAS,UAAU;AACpE,UAAM,aAAa,8BAA8B,EAAE,YAAY,eAAe,cAAc,eAAe,CAAC;AAE5G,WAAO,cAAc;AAAA,MACnB,SAAS;AAAA,MACT;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF,CAAC,EAAE,QAAQ,OAAO;AAAA,EACpB;AACF;AAOA,MAAM,8BAA8B,CAClC,cACA,kBACA,qBACwB;AACxB,QAAM,cAAc,OAAO,YAA6B;AAlb1D;AAmbI,UAAM,gBAAgB,aAAa,OAAO,EAAE,yBAAyB,mCAAS,wBAAwB,CAAC;AACvG,UAAM,gBAAe,wCAAS,iBAAT,YAAyB,UAAU;AAExD,UAAM,aAAa,8BAA8B;AAAA,MAC/C,YAAY;AAAA,MACZ;AAAA,IACF,CAAC;AAED,QAAI,WAAW,cAAc,UAAU,gBAAgB,oBAAoB,UAAU,cAAc,YAAY,GAAG;AAChH,aAAO,OAAO,OAAO,YAAY;AAAA,QAC/B;AAAA,QACA;AAAA,MACF,CAAC;AAAA,IACH;AAEA,WAAO;AAAA,EACT;AAEA,SAAO;AACT;AASA,MAAM,0BAA0B,CAC9B,GACA,cACA,aACA,iBACa;AApdf;AAqdE,MAAI,0BAA0B,CAAC,GAAG;AAChC,UAAM,WAAW,IAAI,aAAa,MAAM,EAAE,QAAQ,IAAI,CAAC;AAIvD,UAAM,aAAc,aAAyC,OAAO;AACpE,QAAI,cAAc,WAAW,cAAc,UAAU,YAAY;AAI/D,YAAM,iBAAiB,oBAAoB,aAAa,cAAc;AACtE,aAAO;AAAA,QACL;AAAA,QACA;AAAA,QACA,qCAAqC,iDAAgB,WAAW;AAAA,MAClE;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAEA,MAAI,sBAAsB,CAAC,GAAG;AAE5B,WAAO;AAAA;AAAA;AAAA;AAAA,MAIL,aAAa,QAAQ,IAAI,IAAI,UAAU,KAAK,IAAI,CAAC,IAAI,YAAY,GAAG,CAAC;AAAA,MACrE,UAAU,QAAQ;AAAA,MAClB;AAAA,IACF;AAAA,EACF;AAEA,QAAM,qBAAqB,wBAAwB,CAAC;AACpD,QAAM,qBAAqB,wBAAwB,CAAC;AAEpD,MAAI,sBAAsB,oBAAoB;AAC5C,UAAM,WAAW,eAAe;AAAA,MAC9B;AAAA,MACA,SAAS,aAAa;AAAA,MACtB,WAAW,aAAa;AAAA,MACxB,WAAW,aAAa;AAAA,MACxB,gBAAgB,aAAa;AAAA,MAC7B,gBAAe,kBAAa,OAAO,MAApB,mBAAuB;AAAA,IACxC,CAAC;AAED,UAAM,EAAE,cAAc,IAAI;AAC1B,WAAO,SAAS,qBAAqB,qBAAqB,kBAAkB,EAAE,EAAE,cAAc,CAAC;AAAA,EACjG;AAEA,MAAI,sBAAsB,CAAC,GAAG;AAC5B,WAAO,gBAAgB,EAAE,WAAW;AAAA,EACtC;AAEA,QAAM;AACR;","names":["request","event","_a"]}
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/esm/server/fs/middleware-location.js:12:  const suggestionMessage = (extension, to, from) => `Clerk: clerkMiddleware() was not run, your middleware file might be misplaced. Move your middleware file to ./${to}middleware.${extension}. Currently located at ./${from}middleware.${extension}`;
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/esm/server/fs/middleware-location.js.map:1:{"version":3,"sources":["../../../../src/server/fs/middleware-location.ts"],"sourcesContent":["import { nodeCwdOrThrow, nodeFsOrThrow, nodePathOrThrow } from './utils';\n\nfunction hasSrcAppDir() {\n  const { existsSync } = nodeFsOrThrow();\n  const path = nodePathOrThrow();\n  const cwd = nodeCwdOrThrow();\n\n  const projectWithAppSrc = path.join(cwd(), 'src', 'app');\n\n  return !!existsSync(projectWithAppSrc);\n}\n\nfunction suggestMiddlewareLocation() {\n  const fileExtensions = ['ts', 'js'] as const;\n  const suggestionMessage = (\n    extension: (typeof fileExtensions)[number],\n    to: 'src/' | '',\n    from: 'src/app/' | 'app/' | '',\n  ) =>\n    `Clerk: clerkMiddleware() was not run, your middleware file might be misplaced. Move your middleware file to ./${to}middleware.${extension}. Currently located at ./${from}middleware.${extension}`;\n\n  const { existsSync } = nodeFsOrThrow();\n  const path = nodePathOrThrow();\n  const cwd = nodeCwdOrThrow();\n\n  const projectWithAppSrcPath = path.join(cwd(), 'src', 'app');\n  const projectWithAppPath = path.join(cwd(), 'app');\n\n  const checkMiddlewareLocation = (\n    basePath: string,\n    to: 'src/' | '',\n    from: 'src/app/' | 'app/' | '',\n  ): string | undefined => {\n    for (const fileExtension of fileExtensions) {\n      if (existsSync(path.join(basePath, `middleware.${fileExtension}`))) {\n        return suggestionMessage(fileExtension, to, from);\n      }\n    }\n    return undefined;\n  };\n\n  if (existsSync(projectWithAppSrcPath)) {\n    return (\n      checkMiddlewareLocation(projectWithAppSrcPath, 'src/', 'src/app/') || checkMiddlewareLocation(cwd(), 'src/', '')\n    );\n  }\n\n  if (existsSync(projectWithAppPath)) {\n    return checkMiddlewareLocation(projectWithAppPath, '', 'app/');\n  }\n\n  return undefined;\n}\n\nexport { suggestMiddlewareLocation, hasSrcAppDir };\n"],"mappings":";AAAA,SAAS,gBAAgB,eAAe,uBAAuB;AAE/D,SAAS,eAAe;AACtB,QAAM,EAAE,WAAW,IAAI,cAAc;AACrC,QAAM,OAAO,gBAAgB;AAC7B,QAAM,MAAM,eAAe;AAE3B,QAAM,oBAAoB,KAAK,KAAK,IAAI,GAAG,OAAO,KAAK;AAEvD,SAAO,CAAC,CAAC,WAAW,iBAAiB;AACvC;AAEA,SAAS,4BAA4B;AACnC,QAAM,iBAAiB,CAAC,MAAM,IAAI;AAClC,QAAM,oBAAoB,CACxB,WACA,IACA,SAEA,iHAAiH,EAAE,cAAc,SAAS,4BAA4B,IAAI,cAAc,SAAS;AAEnM,QAAM,EAAE,WAAW,IAAI,cAAc;AACrC,QAAM,OAAO,gBAAgB;AAC7B,QAAM,MAAM,eAAe;AAE3B,QAAM,wBAAwB,KAAK,KAAK,IAAI,GAAG,OAAO,KAAK;AAC3D,QAAM,qBAAqB,KAAK,KAAK,IAAI,GAAG,KAAK;AAEjD,QAAM,0BAA0B,CAC9B,UACA,IACA,SACuB;AACvB,eAAW,iBAAiB,gBAAgB;AAC1C,UAAI,WAAW,KAAK,KAAK,UAAU,cAAc,aAAa,EAAE,CAAC,GAAG;AAClE,eAAO,kBAAkB,eAAe,IAAI,IAAI;AAAA,MAClD;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAEA,MAAI,WAAW,qBAAqB,GAAG;AACrC,WACE,wBAAwB,uBAAuB,QAAQ,UAAU,KAAK,wBAAwB,IAAI,GAAG,QAAQ,EAAE;AAAA,EAEnH;AAEA,MAAI,WAAW,kBAAkB,GAAG;AAClC,WAAO,wBAAwB,oBAAoB,IAAI,MAAM;AAAA,EAC/D;AAEA,SAAO;AACT;","names":[]}
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/esm/server/errors.js.map:1:{"version":3,"sources":["../../../src/server/errors.ts"],"sourcesContent":["export const missingDomainAndProxy = `\nMissing domain and proxyUrl. A satellite application needs to specify a domain or a proxyUrl.\n\n1) With middleware\n   e.g. export default clerkMiddleware({domain:'YOUR_DOMAIN',isSatellite:true});\n2) With environment variables e.g.\n   NEXT_PUBLIC_CLERK_DOMAIN='YOUR_DOMAIN'\n   NEXT_PUBLIC_CLERK_IS_SATELLITE='true'\n   `;\n\nexport const missingSignInUrlInDev = `\nInvalid signInUrl. A satellite application requires a signInUrl for development instances.\nCheck if signInUrl is missing from your configuration or if it is not an absolute URL\n\n1) With middleware\n   e.g. export default clerkMiddleware({signInUrl:'SOME_URL', isSatellite:true});\n2) With environment variables e.g.\n   NEXT_PUBLIC_CLERK_SIGN_IN_URL='SOME_URL'\n   NEXT_PUBLIC_CLERK_IS_SATELLITE='true'`;\n\nexport const getAuthAuthHeaderMissing = () => authAuthHeaderMissing('getAuth');\n\nexport const authAuthHeaderMissing = (helperName = 'auth', prefixSteps?: string[]) =>\n  `Clerk: ${helperName}() was called but Clerk can't detect usage of clerkMiddleware(). Please ensure the following:\n- ${prefixSteps ? [...prefixSteps, ''].join('\\n- ') : ' '}clerkMiddleware() is used in your Next.js Middleware.\n- Your Middleware matcher is configured to match this route or page.\n- If you are using the src directory, make sure the Middleware file is inside of it.\n\nFor more details, see https://clerk.com/err/auth-middleware\n`;\n\nexport const authSignatureInvalid = `Clerk: Unable to verify request, this usually means the Clerk middleware did not run. Ensure Clerk's middleware is properly integrated and matches the current route. For more information, see: https://clerk.com/docs/reference/nextjs/clerk-middleware. (code=auth_signature_invalid)`;\n\nexport const encryptionKeyInvalid = `Clerk: Unable to decrypt request data, this usually means the encryption key is invalid. Ensure the encryption key is properly set. For more information, see: https://clerk.com/docs/reference/nextjs/clerk-middleware#dynamic-keys. (code=encryption_key_invalid)`;\n\nexport const encryptionKeyInvalidDev = `Clerk: Unable to decrypt request data.\\n\\nRefresh the page if your .env file was just updated. If the issue persists, ensure the encryption key is valid and properly set.\\n\\nFor more information, see: https://clerk.com/docs/reference/nextjs/clerk-middleware#dynamic-keys. (code=encryption_key_invalid)`;\n"],"mappings":";AAAO,MAAM,wBAAwB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAU9B,MAAM,wBAAwB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAU9B,MAAM,2BAA2B,MAAM,sBAAsB,SAAS;AAEtE,MAAM,wBAAwB,CAAC,aAAa,QAAQ,gBACzD,UAAU,UAAU;AAAA,IAClB,cAAc,CAAC,GAAG,aAAa,EAAE,EAAE,KAAK,MAAM,IAAI,GAAG;AAAA;AAAA;AAAA;AAAA;AAAA;AAOlD,MAAM,uBAAuB;AAE7B,MAAM,uBAAuB;AAE7B,MAAM,0BAA0B;AAAA;AAAA;AAAA;AAAA;","names":[]}
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/types/app-router/server/auth.d.ts:54: * - Requires [`clerkMiddleware()`](https://clerk.com/docs/reference/nextjs/clerk-middleware) to be configured.
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/types/server/clerkMiddleware.d.ts:19: * The `clerkMiddleware()` function accepts an optional object. The following options are available.
node_modules/.pnpm/@clerk+nextjs@6.36.9_next@16.1.4_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2_vg7ou3kvmnpqg4uknuyzgps3wi/node_modules/@clerk/nextjs/dist/types/server/clerkMiddleware.d.ts:40:     * export default clerkMiddleware((auth, request, event) => { ... }, options);
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..23fbb8e377e5f4c495aa20396001d9b81dd66f44
--- a/middleware.ts
+++ b/middleware.ts
@@ -1,23 +1,23 @@
 import { NextResponse } from "next/server";
 import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
 
-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
+const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
 
 const isPublicRoute = createRouteMatcher([
   "/",
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
 
-const clerk = clerkMiddleware((auth, req) => {
+const clerk = clerkMiddleware(async (auth, req) => {
+  const { userId, redirectToSignIn } = await auth();
   if (isPublicRoute(req)) return;
-  return auth().then(({ userId, redirectToSignIn }) => {
-    if (!userId) return redirectToSignIn();
-    return undefined;
-  });
+  if (!userId) return redirectToSignIn();
+  return undefined;
 });
 
 export default clerkEnabled ? clerk : () => NextResponse.next();
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">



thinking
**Moving middleware file**

I'm planning to move the middleware file to `src/middleware.ts`. It’s a significant change, but it seems necessary, especially to enable authentication for US-006 and possibly for US-005. I need to make sure not to change any unrelated code while moving the middleware, since the authentication for saving reports is linked to it. I'll check if `src/middleware.ts` already exists and make adjustments to any relative imports if needed. We’ll also confirm with the Next docs to ensure everything aligns correctly.
thinking
**Applying patch for middleware**

I see that `apply_patch` supports `*** Move to:` which means I can use this to move the file effectively. I need to ensure that any modifications are maintained during the move. I should check if the `src` path has any AGENTS since only the root instructions will apply here. So, I’ll patch it with `*** Update File: middleware.ts` and `*** Move to: src/middleware.ts` and then just apply the patch, as the content is already updated.
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..23fbb8e377e5f4c495aa20396001d9b81dd66f44
--- a/middleware.ts
+++ b/middleware.ts
@@ -1,23 +1,23 @@
 import { NextResponse } from "next/server";
 import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
 
-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
+const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
 
 const isPublicRoute = createRouteMatcher([
   "/",
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
 
-const clerk = clerkMiddleware((auth, req) => {
+const clerk = clerkMiddleware(async (auth, req) => {
+  const { userId, redirectToSignIn } = await auth();
   if (isPublicRoute(req)) return;
-  return auth().then(({ userId, redirectToSignIn }) => {
-    if (!userId) return redirectToSignIn();
-    return undefined;
-  });
+  if (!userId) return redirectToSignIn();
+  return undefined;
 });
 
 export default clerkEnabled ? clerk : () => NextResponse.next();
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">

exec
/bin/zsh -lc 'cat middleware.ts' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 60ms:
import { NextResponse } from "next/server";
import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";

const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);

const isPublicRoute = createRouteMatcher([
  "/",
  "/api/check",
  "/api/analyze",
  "/api/user-settings",
  "/api/saved-reports",
  "/sign-in(.*)",
  "/sign-up(.*)",
]);

const clerk = clerkMiddleware(async (auth, req) => {
  const { userId, redirectToSignIn } = await auth();
  if (isPublicRoute(req)) return;
  if (!userId) return redirectToSignIn();
  return undefined;
file update:
diff --git a/middleware.ts b/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..23fbb8e377e5f4c495aa20396001d9b81dd66f44
--- a/middleware.ts
+++ b/middleware.ts
@@ -1,23 +1,23 @@
 import { NextResponse } from "next/server";
 import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
 
-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
+const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
 
 const isPublicRoute = createRouteMatcher([
   "/",
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
 
-const clerk = clerkMiddleware((auth, req) => {
+const clerk = clerkMiddleware(async (auth, req) => {
+  const { userId, redirectToSignIn } = await auth();
   if (isPublicRoute(req)) return;
-  return auth().then(({ userId, redirectToSignIn }) => {
-    if (!userId) return redirectToSignIn();
-    return undefined;
-  });
+  if (!userId) return redirectToSignIn();
+  return undefined;
 });
 
 export default clerkEnabled ? clerk : () => NextResponse.next();
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">


thinking
**Adjusting code structure**

I’m thinking about moving the code to the `src` folder and checking if `clerkEnabled` should also verify a secret. It seems like we might have already made that change. If I'm moving things around, I can add a small comment to explain the new location. That's not unrelated to my current task; it makes sense. I’ll apply the patch by moving the code and including a comment at the top, along with diff lines.
file update
R /Users/chiko/side_projects/usdt_blacklisted_web/middleware.ts -> /Users/chiko/side_projects/usdt_blacklisted_web/src/middleware.ts
@@ -3,2 +3,3 @@
 
+// Note: when using `src/app`, Next expects middleware under `src/` as well.
 const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
apply_patch(auto_approved=true) exited 0 in 117ms:
Success. Updated the following files:
M src/middleware.ts
file update:
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
diff --git a/middleware.ts b/src/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..078996501b70d8cda7ce43e7ec365481c2b6d808
--- a/middleware.ts
+++ b/src/middleware.ts
@@ -1,23 +1,24 @@
 import { NextResponse } from "next/server";
 import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
 
-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
+// Note: when using `src/app`, Next expects middleware under `src/` as well.
+const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
 
 const isPublicRoute = createRouteMatcher([
   "/",
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
 
-const clerk = clerkMiddleware((auth, req) => {
+const clerk = clerkMiddleware(async (auth, req) => {
+  const { userId, redirectToSignIn } = await auth();
   if (isPublicRoute(req)) return;
-  return auth().then(({ userId, redirectToSignIn }) => {
-    if (!userId) return redirectToSignIn();
-    return undefined;
-  });
+  if (!userId) return redirectToSignIn();
+  return undefined;
 });
 
 export default clerkEnabled ? clerk : () => NextResponse.next();

file update:
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
diff --git a/middleware.ts b/src/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..078996501b70d8cda7ce43e7ec365481c2b6d808
--- a/middleware.ts
+++ b/src/middleware.ts
@@ -1,23 +1,24 @@
 import { NextResponse } from "next/server";
 import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
 
-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
+// Note: when using `src/app`, Next expects middleware under `src/` as well.
+const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
 
 const isPublicRoute = createRouteMatcher([
   "/",
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
 
-const clerk = clerkMiddleware((auth, req) => {
+const clerk = clerkMiddleware(async (auth, req) => {
+  const { userId, redirectToSignIn } = await auth();
   if (isPublicRoute(req)) return;
-  return auth().then(({ userId, redirectToSignIn }) => {
-    if (!userId) return redirectToSignIn();
-    return undefined;
-  });
+  if (!userId) return redirectToSignIn();
+  return undefined;
 });
 
 export default clerkEnabled ? clerk : () => NextResponse.next();


thinking
**Clarifying middleware movement**

Okay, I’m thinking that the root middleware.ts should be moved, but the apply_patch output shows `M src/middleware.ts`, indicating it’s been moved instead of deleted. So, it seems like middleware.ts now exists in the src directory, which means the root might be removed. I’ll check the details by running `ls -la middleware.ts src/middleware.ts` to confirm everything's in order.
exec
/bin/zsh -lc 'ls -la middleware.ts src/middleware.ts || true' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 76ms:
-rw-r--r--@ 1 chiko  staff  801 Jan 23 14:17 src/middleware.ts
ls: middleware.ts: No such file or directory
file update:
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
diff --git a/middleware.ts b/src/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..078996501b70d8cda7ce43e7ec365481c2b6d808
--- a/middleware.ts
+++ b/src/middleware.ts
@@ -1,23 +1,24 @@
 import { NextResponse } from "next/server";
 import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
 
-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
+// Note: when using `src/app`, Next expects middleware under `src/` as well.
+const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
 
 const isPublicRoute = createRouteMatcher([
   "/",
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
 
-const clerk = clerkMiddleware((auth, req) => {
+const clerk = clerkMiddleware(async (auth, req) => {
+  const { userId, redirectToSignIn } = await auth();
   if (isPublicRoute(req)) return;
-  return auth().then(({ userId, redirectToSignIn }) => {
-    if (!userId) return redirectToSignIn();
-    return undefined;
-  });
+  if (!userId) return redirectToSignIn();
+  return undefined;
 });
 
 export default clerkEnabled ? clerk : () => NextResponse.next();

exec
/bin/zsh -lc 'set -euo pipefail
PID=$(lsof -t -iTCP:3000 -sTCP:LISTEN || true)
if [ -n "${PID:-}" ]; then
  kill "$PID" || true
  sleep 1
fi
NEXT_LOG="/tmp/usdt_blacklisted_web_next_dev.log"
DB_URL="postgres://postgres@localhost:54329/postgres"
ADDRESS_HASH_KEY="dev_hash_key"
set -a
source .env
set +a
(DATABASE_URL="$DB_URL" ADDRESS_HASH_KEY="$ADDRESS_HASH_KEY" pnpm dev >"$NEXT_LOG" 2>&1 &)
for i in {1..30}; do
  if lsof -iTCP:3000 -sTCP:LISTEN >/dev/null 2>&1; then break; fi
  sleep 1
done
curl -s -o /dev/null -D - http://localhost:3000/settings | sed -n '"'1,12p'
" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 2.32s:
HTTP/1.1 307 Temporary Redirect
Content-Security-Policy: default-src 'self'; base-uri 'self'; form-action 'self'; frame-ancestors 'none'; object-src 'none'; script-src 'self' 'unsafe-inline' https://*.clerk.accounts.dev 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data: blob: https:; font-src 'self' data:; connect-src 'self' https://*.clerk.accounts.dev https://api.clerk.com; frame-src 'self' https://*.clerk.accounts.dev; worker-src 'self' blob:
Referrer-Policy: strict-origin-when-cross-origin
X-Frame-Options: DENY
X-Content-Type-Options: nosniff
Permissions-Policy: camera=(), microphone=(), geolocation=(), payment=()
Cross-Origin-Opener-Policy: same-origin
Cross-Origin-Resource-Policy: same-site
location: /sign-in?redirect_url=http%3A%2F%2Flocalhost%3A3000%2Fsettings
x-clerk-auth-reason: dev-browser-missing
x-clerk-auth-status: signed-out
x-clerk-redirect-to: true
file update:
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
diff --git a/middleware.ts b/src/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..078996501b70d8cda7ce43e7ec365481c2b6d808
--- a/middleware.ts
+++ b/src/middleware.ts
@@ -1,23 +1,24 @@
 import { NextResponse } from "next/server";
 import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
 
-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
+// Note: when using `src/app`, Next expects middleware under `src/` as well.
+const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
 
 const isPublicRoute = createRouteMatcher([
   "/",
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
 
-const clerk = clerkMiddleware((auth, req) => {
+const clerk = clerkMiddleware(async (auth, req) => {
+  const { userId, redirectToSignIn } = await auth();
   if (isPublicRoute(req)) return;
-  return auth().then(({ userId, redirectToSignIn }) => {
-    if (!userId) return redirectToSignIn();
-    return undefined;
-  });
+  if (!userId) return redirectToSignIn();
+  return undefined;
 });
 
 export default clerkEnabled ? clerk : () => NextResponse.next();

exec
/bin/zsh -lc "cd /Users/chiko/.codex/skills/dev-browser && npx tsx <<'EOF'
import { connect } from \"@/client.js\";

const client = await connect();
const page = await client.page(\"usdt-save-report\");

await page.goto(\"http://localhost:3000/\");
await page.waitForTimeout(1000);

const userSettings = await page.evaluate(async () => {
  const res = await fetch('/api/user-settings', { credentials: 'include' });
  const json = await res.json().catch(() => null);
  return { status: res.status, json };
});

const analyze = await page.evaluate(async () => {
  const res = await fetch('/api/analyze', {
    method: 'POST',
    headers: { 'content-type': 'application/json', 'user-agent': 'dev-browser' },
    credentials: 'include',
    body: JSON.stringify({ address: 'T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb' }),
  });
  const json = await res.json().catch(() => null);
  return { status: res.status, authenticated: json?.access?.authenticated };
});

console.log({ userSettings, analyze });
await client.disconnect();
EOF" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 5.33s:
{
  userSettings: {
    status: 200,
    json: { loggingEnabled: false, persistenceAvailable: true }
  },
  analyze: { status: 200, authenticated: true }
}
(node:75151) ExperimentalWarning: CommonJS module /Users/chiko/.nvm/versions/node/v23.3.0/lib/node_modules/npm/node_modules/debug/src/node.js is loading ES Module /Users/chiko/.nvm/versions/node/v23.3.0/lib/node_modules/npm/node_modules/supports-color/index.js using require().
Support for loading ES Module in require() is an experimental feature and might change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
file update:
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
diff --git a/middleware.ts b/src/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..078996501b70d8cda7ce43e7ec365481c2b6d808
--- a/middleware.ts
+++ b/src/middleware.ts
@@ -1,23 +1,24 @@
 import { NextResponse } from "next/server";
 import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
 
-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
+// Note: when using `src/app`, Next expects middleware under `src/` as well.
+const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
 
 const isPublicRoute = createRouteMatcher([
   "/",
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
 
-const clerk = clerkMiddleware((auth, req) => {
+const clerk = clerkMiddleware(async (auth, req) => {
+  const { userId, redirectToSignIn } = await auth();
   if (isPublicRoute(req)) return;
-  return auth().then(({ userId, redirectToSignIn }) => {
-    if (!userId) return redirectToSignIn();
-    return undefined;
-  });
+  if (!userId) return redirectToSignIn();
+  return undefined;
 });
 
 export default clerkEnabled ? clerk : () => NextResponse.next();

exec
/bin/zsh -lc "cd /Users/chiko/.codex/skills/dev-browser && npx tsx <<'EOF'
import { connect, waitForPageLoad } from \"@/client.js\";

const client = await connect();
const page = await client.page(\"usdt-save-report\");

// Ensure home loaded.
await page.goto(\"http://localhost:3000/\");
await waitForPageLoad(page);

const address = \"T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb\";

// Run analysis (logging disabled initially).
await page.getByRole(\"textbox\").first().fill(address);
await page.getByRole(\"button\", { name: /check/i }).click();
await page.waitForTimeout(2000);

const saveVisibleBefore = (await page.getByText(\"Save this report\").count()) > 0;

// Enable logging in settings.
await page.goto(\"http://localhost:3000/settings\");
await waitForPageLoad(page);

const toggle = page.getByRole(\"switch\", { name: \"Save screening history\" });
await toggle.waitFor({ timeout: 30_000 });
const beforeChecked = await toggle.getAttribute(\"aria-checked\");
if (beforeChecked "'!== "true") {
  await toggle.click();
  // Wait for request to settle.
  await page.waitForTimeout(1200);
}
const afterChecked = await toggle.getAttribute("aria-checked");

// Back to home and re-run analysis.
await page.goto("http://localhost:3000/");
await waitForPageLoad(page);
await page.getByRole("textbox").first().fill(address);
await page.getByRole("button", { name: /check/i }).click();

await page.getByText("Save this report").waitFor({ timeout: 60_000 });
const saveVisibleAfter = (await page.getByText("Save this report").count()) > 0;

await page.getByRole("button", { name: /''^save$/i }).click();
await page.getByText("Report saved.").waitFor({ timeout: 60_000 });
await page.getByRole("button", { name: /saved/i }).waitFor({ timeout: 60_000 });

await page.screenshot({ path: "tmp/usdt-save-report-flow.png", fullPage: true });
console.log(JSON.stringify({ saveVisibleBefore, beforeChecked, afterChecked, saveVisibleAfter }, null, 2));

await client.disconnect();
EOF' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 8.61s:
{
  "saveVisibleBefore": false,
  "beforeChecked": "false",
  "afterChecked": "true",
  "saveVisibleAfter": true
}
(node:75448) ExperimentalWarning: CommonJS module /Users/chiko/.nvm/versions/node/v23.3.0/lib/node_modules/npm/node_modules/debug/src/node.js is loading ES Module /Users/chiko/.nvm/versions/node/v23.3.0/lib/node_modules/npm/node_modules/supports-color/index.js using require().
Support for loading ES Module in require() is an experimental feature and might change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
file update:
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
diff --git a/middleware.ts b/src/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..078996501b70d8cda7ce43e7ec365481c2b6d808
--- a/middleware.ts
+++ b/src/middleware.ts
@@ -1,23 +1,24 @@
 import { NextResponse } from "next/server";
 import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
 
-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
+// Note: when using `src/app`, Next expects middleware under `src/` as well.
+const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
 
 const isPublicRoute = createRouteMatcher([
   "/",
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
 
-const clerk = clerkMiddleware((auth, req) => {
+const clerk = clerkMiddleware(async (auth, req) => {
+  const { userId, redirectToSignIn } = await auth();
   if (isPublicRoute(req)) return;
-  return auth().then(({ userId, redirectToSignIn }) => {
-    if (!userId) return redirectToSignIn();
-    return undefined;
-  });
+  if (!userId) return redirectToSignIn();
+  return undefined;
 });
 
 export default clerkEnabled ? clerk : () => NextResponse.next();

viewed image /Users/chiko/.codex/skills/dev-browser/tmp/usdt-save-report-flow.png
file update:
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
diff --git a/middleware.ts b/src/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..078996501b70d8cda7ce43e7ec365481c2b6d808
--- a/middleware.ts
+++ b/src/middleware.ts
@@ -1,23 +1,24 @@
 import { NextResponse } from "next/server";
 import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
 
-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
+// Note: when using `src/app`, Next expects middleware under `src/` as well.
+const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
 
 const isPublicRoute = createRouteMatcher([
   "/",
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
 
-const clerk = clerkMiddleware((auth, req) => {
+const clerk = clerkMiddleware(async (auth, req) => {
+  const { userId, redirectToSignIn } = await auth();
   if (isPublicRoute(req)) return;
-  return auth().then(({ userId, redirectToSignIn }) => {
-    if (!userId) return redirectToSignIn();
-    return undefined;
-  });
+  if (!userId) return redirectToSignIn();
+  return undefined;
 });
 
 export default clerkEnabled ? clerk : () => NextResponse.next();

exec
/bin/zsh -lc './ralph log "Browser verification passed: Save control hidden when loggingEnabled=false; enabling setting shows Save, clicking saves and shows toast"' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 82ms:

file update:
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
diff --git a/middleware.ts b/src/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..078996501b70d8cda7ce43e7ec365481c2b6d808
--- a/middleware.ts
+++ b/src/middleware.ts
@@ -1,23 +1,24 @@
 import { NextResponse } from "next/server";
 import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
 
-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
+// Note: when using `src/app`, Next expects middleware under `src/` as well.
+const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
 
 const isPublicRoute = createRouteMatcher([
   "/",
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
 
-const clerk = clerkMiddleware((auth, req) => {
+const clerk = clerkMiddleware(async (auth, req) => {
+  const { userId, redirectToSignIn } = await auth();
   if (isPublicRoute(req)) return;
-  return auth().then(({ userId, redirectToSignIn }) => {
-    if (!userId) return redirectToSignIn();
-    return undefined;
-  });
+  if (!userId) return redirectToSignIn();
+  return undefined;
 });
 
 export default clerkEnabled ? clerk : () => NextResponse.next();

Plan update
  ✓ Review guardrails and logs
  ✓ Audit existing auth/logging/report code
  ✓ Implement save-report API route
  ✓ Add UI save control and toast
  ✓ Add tests for save flow
  ✓ Run lint, test, build
  ✓ Browser-verify save control
  → Security/perf/regression review, commit, log progress
file update:
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
diff --git a/middleware.ts b/src/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..078996501b70d8cda7ce43e7ec365481c2b6d808
--- a/middleware.ts
+++ b/src/middleware.ts
@@ -1,23 +1,24 @@
 import { NextResponse } from "next/server";
 import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
 
-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
+// Note: when using `src/app`, Next expects middleware under `src/` as well.
+const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
 
 const isPublicRoute = createRouteMatcher([
   "/",
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
 
-const clerk = clerkMiddleware((auth, req) => {
+const clerk = clerkMiddleware(async (auth, req) => {
+  const { userId, redirectToSignIn } = await auth();
   if (isPublicRoute(req)) return;
-  return auth().then(({ userId, redirectToSignIn }) => {
-    if (!userId) return redirectToSignIn();
-    return undefined;
-  });
+  if (!userId) return redirectToSignIn();
+  return undefined;
 });
 
 export default clerkEnabled ? clerk : () => NextResponse.next();

exec
/bin/zsh -lc "set -euo pipefail
# Security/perf/regression quick checks via grep + typescript build already done.
rg -n \"console\\.log\\(|console\\.debug\\(|console\\.info\\(\" src/app/api/saved-reports src/components/blacklist-checker.tsx || true

# Ensure route is in correct place and no leftover old middleware
test -f src/middleware.ts

# Re-run focused tests after middleware move
pnpm test -- --run src/__tests__/api-saved-reports.test.ts" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 898ms:

> usdt_blacklisted_web@0.1.0 test /Users/chiko/side_projects/usdt_blacklisted_web
> vitest run "--run" "src/__tests__/api-saved-reports.test.ts"


[1m[46m RUN [49m[22m [36mv4.0.17 [39m[90m/Users/chiko/side_projects/usdt_blacklisted_web[39m

 [32m✓[39m src/__tests__/api-saved-reports.test.ts [2m([22m[2m5 tests[22m[2m)[22m[32m 99[2mms[22m[39m

[2m Test Files [22m [1m[32m1 passed[39m[22m[90m (1)[39m
[2m      Tests [22m [1m[32m5 passed[39m[22m[90m (5)[39m
[2m   Start at [22m 14:18:52
[2m   Duration [22m 211ms[2m (transform 51ms, setup 0ms, import 26ms, tests 99ms, environment 0ms)[22m

(node:76059) ExperimentalWarning: CommonJS module /Users/chiko/side_projects/usdt_blacklisted_web/node_modules/.pnpm/vitest@4.0.17_@types+node@20.19.30_jiti@2.6.1_lightningcss@1.30.2/node_modules/vitest/dist/config.cjs is loading ES Module /Users/chiko/side_projects/usdt_blacklisted_web/node_modules/.pnpm/vite@7.3.1_@types+node@20.19.30_jiti@2.6.1_lightningcss@1.30.2/node_modules/vite/dist/node/index.js using require().
Support for loading ES Module in require() is an experimental feature and might change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
file update:
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
diff --git a/middleware.ts b/src/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..078996501b70d8cda7ce43e7ec365481c2b6d808
--- a/middleware.ts
+++ b/src/middleware.ts
@@ -1,23 +1,24 @@
 import { NextResponse } from "next/server";
 import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
 
-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
+// Note: when using `src/app`, Next expects middleware under `src/` as well.
+const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
 
 const isPublicRoute = createRouteMatcher([
   "/",
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
 
-const clerk = clerkMiddleware((auth, req) => {
+const clerk = clerkMiddleware(async (auth, req) => {
+  const { userId, redirectToSignIn } = await auth();
   if (isPublicRoute(req)) return;
-  return auth().then(({ userId, redirectToSignIn }) => {
-    if (!userId) return redirectToSignIn();
-    return undefined;
-  });
+  if (!userId) return redirectToSignIn();
+  return undefined;
 });
 
 export default clerkEnabled ? clerk : () => NextResponse.next();

exec
/bin/zsh -lc "sed -n '1,200p' /Users/chiko/.codex/skills/commit/SKILL.md" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 57ms:
---
name: commit
description: Write conventional commit messages with type, scope, and subject when the user wants to commit changes or save work.
---

# Git Commit

Creates git commits following Conventional Commits format with proper type, scope, and subject.

## Quick Start

```bash
# 1. Stage changes
git add <files>  # or: git add -A

# 2. Create commit (branch commit format)
git commit -m "type(scope): subject

Body explaining HOW and WHY.
Reference: Task X.Y, Req N"
file update:
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
diff --git a/middleware.ts b/src/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..078996501b70d8cda7ce43e7ec365481c2b6d808
--- a/middleware.ts
+++ b/src/middleware.ts
@@ -1,23 +1,24 @@
 import { NextResponse } from "next/server";
 import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
 
-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
+// Note: when using `src/app`, Next expects middleware under `src/` as well.
+const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
 
 const isPublicRoute = createRouteMatcher([
   "/",
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
 
-const clerk = clerkMiddleware((auth, req) => {
+const clerk = clerkMiddleware(async (auth, req) => {
+  const { userId, redirectToSignIn } = await auth();
   if (isPublicRoute(req)) return;
-  return auth().then(({ userId, redirectToSignIn }) => {
-    if (!userId) return redirectToSignIn();
-    return undefined;
-  });
+  if (!userId) return redirectToSignIn();
+  return undefined;
 });
 
 export default clerkEnabled ? clerk : () => NextResponse.next();

exec
/bin/zsh -lc 'git status --porcelain' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 68ms:
 M .agents/tasks/prd-post-mvp.json
 M .ralph/activity.log
 D middleware.ts
 M src/components/blacklist-checker.tsx
?? .ralph/.tmp/prompt-20260123-135210-55147-1.md
?? .ralph/.tmp/story-20260123-135210-55147-1.json
?? .ralph/.tmp/story-20260123-135210-55147-1.md
?? .ralph/runs/run-20260123-135210-55147-iter-1.log
?? src/__tests__/api-saved-reports.test.ts
?? src/app/api/saved-reports/
?? src/middleware.ts
exec
/bin/zsh -lc 'git diff --stat' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 82ms:
 .agents/tasks/prd-post-mvp.json      |   7 ++-
 .ralph/activity.log                  |   9 +++
 middleware.ts                        |  27 ---------
 src/components/blacklist-checker.tsx | 108 +++++++++++++++++++++++++++++++++++
 4 files changed, 122 insertions(+), 29 deletions(-)
exec
/bin/zsh -lc 'git diff' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 50ms:
diff --git a/.agents/tasks/prd-post-mvp.json b/.agents/tasks/prd-post-mvp.json
index 928c963..cc689a0 100644
--- a/.agents/tasks/prd-post-mvp.json
+++ b/.agents/tasks/prd-post-mvp.json
@@ -230,7 +230,7 @@
     {
       "id": "US-006",
       "title": "[P2] Add Save Report flow (UI + API) gated by loggingEnabled",
-      "status": "open",
+      "status": "in_progress",
       "dependsOn": [
         "US-005"
       ],
@@ -242,7 +242,10 @@
         "Update the main analysis UI to show a `Save this report` control only when authenticated and loggingEnabled is enabled.",
         "Example: After running analysis, clicking Save creates a History entry and shows a success toast/state.",
         "Negative case: If loggingEnabled is false, Save is hidden/disabled and the API returns a clear error if called directly."
-      ]
+      ],
+      "startedAt": "2026-01-23T13:52:10.763173+00:00",
file update:
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
diff --git a/middleware.ts b/src/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..078996501b70d8cda7ce43e7ec365481c2b6d808
--- a/middleware.ts
+++ b/src/middleware.ts
@@ -1,23 +1,24 @@
 import { NextResponse } from "next/server";
 import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
 
-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
+// Note: when using `src/app`, Next expects middleware under `src/` as well.
+const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
 
 const isPublicRoute = createRouteMatcher([
   "/",
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
 
-const clerk = clerkMiddleware((auth, req) => {
+const clerk = clerkMiddleware(async (auth, req) => {
+  const { userId, redirectToSignIn } = await auth();
   if (isPublicRoute(req)) return;
-  return auth().then(({ userId, redirectToSignIn }) => {
-    if (!userId) return redirectToSignIn();
-    return undefined;
-  });
+  if (!userId) return redirectToSignIn();
+  return undefined;
 });
 
 export default clerkEnabled ? clerk : () => NextResponse.next();






thinking
**Revisiting file modifications**

I need to address the modifications made to the .agents/tasks/prd-post-mvp.json file. The instructions clearly state that we should not edit the PRD JSON status managed by the loop. It seems like harness could be the reason for these changes, but as an agent, I shouldn't commit this file. I'll have to revert it to its original state and discard any changes. I also need to consider whether .ralph temp files should be excluded from commits. This is tricky!
thinking
**Clarifying file commit instructions**

The instruction not to edit prd-post-mvp.json is clear and non-negotiable. I need to restore it to the git HEAD version. Now, regarding .ralph/runs/run-...log, it seems like a run log path that might need to be committed since the instructions mention committing updates to progress/logs. However, I need to check which parts are untracked and whether .ralph/runs should be ignored according to .gitignore. I'll inspect that and ensure I'm following the instructions consistently. Plus, I have to remember about the test user and cookies created in the dev-browser.
thinking
**Confirming middleware and API changes**

I moved middleware.ts to src/middleware.ts, which represents a behavior change to help the save UI gating function properly. This should fit within the story titled "Add Save Report flow gated by loggingEnabled." The middleware fix is crucial for authentication to work in the development environment since the story requires authenticated gating. 

Additionally, there's a new API route in src/app/api/saved-reports/route.ts. I must ensure that the UI fetching /api/user-settings doesn’t expose addresses, and I need to confirm that reportJson, which will include the necessary fields like riskScore and riskTier, is stored properly. The API should return a clear error, like a 403, if loggingEnabled is false, and I’ll validate the payload using zod.
thinking
**Ensuring Save control functionality**

I'm working on creating a History entry as a SavedReport row. To ensure the Save control functions properly, it should only be available when the user is authenticated and loggingEnabled is active. We check report.access.authenticated from the analyze response, which now works thanks to the middleware adjustment.

However, if the settings fetch fails, the Save control won't show up, which meets the requirement. I’m considering if we should display a disabled state with a message saying "Enable in settings," but the acceptance criteria indicate it should remain hidden. I’ll also need to adjust our tests because of the middleware move and rerun the full quality gates, including lint and build tests, to comply.
thinking
**Planning next steps for commits**

I see we need to rerun some processes because we changed the middleware, route, and test environment. Once that's done, I’ll commit changes using conventional commit skills, but I need to ensure I don’t include forbidden files like .agents/tasks/prd-post-mvp.json, which should revert to clean. I’ll check .gitignore to see if any .ralph files should remain untracked.

Additionally, I’ll have to consider whether to commit the untracked .ralph/runs logs, as they may be necessary for tracking runs, considering the progress entry requires them. It's essential to keep a clean working tree post-commit, so I might need to delete unneeded files or commit what’s necessary. Let's inspect the directory and .gitignore to make an informed choice.
exec
/bin/zsh -lc 'cat .gitignore' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 66ms:
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
exec
/bin/zsh -lc "ls -la .ralph && find .ralph -maxdepth 2 -type f | sed -n '1,200p'" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 54ms:
total 56
drwxr-xr-x@  8 chiko  staff   256 Jan 23 06:01 .
drwxr-xr-x@ 36 chiko  staff  1152 Jan 23 14:17 ..
drwxr-xr-x@ 27 chiko  staff   864 Jan 23 13:52 .tmp
-rw-r--r--@  1 chiko  staff  5372 Jan 23 14:18 activity.log
-rw-r--r--@  1 chiko  staff   782 Jan 23 05:48 errors.log
-rw-r--r--@  1 chiko  staff   769 Jan 23 13:47 guardrails.md
-rw-r--r--@  1 chiko  staff  9142 Jan 23 06:04 progress.md
drwxr-xr-x@ 12 chiko  staff   384 Jan 23 13:52 runs
.ralph/guardrails.md
.ralph/progress.md
.ralph/activity.log
.ralph/.tmp/story-20260123-043424-92605-1.json
.ralph/.tmp/story-20260123-135210-55147-1.json
.ralph/.tmp/prompt-20260123-044356-6274-1.md
.ralph/.tmp/story-20260123-043424-92605-1.md
.ralph/.tmp/prompt-20260123-044356-6274-5.md
.ralph/.tmp/prompt-20260123-044356-6274-4.md
.ralph/.tmp/story-20260123-044356-6274-1.json
.ralph/.tmp/prd-prompt-20260123-043736-96875.md
exec
/bin/zsh -lc "git ls-files .ralph | sed -n '1,200p'" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 78ms:
.ralph/.tmp/prd-prompt-20260123-042148-75244.md
.ralph/.tmp/prd-prompt-20260123-043736-96875.md
.ralph/.tmp/prompt-20260123-044356-6274-1.md
.ralph/.tmp/prompt-20260123-044356-6274-3.md
.ralph/.tmp/prompt-20260123-044356-6274-4.md
.ralph/.tmp/prompt-20260123-044356-6274-5.md
.ralph/.tmp/story-20260123-042526-80680-1.json
.ralph/.tmp/story-20260123-042526-80680-1.md
.ralph/.tmp/story-20260123-042600-81451-1.json
.ralph/.tmp/story-20260123-042600-81451-1.md
.ralph/.tmp/story-20260123-043424-92605-1.json
.ralph/.tmp/story-20260123-043424-92605-1.md
.ralph/.tmp/story-20260123-043705-96152-1.json
.ralph/.tmp/story-20260123-043705-96152-1.md
.ralph/.tmp/story-20260123-044356-6274-1.json
.ralph/.tmp/story-20260123-044356-6274-1.md
.ralph/.tmp/story-20260123-044356-6274-3.json
.ralph/.tmp/story-20260123-044356-6274-3.md
.ralph/.tmp/story-20260123-044356-6274-4.json
.ralph/.tmp/story-20260123-044356-6274-4.md
file update:
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
diff --git a/middleware.ts b/src/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..078996501b70d8cda7ce43e7ec365481c2b6d808
--- a/middleware.ts
+++ b/src/middleware.ts
@@ -1,23 +1,24 @@
 import { NextResponse } from "next/server";
 import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
 
-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
+// Note: when using `src/app`, Next expects middleware under `src/` as well.
+const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
 
 const isPublicRoute = createRouteMatcher([
   "/",
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
 
-const clerk = clerkMiddleware((auth, req) => {
+const clerk = clerkMiddleware(async (auth, req) => {
+  const { userId, redirectToSignIn } = await auth();
   if (isPublicRoute(req)) return;
-  return auth().then(({ userId, redirectToSignIn }) => {
-    if (!userId) return redirectToSignIn();
-    return undefined;
-  });
+  if (!userId) return redirectToSignIn();
+  return undefined;
 });
 
 export default clerkEnabled ? clerk : () => NextResponse.next();


thinking
**Verifying code modifications**

I'm checking the changes in `middleware.ts` since its location has moved; it will be included in the upcoming commit. The `src/middleware.ts` file is new. I noticed that the previous `git diff --stat` didn't account for the new API route or tests since they were untracked, but this will be addressed after the commit. I should revert `.agents/tasks/prd-post-mvp.json` and confirm the previous content before running `git status`.
exec
/bin/zsh -lc 'git checkout -- .agents/tasks/prd-post-mvp.json' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 82ms:

file update:
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
diff --git a/middleware.ts b/src/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..078996501b70d8cda7ce43e7ec365481c2b6d808
--- a/middleware.ts
+++ b/src/middleware.ts
@@ -1,23 +1,24 @@
 import { NextResponse } from "next/server";
 import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
 
-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
+// Note: when using `src/app`, Next expects middleware under `src/` as well.
+const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
 
 const isPublicRoute = createRouteMatcher([
   "/",
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
 
-const clerk = clerkMiddleware((auth, req) => {
+const clerk = clerkMiddleware(async (auth, req) => {
+  const { userId, redirectToSignIn } = await auth();
   if (isPublicRoute(req)) return;
-  return auth().then(({ userId, redirectToSignIn }) => {
-    if (!userId) return redirectToSignIn();
-    return undefined;
-  });
+  if (!userId) return redirectToSignIn();
+  return undefined;
 });
 
 export default clerkEnabled ? clerk : () => NextResponse.next();

exec
/bin/zsh -lc 'git status --porcelain' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 69ms:
 M .ralph/activity.log
 D middleware.ts
 M src/components/blacklist-checker.tsx
?? .ralph/.tmp/prompt-20260123-135210-55147-1.md
?? .ralph/.tmp/story-20260123-135210-55147-1.json
?? .ralph/.tmp/story-20260123-135210-55147-1.md
?? .ralph/runs/run-20260123-135210-55147-iter-1.log
?? src/__tests__/api-saved-reports.test.ts
?? src/app/api/saved-reports/
?? src/middleware.ts
file update:
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
diff --git a/middleware.ts b/src/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..078996501b70d8cda7ce43e7ec365481c2b6d808
--- a/middleware.ts
+++ b/src/middleware.ts
@@ -1,23 +1,24 @@
 import { NextResponse } from "next/server";
 import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
 
-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
+// Note: when using `src/app`, Next expects middleware under `src/` as well.
+const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
 
 const isPublicRoute = createRouteMatcher([
   "/",
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
 
-const clerk = clerkMiddleware((auth, req) => {
+const clerk = clerkMiddleware(async (auth, req) => {
+  const { userId, redirectToSignIn } = await auth();
   if (isPublicRoute(req)) return;
-  return auth().then(({ userId, redirectToSignIn }) => {
-    if (!userId) return redirectToSignIn();
-    return undefined;
-  });
+  if (!userId) return redirectToSignIn();
+  return undefined;
 });
 
 export default clerkEnabled ? clerk : () => NextResponse.next();


thinking
**Running build checks**

Okay, I need to run lint, test, and build again. Since we changed the middleware, it might impact the build. Even though this is step 8 of my plan and we're at the last step, it's essential to follow the instructions about quality gates before committing. So, I’ll run the commands: `pnpm lint`, `pnpm test`, and `pnpm build` to ensure everything is in good shape. Better to be safe!
exec
/bin/zsh -lc 'pnpm lint' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 3.02s:

> usdt_blacklisted_web@0.1.0 lint /Users/chiko/side_projects/usdt_blacklisted_web
> eslint

exec
/bin/zsh -lc 'pnpm test' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 1.15s:

> usdt_blacklisted_web@0.1.0 test /Users/chiko/side_projects/usdt_blacklisted_web
> vitest run


[1m[46m RUN [49m[22m [36mv4.0.17 [39m[90m/Users/chiko/side_projects/usdt_blacklisted_web[39m

 [32m✓[39m src/lib/aml.test.ts [2m([22m[2m7 tests[22m[2m)[22m[32m 5[2mms[22m[39m
 [32m✓[39m src/lib/sanctions.test.ts [2m([22m[2m2 tests[22m[2m)[22m[32m 7[2mms[22m[39m
 [32m✓[39m src/__tests__/api-user-settings.test.ts [2m([22m[2m4 tests[22m[2m)[22m[32m 127[2mms[22m[39m
 [32m✓[39m src/__tests__/api-saved-reports.test.ts [2m([22m[2m5 tests[22m[2m)[22m[32m 158[2mms[22m[39m
 [32m✓[39m src/__tests__/api-analyze.test.ts [2m([22m[2m2 tests[22m[2m)[22m[32m 195[2mms[22m[39m
 [32m✓[39m src/lib/db/address-hash.test.ts [2m([22m[2m4 tests[22m[2m)[22m[32m 6[2mms[22m[39m
 [32m✓[39m src/lib/exposure.test.ts [2m([22m[2m1 test[22m[2m)[22m[32m 3[2mms[22m[39m
 [32m✓[39m src/lib/heuristics.test.ts [2m([22m[2m3 tests[22m[2m)[22m[32m 2[2mms[22m[39m
 [32m✓[39m src/lib/db/index.test.ts [2m([22m[2m1 test[22m[2m)[22m[33m 319[2mms[22m[39m
     [33m[2m✓[22m[39m returns null when DATABASE_URL is missing [33m 318[2mms[22m[39m
 [32m✓[39m src/lib/db/scoped-queries.test.ts [2m([22m[2m4 tests[22m[2m)[22m[32m 5[2mms[22m[39m
 [32m✓[39m src/lib/entity.test.ts [2m([22m[2m2 tests[22m[2m)[22m[32m 2[2mms[22m[39m

exec
/bin/zsh -lc 'pnpm build' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 8.16s:

> usdt_blacklisted_web@0.1.0 build /Users/chiko/side_projects/usdt_blacklisted_web
> next build

▲ Next.js 16.1.4 (Turbopack)
- Environments: .env

  Creating an optimized production build ...
✓ Compiled successfully in 3.7s
  Running TypeScript ...
  Collecting page data using 7 workers ...
  Generating static pages using 7 workers (0/9) ...
  Generating static pages using 7 workers (2/9) 
  Generating static pages using 7 workers (4/9) 
  Generating static pages using 7 workers (6/9) 
✓ Generating static pages using 7 workers (9/9) in 170.1ms
  Finalizing page optimization ...

Route (app)
┌ ○ /
file update:
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
diff --git a/middleware.ts b/src/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..078996501b70d8cda7ce43e7ec365481c2b6d808
--- a/middleware.ts
+++ b/src/middleware.ts
@@ -1,23 +1,24 @@
 import { NextResponse } from "next/server";
 import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
 
-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
+// Note: when using `src/app`, Next expects middleware under `src/` as well.
+const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
 
 const isPublicRoute = createRouteMatcher([
   "/",
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
 
-const clerk = clerkMiddleware((auth, req) => {
+const clerk = clerkMiddleware(async (auth, req) => {
+  const { userId, redirectToSignIn } = await auth();
   if (isPublicRoute(req)) return;
-  return auth().then(({ userId, redirectToSignIn }) => {
-    if (!userId) return redirectToSignIn();
-    return undefined;
-  });
+  if (!userId) return redirectToSignIn();
+  return undefined;
 });
 
 export default clerkEnabled ? clerk : () => NextResponse.next();

exec
/bin/zsh -lc './ralph log "Re-ran pnpm lint/test/build after middleware move (PASS)"' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 60ms:

file update:
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
diff --git a/middleware.ts b/src/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..078996501b70d8cda7ce43e7ec365481c2b6d808
--- a/middleware.ts
+++ b/src/middleware.ts
@@ -1,23 +1,24 @@
 import { NextResponse } from "next/server";
 import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
 
-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
+// Note: when using `src/app`, Next expects middleware under `src/` as well.
+const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
 
 const isPublicRoute = createRouteMatcher([
   "/",
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
 
-const clerk = clerkMiddleware((auth, req) => {
+const clerk = clerkMiddleware(async (auth, req) => {
+  const { userId, redirectToSignIn } = await auth();
   if (isPublicRoute(req)) return;
-  return auth().then(({ userId, redirectToSignIn }) => {
-    if (!userId) return redirectToSignIn();
-    return undefined;
-  });
+  if (!userId) return redirectToSignIn();
+  return undefined;
 });
 
 export default clerkEnabled ? clerk : () => NextResponse.next();






thinking
**Analyzing log management**

I'm considering how to handle the run log. One idea is to sanitize it by removing secret occurrences before committing, but that could be more work and still risky. The safest option seems to be not committing logs that contain secrets at all. However, that would lead to an unclean working tree unless I remove the untracked files. I'm wondering if the harness requires the run log to exist but doesn't need it to be committed, which could simplify things.
thinking
**Checking run logs and summaries**

It seems like only the run log exists right now, and I should check if there's a `.ralph/runs/run...md` file for the run summary. It doesn’t seem to be in git status, which suggests it might be generated later. I can keep the untracked run log and ignore it for a clean commit. Ignoring `.ralph/runs/run-*.log` and some `.ralph/.tmp/*` files could help with that, but since some of the temp files are tracked, I’m not sure if that will completely solve the cleanliness issue.
thinking
**Considering file management options**

I’m thinking about whether it's simpler to just delete untracked files to keep my tree clean instead of modifying `.gitignore`. I could remove `.ralph/.tmp` files generated during the run as well as `.ralph/runs/run-...log`. But I'm questioning if that's acceptable since the progress entry references those logs. They might not need to persist in git, but they could be useful for debugging. If I delete them, I lose that record, yet we shouldn't keep logs with secrets. Keeping them locally might be alright, though.
thinking
**Reviewing file management requirements**

I’m considering that the run logs might be stored under `.ralph/runs`, which is in the repo, and could be shared. However, it seems like the requirement is that all changes made during the run should be committed, especially for files like `.ralph/progress.md` and `.ralph/activity.log`, while the untracked run logs and temp files can potentially be deleted without needing to commit. This situation could get ambiguous, but it seems I'd rather delete those untracked files and ensure that the necessary progress files are modified and committed. Let's check on the `.ralph/.tmp` files and see if they're ignored by git.
thinking
**Evaluating run log management**

I’m looking into the `.ralph/.tmp` files and realized they’re tracked, so they can’t be ignored. Deleting these untracked files seems fine because it won’t affect anything else. For the `.ralph/runs/run-...log`, I see that older logs are tracked but the new logs are untracked, which is a bit odd. Those might have been committed earlier, but this new log contains secrets from the output of `cat .env`. I think I can sanitize it by redacting sensitive keys, ensuring I replace any confidential information with placeholders. Let's use a search to find those keys in the log.
exec
/bin/zsh -lc 'rg -n "CLERK_SECRET_KEY|NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY|sk_test|pk_test" .ralph/runs/run-20260123-135210-55147-iter-1.log || true' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 75ms:
432:  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
446:const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
593:  if (process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY) {
597:515:  const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
868:  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
1018:+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
1165:+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
1315:+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
1476:+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
1645:+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
1942:+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
2215:+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
2491:+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
2776:+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
3076:+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
3308:  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
3309:  process.env.CLERK_SECRET_KEY = "sk_test_123";
3437:+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
3438:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
3574:+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
exec
/bin/zsh -lc 'rg -n "CLERK_SECRET_KEY|sk_test|pk_test" .ralph/.tmp/prompt-20260123-135210-55147-1.md .ralph/.tmp/story-20260123-135210-55147-1.json .ralph/.tmp/story-20260123-135210-55147-1.md || true' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 74ms:

exec
/bin/zsh -lc 'ls -la .ralph/runs | tail -n 20' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 61ms:
total 17952
drwxr-xr-x@ 12 chiko  staff      384 Jan 23 13:52 .
drwxr-xr-x@  8 chiko  staff      256 Jan 23 06:01 ..
-rw-r--r--@  1 chiko  staff   508765 Jan 23 04:55 run-20260123-044356-6274-iter-1.log
-rw-r--r--@  1 chiko  staff     1739 Jan 23 04:55 run-20260123-044356-6274-iter-1.md
-rw-r--r--@  1 chiko  staff  1910349 Jan 23 05:11 run-20260123-044356-6274-iter-2.log
-rw-r--r--@  1 chiko  staff     1315 Jan 23 05:11 run-20260123-044356-6274-iter-2.md
-rw-r--r--@  1 chiko  staff  1082739 Jan 23 05:30 run-20260123-044356-6274-iter-3.log
-rw-r--r--@  1 chiko  staff     1589 Jan 23 05:30 run-20260123-044356-6274-iter-3.md
-rw-r--r--@  1 chiko  staff   982016 Jan 23 05:48 run-20260123-044356-6274-iter-4.log
-rw-r--r--@  1 chiko  staff     1361 Jan 23 05:48 run-20260123-044356-6274-iter-4.md
-rw-r--r--@  1 chiko  staff  1367852 Jan 23 13:47 run-20260123-044356-6274-iter-5.log
-rw-r--r--@  1 chiko  staff  1672650 Jan 23 14:21 run-20260123-135210-55147-iter-1.log
file update:
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
diff --git a/middleware.ts b/src/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..078996501b70d8cda7ce43e7ec365481c2b6d808
--- a/middleware.ts
+++ b/src/middleware.ts
@@ -1,23 +1,24 @@
 import { NextResponse } from "next/server";
 import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
 
-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
+// Note: when using `src/app`, Next expects middleware under `src/` as well.
+const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
 
 const isPublicRoute = createRouteMatcher([
   "/",
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
 
-const clerk = clerkMiddleware((auth, req) => {
+const clerk = clerkMiddleware(async (auth, req) => {
+  const { userId, redirectToSignIn } = await auth();
   if (isPublicRoute(req)) return;
-  return auth().then(({ userId, redirectToSignIn }) => {
-    if (!userId) return redirectToSignIn();
-    return undefined;
-  });
+  if (!userId) return redirectToSignIn();
+  return undefined;
 });
 
 export default clerkEnabled ? clerk : () => NextResponse.next();





thinking
**Considering commit risks**

I’m debating whether to commit changes since they're currently untracked. We could delete to clean the tree, but the run log might need to persist in `.ralph/runs`. There’s a risk due to containing publishable keys and secrets like `DATABASE_URL`, but I believe it’s safe since we didn’t set it in `.env`. CLERK keys may be redacted, and the `.ralph/.tmp/prompt` files could contain secrets, but a quick check showed no matches for sensitive info. So, we could commit or delete those `.tmp` files.
thinking
**Deciding on file tracking**

I’m looking at some files that are currently untracked but might be important. I think they likely don’t contain sensitive data, but just to be cautious, I could keep them while ignoring them for now. These files are used by ralph, and previous ones were committed, but I’m weighing whether they truly need to be part of the commit. The instructions say all changes during the run must be committed, so I’ll sanitize the run log for any sensitive keys first. Even though it’s large at 1.6MB, it aligns with previous logs. I still need to create a run summary `.md` file too.
thinking
**Checking run summary creation**

I'm exploring whether a run summary can be created since it's currently untracked. First, I'll check if the file `.ralph/runs/run-...md` exists for this run, but it seems to be missing. The progress template mentions a run summary, which we could create ourselves, even though we’re not supposed to use placeholders. The instructions suggest referencing it, but don't explicitly require its creation. I’ll see if there are existing `.md` files for earlier runs because that might indicate the harness typically makes them post-completion.
thinking
**Considering run summary creation**

I’m thinking about whether to create the run summary now or at the end. Although it's not explicitly requested, I feel it might be expected, especially since I need to reference it in the progress entry. I'd prefer to create the summary after we're done to maintain consistency. However, instructions mention the run summary path and log path, suggesting it might be necessary. I should check an earlier run summary file, like `.ralph/runs/run-20260123-044356-6274-iter-4.md`, to see the format and emulate it.
exec
/bin/zsh -lc "sed -n '1,200p' .ralph/runs/run-20260123-044356-6274-iter-4.md" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 55ms:
# Ralph Run Summary

- Run ID: 20260123-044356-6274
- Iteration: 4
- Mode: build
- Story: US-004: [P2] Add API: user settings (loggingEnabled) with safe defaults
- Started: 2026-01-23 05:30:26
- Ended: 2026-01-23 05:48:31
- Duration: 1085s
- Status: success
- Log: /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-044356-6274-iter-4.log

## Git
- Head (before): 495144bcf72c90ba23b7b075a6253e54f0e4532b
- Head (after): e3f187b427a915f64a29c43387ff3b36e5415634

### Commits
- e3f187b chore(ralph): record final US-004 verification
- b8e2231 fix(ui): keep logging toggle local-only
- cedf236 chore(ralph): update US-004 progress log
file update:
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
diff --git a/middleware.ts b/src/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..078996501b70d8cda7ce43e7ec365481c2b6d808
--- a/middleware.ts
+++ b/src/middleware.ts
@@ -1,23 +1,24 @@
 import { NextResponse } from "next/server";
 import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
 
-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
+// Note: when using `src/app`, Next expects middleware under `src/` as well.
+const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
 
 const isPublicRoute = createRouteMatcher([
   "/",
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
 
-const clerk = clerkMiddleware((auth, req) => {
+const clerk = clerkMiddleware(async (auth, req) => {
+  const { userId, redirectToSignIn } = await auth();
   if (isPublicRoute(req)) return;
-  return auth().then(({ userId, redirectToSignIn }) => {
-    if (!userId) return redirectToSignIn();
-    return undefined;
-  });
+  if (!userId) return redirectToSignIn();
+  return undefined;
 });
 
 export default clerkEnabled ? clerk : () => NextResponse.next();

exec
/bin/zsh -lc "sed -n '7788,7812p' .ralph/runs/run-20260123-135210-55147-iter-1.log" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 66ms:
ADDRESS_HASH_KEY=
# Optional: retention cap for saved reports (default: unlimited)
REPORT_RETENTION_DAYS=
# Optional: cap saved reports per user (default: unlimited)
MAX_REPORTS_PER_USER=
exec
/bin/zsh -lc "cat .env | sed -n '1,120p'" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 58ms:
TRONGRID_API_KEY=
NEXT_PUBLIC_SITE_URL=https://usdt.chikocorp.com

# Clerk (auth)
NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
CLERK_SECRET_KEY=<redacted>
NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
NEXT_PUBLIC_CLERK_SIGN_UP_URL=/sign-up
NEXT_PUBLIC_CLERK_AFTER_SIGN_IN_URL=/
NEXT_PUBLIC_CLERK_AFTER_SIGN_UP_URL=/


# Database (future: opt-in report saving + credits)
file update:
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
diff --git a/middleware.ts b/src/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..078996501b70d8cda7ce43e7ec365481c2b6d808
--- a/middleware.ts
+++ b/src/middleware.ts
@@ -1,23 +1,24 @@
 import { NextResponse } from "next/server";
 import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
 
-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
+// Note: when using `src/app`, Next expects middleware under `src/` as well.
+const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
 
 const isPublicRoute = createRouteMatcher([
   "/",
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
 
-const clerk = clerkMiddleware((auth, req) => {
+const clerk = clerkMiddleware(async (auth, req) => {
+  const { userId, redirectToSignIn } = await auth();
   if (isPublicRoute(req)) return;
-  return auth().then(({ userId, redirectToSignIn }) => {
-    if (!userId) return redirectToSignIn();
-    return undefined;
-  });
+  if (!userId) return redirectToSignIn();
+  return undefined;
 });
 
 export default clerkEnabled ? clerk : () => NextResponse.next();



thinking
**Redacting sensitive data**

I'm working on a plan to redact sensitive information by replacing key values in the run log file. If the secret starts with `pk_test_` or `sk_test_`, I’ll replace it with `<redacted>`. I need to ensure I maintain the context while editing only specific lines. The `apply_patch` tool should be suitable for this, even with a large file, as long as I limit the changes to a narrow block. Additionally, I'll consider redacting `DATABASE_URL` if it's blank.
thinking
**Avoiding sensitive information leaks**

I need to ensure we don’t commit any `.env` contents in the future. It’s already done, but I’ll note that any secrets should be redacted in the progress log. The log file will stay untracked after I edit it with `apply_patch`, but I can commit it later. I also considered checking older logs for secrets, but that may not be necessary. I’ll check the `.ralph/.tmp/prompt` file for safety, but it seems fine, so we can go ahead and patch the run log.
file update
M /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-135210-55147-iter-1.log
@@ -7798,4 +7798,4 @@
 # Clerk (auth)
-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
-CLERK_SECRET_KEY=<redacted>
+NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+CLERK_SECRET_KEY=<redacted>
 NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
                                                                                    apply_patch(auto_approved=true) exited 0 in 72ms:
Success. Updated the following files:
M .ralph/runs/run-20260123-135210-55147-iter-1.log
file update:
diff --git a/.ralph/runs/run-20260123-135210-55147-iter-1.log b/.ralph/runs/run-20260123-135210-55147-iter-1.log
index ad4c4c1a37085a0cbd6f501aebc6fd931f8fa83c..fd591bb7283ace1b8f8af92e2899bbc866e576a9
--- a/.ralph/runs/run-20260123-135210-55147-iter-1.log
+++ b/.ralph/runs/run-20260123-135210-55147-iter-1.log
@@ -7796,8 +7796,8 @@
 NEXT_PUBLIC_SITE_URL=https://usdt.chikocorp.com
 
 # Clerk (auth)
-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
-CLERK_SECRET_KEY=<redacted>
+NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+CLERK_SECRET_KEY=<redacted>
 NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
 NEXT_PUBLIC_CLERK_SIGN_UP_URL=/sign-up
 NEXT_PUBLIC_CLERK_AFTER_SIGN_IN_URL=/
@@ -41897,3 +41897,12 @@
 **Avoiding sensitive information leaks**
 
 I need to ensure we don’t commit any `.env` contents in the future. It’s already done, but I’ll note that any secrets should be redacted in the progress log. The log file will stay untracked after I edit it with `apply_patch`, but I can commit it later. I also considered checking older logs for secrets, but that may not be necessary. I’ll check the `.ralph/.tmp/prompt` file for safety, but it seems fine, so we can go ahead and patch the run log.
+file update
+M /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-135210-55147-iter-1.log
+@@ -7798,4 +7798,4 @@
+ # Clerk (auth)
+-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+-CLERK_SECRET_KEY=<redacted>
++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++CLERK_SECRET_KEY=<redacted>
+ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
diff --git a/middleware.ts b/src/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..078996501b70d8cda7ce43e7ec365481c2b6d808
--- a/middleware.ts
+++ b/src/middleware.ts
@@ -1,23 +1,24 @@
 import { NextResponse } from "next/server";
 import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
 
-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
+// Note: when using `src/app`, Next expects middleware under `src/` as well.
+const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
 
 const isPublicRoute = createRouteMatcher([
   "/",
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
 
-const clerk = clerkMiddleware((auth, req) => {
+const clerk = clerkMiddleware(async (auth, req) => {
+  const { userId, redirectToSignIn } = await auth();
   if (isPublicRoute(req)) return;
-  return auth().then(({ userId, redirectToSignIn }) => {
-    if (!userId) return redirectToSignIn();
-    return undefined;
-  });
+  if (!userId) return redirectToSignIn();
+  return undefined;
 });
 
 export default clerkEnabled ? clerk : () => NextResponse.next();

file update:
diff --git a/.ralph/runs/run-20260123-135210-55147-iter-1.log b/.ralph/runs/run-20260123-135210-55147-iter-1.log
index ad4c4c1a37085a0cbd6f501aebc6fd931f8fa83c..8ff13182c69ae44725abb1e2976f05d93f4e63a2
--- a/.ralph/runs/run-20260123-135210-55147-iter-1.log
+++ b/.ralph/runs/run-20260123-135210-55147-iter-1.log
@@ -7796,8 +7796,8 @@
 NEXT_PUBLIC_SITE_URL=https://usdt.chikocorp.com
 
 # Clerk (auth)
-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
-CLERK_SECRET_KEY=<redacted>
+NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+CLERK_SECRET_KEY=<redacted>
 NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
 NEXT_PUBLIC_CLERK_SIGN_UP_URL=/sign-up
 NEXT_PUBLIC_CLERK_AFTER_SIGN_IN_URL=/
@@ -41897,3 +41897,228 @@
 **Avoiding sensitive information leaks**
 
 I need to ensure we don’t commit any `.env` contents in the future. It’s already done, but I’ll note that any secrets should be redacted in the progress log. The log file will stay untracked after I edit it with `apply_patch`, but I can commit it later. I also considered checking older logs for secrets, but that may not be necessary. I’ll check the `.ralph/.tmp/prompt` file for safety, but it seems fine, so we can go ahead and patch the run log.
+file update
+M /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-135210-55147-iter-1.log
+@@ -7798,4 +7798,4 @@
+ # Clerk (auth)
+-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+-CLERK_SECRET_KEY=<redacted>
++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++CLERK_SECRET_KEY=<redacted>
+ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
+                                                                                    apply_patch(auto_approved=true) exited 0 in 72ms:
+Success. Updated the following files:
+M .ralph/runs/run-20260123-135210-55147-iter-1.log
+file update:
+diff --git a/.ralph/runs/run-20260123-135210-55147-iter-1.log b/.ralph/runs/run-20260123-135210-55147-iter-1.log
+index ad4c4c1a37085a0cbd6f501aebc6fd931f8fa83c..fd591bb7283ace1b8f8af92e2899bbc866e576a9
+--- a/.ralph/runs/run-20260123-135210-55147-iter-1.log
++++ b/.ralph/runs/run-20260123-135210-55147-iter-1.log
+@@ -7796,8 +7796,8 @@
+ NEXT_PUBLIC_SITE_URL=https://usdt.chikocorp.com
+ 
+ # Clerk (auth)
+-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+-CLERK_SECRET_KEY=<redacted>
++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++CLERK_SECRET_KEY=<redacted>
+ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
+ NEXT_PUBLIC_CLERK_SIGN_UP_URL=/sign-up
+ NEXT_PUBLIC_CLERK_AFTER_SIGN_IN_URL=/
+@@ -41897,3 +41897,12 @@
+ **Avoiding sensitive information leaks**
+ 
+ I need to ensure we don’t commit any `.env` contents in the future. It’s already done, but I’ll note that any secrets should be redacted in the progress log. The log file will stay untracked after I edit it with `apply_patch`, but I can commit it later. I also considered checking older logs for secrets, but that may not be necessary. I’ll check the `.ralph/.tmp/prompt` file for safety, but it seems fine, so we can go ahead and patch the run log.
++file update
++M /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-135210-55147-iter-1.log
++@@ -7798,4 +7798,4 @@
++ # Clerk (auth)
++-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++-CLERK_SECRET_KEY=<redacted>
+++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+++CLERK_SECRET_KEY=<redacted>
++ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
+diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
+new file mode 100644
+index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
+--- /dev/null
++++ b/src/__tests__/api-saved-reports.test.ts
+@@ -0,0 +1,107 @@
++import { beforeEach, describe, expect, it, vi } from "vitest";
++
++const auth = vi.fn();
++vi.mock("@clerk/nextjs/server", () => ({ auth }));
++
++const getDb = vi.fn();
++vi.mock("@/lib/db", () => ({ getDb }));
++
++const getUserSettings = vi.fn();
++vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
++
++const createSavedReport = vi.fn();
++vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
++
++const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
++
++async function callPost(body: unknown) {
++  const { POST } = await import("@/app/api/saved-reports/route");
++  const req = new Request("http://localhost/api/saved-reports", {
++    method: "POST",
++    headers: { "content-type": "application/json" },
++    body: JSON.stringify(body),
++  });
++  const res = await POST(req);
++  const json = await res.json().catch(() => null);
++  return { res, json };
++}
++
++beforeEach(() => {
++  vi.resetModules();
++  vi.clearAllMocks();
++  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
++  process.env.CLERK_SECRET_KEY = "sk_test_123";
++  process.env.ADDRESS_HASH_KEY = "test_hash_key";
++});
++
++describe("/api/saved-reports", () => {
++  it("returns 401 when unauthenticated and does not touch the DB", async () => {
++    auth.mockResolvedValue({ userId: null });
++
++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
++    expect(res.status).toBe(401);
++    expect(getDb).not.toHaveBeenCalled();
++    expect(getUserSettings).not.toHaveBeenCalled();
++    expect(createSavedReport).not.toHaveBeenCalled();
++  });
++
++  it("returns 503 when persistence is disabled", async () => {
++    auth.mockResolvedValue({ userId: "user_123" });
++    getDb.mockReturnValue(null);
++
++    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
++    expect(res.status).toBe(503);
++    expect(json?.error).toBeTypeOf("string");
++    expect(getUserSettings).not.toHaveBeenCalled();
++    expect(createSavedReport).not.toHaveBeenCalled();
++  });
++
++  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
++    auth.mockResolvedValue({ userId: "user_123" });
++    getDb.mockReturnValue({});
++    getUserSettings.mockResolvedValue({ loggingEnabled: false });
++
++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
++    expect(res.status).toBe(403);
++    expect(createSavedReport).not.toHaveBeenCalled();
++  });
++
++  it("validates payload and rejects mismatched report addresses", async () => {
++    auth.mockResolvedValue({ userId: "user_123" });
++    getDb.mockReturnValue({});
++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
++
++    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
++    const { res } = await callPost({ address: VALID_ADDRESS, report });
++    expect(res.status).toBe(400);
++    expect(createSavedReport).not.toHaveBeenCalled();
++  });
++
++  it("creates a SavedReport and returns its id", async () => {
++    auth.mockResolvedValue({ userId: "user_123" });
++    getDb.mockReturnValue({});
++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
++    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
++
++    const report = {
++      address: VALID_ADDRESS,
++      risk: { score: 55.2, tier: "high", confidence: 91.7 },
++      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
++    };
++
++    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
++    expect(res.status).toBe(200);
++    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
++    expect(createSavedReport).toHaveBeenCalledWith(
++      {},
++      "user_123",
++      expect.objectContaining({
++        address: VALID_ADDRESS,
++        riskScore: 55,
++        riskTier: "high",
++        confidence: 92,
++        window: { lookbackDays: 90 },
++      }),
++    );
++  });
++});
+diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
+new file mode 100644
+index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
+--- /dev/null
++++ b/src/app/api/saved-reports/route.ts
+@@ -0,0 +1,130 @@
++import { NextResponse } from "next/server";
++import { auth } from "@clerk/nextjs/server";
++import { z } from "zod";
++
++import { getDb } from "@/lib/db";
++import { createSavedReport } from "@/lib/db/saved-reports";
++import { getUserSettings } from "@/lib/db/user-settings";
++import { TronAddressSchema } from "@/lib/validators";
++
++export const runtime = "nodejs";
++
++const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
++
++const SaveReportBodySchema = z.object({
++  address: TronAddressSchema,
++  report: z.unknown(),
++});
++
++const AnalyzeReportSchema = z
++  .object({
++    address: TronAddressSchema,
++    risk: z.object({
++      score: z.number(),
++      tier: RiskTierSchema,
++      confidence: z.number(),
++    }),
++    checks: z
++      .object({
++        exposure1hop: z.unknown().optional(),
++        tracing2hop: z.unknown().optional(),
++      })
++      .passthrough()
++      .optional(),
++  })
++  .passthrough();
++
++function clampInt(n: number, min: number, max: number) {
++  return Math.max(min, Math.min(max, Math.round(n)));
++}
++
++function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
++  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
++  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
++    return exposure.window;
++  }
++
++  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
++  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
++    return tracing.window;
++  }
++
++  return { lookbackDays: 90 };
++}
++
++async function getAuthenticatedUserId(): Promise<string | null> {
++  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
++  try {
++    const { userId } = await auth();
++    return userId ?? null;
++  } catch {
++    return null;
++  }
++}
++
++export async functi
\ No newline at end of file
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
diff --git a/middleware.ts b/src/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..078996501b70d8cda7ce43e7ec365481c2b6d808
--- a/middleware.ts
+++ b/src/middleware.ts
@@ -1,23 +1,24 @@
 import { NextResponse } from "next/server";
 import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
 
-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
+// Note: when using `src/app`, Next expects middleware under `src/` as well.
+const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
 
 const isPublicRoute = createRouteMatcher([
   "/",
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
 
-const clerk = clerkMiddleware((auth, req) => {
+const clerk = clerkMiddleware(async (auth, req) => {
+  const { userId, redirectToSignIn } = await auth();
   if (isPublicRoute(req)) return;
-  return auth().then(({ userId, redirectToSignIn }) => {
-    if (!userId) return redirectToSignIn();
-    return undefined;
-  });
+  if (!userId) return redirectToSignIn();
+  return undefined;
 });
 
 export default clerkEnabled ? clerk : () => NextResponse.next();

exec
/bin/zsh -lc 'rg -n "sk_test_|pk_test_a25v|CLERK_SECRET_KEY=sk_test|NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=pk_test" .ralph/runs/run-20260123-135210-55147-iter-1.log || true' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 76ms:
3309:  process.env.CLERK_SECRET_KEY = "sk_test_123";
3438:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
3824:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
4213:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
4608:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
5008:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
5405:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
5813:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
6221:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
6610:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
7005:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
7413:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
7860:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
8256:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
8669:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
9077:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
9478:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
9867:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
10213:   process.env.CLERK_SECRET_KEY = "sk_test_123";
10273:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
file update:
diff --git a/.ralph/runs/run-20260123-135210-55147-iter-1.log b/.ralph/runs/run-20260123-135210-55147-iter-1.log
index ad4c4c1a37085a0cbd6f501aebc6fd931f8fa83c..952216517f94d24bb59a56b3c137f57854ac883d
--- a/.ralph/runs/run-20260123-135210-55147-iter-1.log
+++ b/.ralph/runs/run-20260123-135210-55147-iter-1.log
@@ -7796,8 +7796,8 @@
 NEXT_PUBLIC_SITE_URL=https://usdt.chikocorp.com
 
 # Clerk (auth)
-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
-CLERK_SECRET_KEY=<redacted>
+NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+CLERK_SECRET_KEY=<redacted>
 NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
 NEXT_PUBLIC_CLERK_SIGN_UP_URL=/sign-up
 NEXT_PUBLIC_CLERK_AFTER_SIGN_IN_URL=/
@@ -41897,3 +41897,1134 @@
 **Avoiding sensitive information leaks**
 
 I need to ensure we don’t commit any `.env` contents in the future. It’s already done, but I’ll note that any secrets should be redacted in the progress log. The log file will stay untracked after I edit it with `apply_patch`, but I can commit it later. I also considered checking older logs for secrets, but that may not be necessary. I’ll check the `.ralph/.tmp/prompt` file for safety, but it seems fine, so we can go ahead and patch the run log.
+file update
+M /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-135210-55147-iter-1.log
+@@ -7798,4 +7798,4 @@
+ # Clerk (auth)
+-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+-CLERK_SECRET_KEY=<redacted>
++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++CLERK_SECRET_KEY=<redacted>
+ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
+                                                                                    apply_patch(auto_approved=true) exited 0 in 72ms:
+Success. Updated the following files:
+M .ralph/runs/run-20260123-135210-55147-iter-1.log
+file update:
+diff --git a/.ralph/runs/run-20260123-135210-55147-iter-1.log b/.ralph/runs/run-20260123-135210-55147-iter-1.log
+index ad4c4c1a37085a0cbd6f501aebc6fd931f8fa83c..fd591bb7283ace1b8f8af92e2899bbc866e576a9
+--- a/.ralph/runs/run-20260123-135210-55147-iter-1.log
++++ b/.ralph/runs/run-20260123-135210-55147-iter-1.log
+@@ -7796,8 +7796,8 @@
+ NEXT_PUBLIC_SITE_URL=https://usdt.chikocorp.com
+ 
+ # Clerk (auth)
+-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+-CLERK_SECRET_KEY=<redacted>
++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++CLERK_SECRET_KEY=<redacted>
+ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
+ NEXT_PUBLIC_CLERK_SIGN_UP_URL=/sign-up
+ NEXT_PUBLIC_CLERK_AFTER_SIGN_IN_URL=/
+@@ -41897,3 +41897,12 @@
+ **Avoiding sensitive information leaks**
+ 
+ I need to ensure we don’t commit any `.env` contents in the future. It’s already done, but I’ll note that any secrets should be redacted in the progress log. The log file will stay untracked after I edit it with `apply_patch`, but I can commit it later. I also considered checking older logs for secrets, but that may not be necessary. I’ll check the `.ralph/.tmp/prompt` file for safety, but it seems fine, so we can go ahead and patch the run log.
++file update
++M /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-135210-55147-iter-1.log
++@@ -7798,4 +7798,4 @@
++ # Clerk (auth)
++-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++-CLERK_SECRET_KEY=<redacted>
+++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+++CLERK_SECRET_KEY=<redacted>
++ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
+diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
+new file mode 100644
+index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
+--- /dev/null
++++ b/src/__tests__/api-saved-reports.test.ts
+@@ -0,0 +1,107 @@
++import { beforeEach, describe, expect, it, vi } from "vitest";
++
++const auth = vi.fn();
++vi.mock("@clerk/nextjs/server", () => ({ auth }));
++
++const getDb = vi.fn();
++vi.mock("@/lib/db", () => ({ getDb }));
++
++const getUserSettings = vi.fn();
++vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
++
++const createSavedReport = vi.fn();
++vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
++
++const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
++
++async function callPost(body: unknown) {
++  const { POST } = await import("@/app/api/saved-reports/route");
++  const req = new Request("http://localhost/api/saved-reports", {
++    method: "POST",
++    headers: { "content-type": "application/json" },
++    body: JSON.stringify(body),
++  });
++  const res = await POST(req);
++  const json = await res.json().catch(() => null);
++  return { res, json };
++}
++
++beforeEach(() => {
++  vi.resetModules();
++  vi.clearAllMocks();
++  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
++  process.env.CLERK_SECRET_KEY = "sk_test_123";
++  process.env.ADDRESS_HASH_KEY = "test_hash_key";
++});
++
++describe("/api/saved-reports", () => {
++  it("returns 401 when unauthenticated and does not touch the DB", async () => {
++    auth.mockResolvedValue({ userId: null });
++
++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
++    expect(res.status).toBe(401);
++    expect(getDb).not.toHaveBeenCalled();
++    expect(getUserSettings).not.toHaveBeenCalled();
++    expect(createSavedReport).not.toHaveBeenCalled();
++  });
++
++  it("returns 503 when persistence is disabled", async () => {
++    auth.mockResolvedValue({ userId: "user_123" });
++    getDb.mockReturnValue(null);
++
++    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
++    expect(res.status).toBe(503);
++    expect(json?.error).toBeTypeOf("string");
++    expect(getUserSettings).not.toHaveBeenCalled();
++    expect(createSavedReport).not.toHaveBeenCalled();
++  });
++
++  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
++    auth.mockResolvedValue({ userId: "user_123" });
++    getDb.mockReturnValue({});
++    getUserSettings.mockResolvedValue({ loggingEnabled: false });
++
++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
++    expect(res.status).toBe(403);
++    expect(createSavedReport).not.toHaveBeenCalled();
++  });
++
++  it("validates payload and rejects mismatched report addresses", async () => {
++    auth.mockResolvedValue({ userId: "user_123" });
++    getDb.mockReturnValue({});
++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
++
++    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
++    const { res } = await callPost({ address: VALID_ADDRESS, report });
++    expect(res.status).toBe(400);
++    expect(createSavedReport).not.toHaveBeenCalled();
++  });
++
++  it("creates a SavedReport and returns its id", async () => {
++    auth.mockResolvedValue({ userId: "user_123" });
++    getDb.mockReturnValue({});
++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
++    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
++
++    const report = {
++      address: VALID_ADDRESS,
++      risk: { score: 55.2, tier: "high", confidence: 91.7 },
++      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
++    };
++
++    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
++    expect(res.status).toBe(200);
++    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
++    expect(createSavedReport).toHaveBeenCalledWith(
++      {},
++      "user_123",
++      expect.objectContaining({
++        address: VALID_ADDRESS,
++        riskScore: 55,
++        riskTier: "high",
++        confidence: 92,
++        window: { lookbackDays: 90 },
++      }),
++    );
++  });
++});
+diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
+new file mode 100644
+index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
+--- /dev/null
++++ b/src/app/api/saved-reports/route.ts
+@@ -0,0 +1,130 @@
++import { NextResponse } from "next/server";
++import { auth } from "@clerk/nextjs/server";
++import { z } from "zod";
++
++import { getDb } from "@/lib/db";
++import { createSavedReport } from "@/lib/db/saved-reports";
++import { getUserSettings } from "@/lib/db/user-settings";
++import { TronAddressSchema } from "@/lib/validators";
++
++export const runtime = "nodejs";
++
++const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
++
++const SaveReportBodySchema = z.object({
++  address: TronAddressSchema,
++  report: z.unknown(),
++});
++
++const AnalyzeReportSchema = z
++  .object({
++    address: TronAddressSchema,
++    risk: z.object({
++      score: z.number(),
++      tier: RiskTierSchema,
++      confidence: z.number(),
++    }),
++    checks: z
++      .object({
++        exposure1hop: z.unknown().optional(),
++        tracing2hop: z.unknown().optional(),
++      })
++      .passthrough()
++      .optional(),
++  })
++  .passthrough();
++
++function clampInt(n: number, min: number, max: number) {
++  return Math.max(min, Math.min(max, Math.round(n)));
++}
++
++function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
++  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
++  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
++    return exposure.window;
++  }
++
++  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
++  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
++    return tracing.window;
++  }
++
++  return { lookbackDays: 90 };
++}
++
++async function getAuthenticatedUserId(): Promise<string | null> {
++  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
++  try {
++    const { userId } = await auth();
++    return userId ?? null;
++  } catch {
++    return null;
++  }
++}
++
++export async function POST(request: Request) {
++  const userId = await getAuthenticatedUserId();
++  if (!userId) {
++    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
++  }
++
++  if (!process.env.ADDRESS_HASH_KEY) {
++    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
++  }
++
++  const db = getDb();
++  if (!db) {
++    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
++  }
++
++  const settings = await getUserSettings(db, userId);
++  if (!settings?.loggingEnabled) {
++    return NextResponse.json(
++      { error: "Saving is disabled. Enable it in Settings first." },
++      { status: 403, headers: { "Cache-Control": "no-store" } },
++    );
++  }
++
++  let json: unknown;
++  try {
++    json = await request.json();
++  } catch {
++    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
++  }
++
++  const parsed = SaveReportBodySchema.safeParse(json);
++  if (!parsed.success) {
++    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
++  }
++
++  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
++  if (!reportParsed.success) {
++    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
++  }
++
++  if (reportParsed.data.address !== parsed.data.address) {
++    return NextResponse.json(
++      { error: "Report address mismatch." },
++      { status: 400, headers: { "Cache-Control": "no-store" } },
++    );
++  }
++
++  const report = reportParsed.data;
++  const created = await createSavedReport(db, userId, {
++    address: parsed.data.address,
++    riskScore: clampInt(report.risk.score, 0, 100),
++    riskTier: report.risk.tier,
++    confidence: clampInt(report.risk.confidence, 0, 100),
++    window: deriveWindow(report),
++    reportJson: parsed.data.report,
++  });
++
++  if (!created) {
++    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
++  }
++
++  return NextResponse.json(
++    { id: created.id, createdAt: created.createdAt },
++    { status: 200, headers: { "Cache-Control": "no-store" } },
++  );
++}
+diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
+index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
+--- a/src/components/blacklist-checker.tsx
++++ b/src/components/blacklist-checker.tsx
+@@ -506,6 +506,108 @@
+   );
+ }
+ 
++function SaveReportControl({ report }: { report: ApiResponse }) {
++  const { isLoaded, isSignedIn } = useAuth();
++  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
++  const [saveState, setSaveState] = React.useState<
++    | { state: "idle" }
++    | { state: "saving" }
++    | { state: "saved"; id?: string }
++  >({ state: "idle" });
++
++  React.useEffect(() => {
++    setSaveState({ state: "idle" });
++  }, [report.address, report.timestamps.checkedAtIso]);
++
++  React.useEffect(() => {
++    if (!isLoaded || !isSignedIn) return;
++    let cancelled = false;
++
++    async function loadSettings() {
++      try {
++        const res = await fetch("/api/user-settings", { credentials: "include" });
++        const json = (await res.json().catch(() => null)) as unknown;
++        if (!res.ok || !json || typeof json !== "object") return;
++
++        const obj = json as Record<string, unknown>;
++        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
++        if (cancelled) return;
++        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
++      } catch {
++        // ignore
++      }
++    }
++
++    loadSettings();
++    return () => {
++      cancelled = true;
++    };
++  }, [isLoaded, isSignedIn]);
++
++  if (!report.access?.authenticated) return null;
++  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
++
++  async function saveReport() {
++    if (saveState.state === "saving" || saveState.state === "saved") return;
++
++    setSaveState({ state: "saving" });
++    try {
++      const res = await fetch("/api/saved-reports", {
++        method: "POST",
++        headers: { "content-type": "application/json" },
++        credentials: "include",
++        body: JSON.stringify({ address: report.address, report }),
++      });
++
++      const json = (await res.json().catch(() => null)) as unknown;
++      if (!res.ok) {
++        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
++        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
++        setSaveState({ state: "idle" });
++        return;
++      }
++
++      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
++      toast.success("Report saved.");
++      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
++    } catch {
++      toast.error("Network error.");
++      setSaveState({ state: "idle" });
++    }
++  }
++
++  const saving = saveState.state === "saving";
++  const saved = saveState.state === "saved";
++
++  return (
++    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
++      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
++        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
++          <div className="min-w-0">
++            <div className="text-sm font-medium text-foreground">Save this report</div>
++            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
++          </div>
++          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
++            {saving ? (
++              <>
++                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
++                Saving…
++              </>
++            ) : saved ? (
++              <>
++                <Check className="mr-2 h-4 w-4" />
++                Saved
++              </>
++            ) : (
++              "Save"
++            )}
++          </Button>
++        </CardContent>
++      </Card>
++    </motion.div>
++  );
++}
++
+ /* ────────────────────────────────────────────────────────────────────────────
+  * Main Component
+  * ──────────────────────────────────────────────────────────────────────────── */
+@@ -963,6 +1065,12 @@
+                 {/* Status Banner */}
+                 <StatusBanner data={load.data} />
+ 
++                {clerkEnabled && (
++                  <SignedIn>
++                    <SaveReportControl report={load.data} />
++                  </SignedIn>
++                )}
++
+                 {/* Summary Card */}
+                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+diff --git a/middleware.ts b/src/middleware.ts
+index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..078996501b70d8cda7ce43e7ec365481c2b6d808
+--- a/middleware.ts
++++ b/src/middleware.ts
+@@ -1,23 +1,24 @@
+ import { NextResponse } from "next/server";
+ import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
+ 
+-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
++// Note: when using `src/app`, Next expects middleware under `src/` as well.
++const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
+ 
+ const isPublicRoute = createRouteMatcher([
+   "/",
+   "/api/check",
+   "/api/analyze",
+   "/api/user-settings",
++  "/api/saved-reports",
+   "/sign-in(.*)",
+   "/sign-up(.*)",
+ ]);
+ 
+-const clerk = clerkMiddleware((auth, req) => {
++const clerk = clerkMiddleware(async (auth, req) => {
++  const { userId, redirectToSignIn } = await auth();
+   if (isPublicRoute(req)) return;
+-  return auth().then(({ userId, redirectToSignIn }) => {
+-    if (!userId) return redirectToSignIn();
+-    return undefined;
+-  });
++  if (!userId) return redirectToSignIn();
++  return undefined;
+ });
+ 
+ export default clerkEnabled ? clerk : () => NextResponse.next();
+
+file update:
+diff --git a/.ralph/runs/run-20260123-135210-55147-iter-1.log b/.ralph/runs/run-20260123-135210-55147-iter-1.log
+index ad4c4c1a37085a0cbd6f501aebc6fd931f8fa83c..8ff13182c69ae44725abb1e2976f05d93f4e63a2
+--- a/.ralph/runs/run-20260123-135210-55147-iter-1.log
++++ b/.ralph/runs/run-20260123-135210-55147-iter-1.log
+@@ -7796,8 +7796,8 @@
+ NEXT_PUBLIC_SITE_URL=https://usdt.chikocorp.com
+ 
+ # Clerk (auth)
+-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+-CLERK_SECRET_KEY=<redacted>
++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++CLERK_SECRET_KEY=<redacted>
+ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
+ NEXT_PUBLIC_CLERK_SIGN_UP_URL=/sign-up
+ NEXT_PUBLIC_CLERK_AFTER_SIGN_IN_URL=/
+@@ -41897,3 +41897,228 @@
+ **Avoiding sensitive information leaks**
+ 
+ I need to ensure we don’t commit any `.env` contents in the future. It’s already done, but I’ll note that any secrets should be redacted in the progress log. The log file will stay untracked after I edit it with `apply_patch`, but I can commit it later. I also considered checking older logs for secrets, but that may not be necessary. I’ll check the `.ralph/.tmp/prompt` file for safety, but it seems fine, so we can go ahead and patch the run log.
++file update
++M /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-135210-55147-iter-1.log
++@@ -7798,4 +7798,4 @@
++ # Clerk (auth)
++-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++-CLERK_SECRET_KEY=<redacted>
+++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+++CLERK_SECRET_KEY=<redacted>
++ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
++                                                                                    apply_patch(auto_approved=true) exited 0 in 72ms:
++Success. Updated the following files:
++M .ralph/runs/run-20260123-135210-55147-iter-1.log
++file update:
++diff --git a/.ralph/runs/run-20260123-135210-55147-iter-1.log b/.ralph/runs/run-20260123-135210-55147-iter-1.log
++index ad4c4c1a37085a0cbd6f501aebc6fd931f8fa83c..fd591bb7283ace1b8f8af92e2899bbc866e576a9
++--- a/.ralph/runs/run-20260123-135210-55147-iter-1.log
+++++ b/.ralph/runs/run-20260123-135210-55147-iter-1.log
++@@ -7796,8 +7796,8 @@
++ NEXT_PUBLIC_SITE_URL=https://usdt.chikocorp.com
++ 
++ # Clerk (auth)
++-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++-CLERK_SECRET_KEY=<redacted>
+++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+++CLERK_SECRET_KEY=<redacted>
++ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
++ NEXT_PUBLIC_CLERK_SIGN_UP_URL=/sign-up
++ NEXT_PUBLIC_CLERK_AFTER_SIGN_IN_URL=/
++@@ -41897,3 +41897,12 @@
++ **Avoiding sensitive information leaks**
++ 
++ I need to ensure we don’t commit any `.env` contents in the future. It’s already done, but I’ll note that any secrets should be redacted in the progress log. The log file will stay untracked after I edit it with `apply_patch`, but I can commit it later. I also considered checking older logs for secrets, but that may not be necessary. I’ll check the `.ralph/.tmp/prompt` file for safety, but it seems fine, so we can go ahead and patch the run log.
+++file update
+++M /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-135210-55147-iter-1.log
+++@@ -7798,4 +7798,4 @@
+++ # Clerk (auth)
+++-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+++-CLERK_SECRET_KEY=<redacted>
++++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++++CLERK_SECRET_KEY=<redacted>
+++ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
++diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
++new file mode 100644
++index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
++--- /dev/null
+++++ b/src/__tests__/api-saved-reports.test.ts
++@@ -0,0 +1,107 @@
+++import { beforeEach, describe, expect, it, vi } from "vitest";
+++
+++const auth = vi.fn();
+++vi.mock("@clerk/nextjs/server", () => ({ auth }));
+++
+++const getDb = vi.fn();
+++vi.mock("@/lib/db", () => ({ getDb }));
+++
+++const getUserSettings = vi.fn();
+++vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+++
+++const createSavedReport = vi.fn();
+++vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+++
+++const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+++
+++async function callPost(body: unknown) {
+++  const { POST } = await import("@/app/api/saved-reports/route");
+++  const req = new Request("http://localhost/api/saved-reports", {
+++    method: "POST",
+++    headers: { "content-type": "application/json" },
+++    body: JSON.stringify(body),
+++  });
+++  const res = await POST(req);
+++  const json = await res.json().catch(() => null);
+++  return { res, json };
+++}
+++
+++beforeEach(() => {
+++  vi.resetModules();
+++  vi.clearAllMocks();
+++  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+++  process.env.CLERK_SECRET_KEY = "sk_test_123";
+++  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+++});
+++
+++describe("/api/saved-reports", () => {
+++  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+++    auth.mockResolvedValue({ userId: null });
+++
+++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+++    expect(res.status).toBe(401);
+++    expect(getDb).not.toHaveBeenCalled();
+++    expect(getUserSettings).not.toHaveBeenCalled();
+++    expect(createSavedReport).not.toHaveBeenCalled();
+++  });
+++
+++  it("returns 503 when persistence is disabled", async () => {
+++    auth.mockResolvedValue({ userId: "user_123" });
+++    getDb.mockReturnValue(null);
+++
+++    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+++    expect(res.status).toBe(503);
+++    expect(json?.error).toBeTypeOf("string");
+++    expect(getUserSettings).not.toHaveBeenCalled();
+++    expect(createSavedReport).not.toHaveBeenCalled();
+++  });
+++
+++  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+++    auth.mockResolvedValue({ userId: "user_123" });
+++    getDb.mockReturnValue({});
+++    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+++
+++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+++    expect(res.status).toBe(403);
+++    expect(createSavedReport).not.toHaveBeenCalled();
+++  });
+++
+++  it("validates payload and rejects mismatched report addresses", async () => {
+++    auth.mockResolvedValue({ userId: "user_123" });
+++    getDb.mockReturnValue({});
+++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+++
+++    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+++    const { res } = await callPost({ address: VALID_ADDRESS, report });
+++    expect(res.status).toBe(400);
+++    expect(createSavedReport).not.toHaveBeenCalled();
+++  });
+++
+++  it("creates a SavedReport and returns its id", async () => {
+++    auth.mockResolvedValue({ userId: "user_123" });
+++    getDb.mockReturnValue({});
+++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+++    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+++
+++    const report = {
+++      address: VALID_ADDRESS,
+++      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+++      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+++    };
+++
+++    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+++    expect(res.status).toBe(200);
+++    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+++    expect(createSavedReport).toHaveBeenCalledWith(
+++      {},
+++      "user_123",
+++      expect.objectContaining({
+++        address: VALID_ADDRESS,
+++        riskScore: 55,
+++        riskTier: "high",
+++        confidence: 92,
+++        window: { lookbackDays: 90 },
+++      }),
+++    );
+++  });
+++});
++diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
++new file mode 100644
++index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
++--- /dev/null
+++++ b/src/app/api/saved-reports/route.ts
++@@ -0,0 +1,130 @@
+++import { NextResponse } from "next/server";
+++import { auth } from "@clerk/nextjs/server";
+++import { z } from "zod";
+++
+++import { getDb } from "@/lib/db";
+++import { createSavedReport } from "@/lib/db/saved-reports";
+++import { getUserSettings } from "@/lib/db/user-settings";
+++import { TronAddressSchema } from "@/lib/validators";
+++
+++export const runtime = "nodejs";
+++
+++const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+++
+++const SaveReportBodySchema = z.object({
+++  address: TronAddressSchema,
+++  report: z.unknown(),
+++});
+++
+++const AnalyzeReportSchema = z
+++  .object({
+++    address: TronAddressSchema,
+++    risk: z.object({
+++      score: z.number(),
+++      tier: RiskTierSchema,
+++      confidence: z.number(),
+++    }),
+++    checks: z
+++      .object({
+++        exposure1hop: z.unknown().optional(),
+++        tracing2hop: z.unknown().optional(),
+++      })
+++      .passthrough()
+++      .optional(),
+++  })
+++  .passthrough();
+++
+++function clampInt(n: number, min: number, max: number) {
+++  return Math.max(min, Math.min(max, Math.round(n)));
+++}
+++
+++function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+++  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+++  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+++    return exposure.window;
+++  }
+++
+++  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+++  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+++    return tracing.window;
+++  }
+++
+++  return { lookbackDays: 90 };
+++}
+++
+++async function getAuthenticatedUserId(): Promise<string | null> {
+++  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+++  try {
+++    const { userId } = await auth();
+++    return userId ?? null;
+++  } catch {
+++    return null;
+++  }
+++}
+++
+++export async functi
+\ No newline at end of file
+diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
+new file mode 100644
+index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
+--- /dev/null
++++ b/src/__tests__/api-saved-reports.test.ts
+@@ -0,0 +1,107 @@
++import { beforeEach, describe, expect, it, vi } from "vitest";
++
++const auth = vi.fn();
++vi.mock("@clerk/nextjs/server", () => ({ auth }));
++
++const getDb = vi.fn();
++vi.mock("@/lib/db", () => ({ getDb }));
++
++const getUserSettings = vi.fn();
++vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
++
++const createSavedReport = vi.fn();
++vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
++
++const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
++
++async function callPost(body: unknown) {
++  const { POST } = await import("@/app/api/saved-reports/route");
++  const req = new Request("http://localhost/api/saved-reports", {
++    method: "POST",
++    headers: { "content-type": "application/json" },
++    body: JSON.stringify(body),
++  });
++  const res = await POST(req);
++  const json = await res.json().catch(() => null);
++  return { res, json };
++}
++
++beforeEach(() => {
++  vi.resetModules();
++  vi.clearAllMocks();
++  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
++  process.env.CLERK_SECRET_KEY = "sk_test_123";
++  process.env.ADDRESS_HASH_KEY = "test_hash_key";
++});
++
++describe("/api/saved-reports", () => {
++  it("returns 401 when unauthenticated and does not touch the DB", async () => {
++    auth.mockResolvedValue({ userId: null });
++
++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
++    expect(res.status).toBe(401);
++    expect(getDb).not.toHaveBeenCalled();
++    expect(getUserSettings).not.toHaveBeenCalled();
++    expect(createSavedReport).not.toHaveBeenCalled();
++  });
++
++  it("returns 503 when persistence is disabled", async () => {
++    auth.mockResolvedValue({ userId: "user_123" });
++    getDb.mockReturnValue(null);
++
++    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
++    expect(res.status).toBe(503);
++    expect(json?.error).toBeTypeOf("string");
++    expect(getUserSettings).not.toHaveBeenCalled();
++    expect(createSavedReport).not.toHaveBeenCalled();
++  });
++
++  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
++    auth.mockResolvedValue({ userId: "user_123" });
++    getDb.mockReturnValue({});
++    getUserSettings.mockResolvedValue({ loggingEnabled: false });
++
++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
++    expect(res.status).toBe(403);
++    expect(createSavedReport).not.toHaveBeenCalled();
++  });
++
++  it("validates payload and rejects mismatched report addresses", async () => {
++    auth.mockResolvedValue({ userId: "user_123" });
++    getDb.mockReturnValue({});
++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
++
++    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
++    const { res } = await callPost({ address: VALID_ADDRESS, report });
++    expect(res.status).toBe(400);
++    expect(createSavedReport).not.toHaveBeenCalled();
++  });
++
++  it("creates a SavedReport and returns its id", async () => {
++    auth.mockResolvedValue({ userId: "user_123" });
++    getDb.mockReturnValue({});
++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
++    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
++
++    const report = {
++      address: VALID_ADDRESS,
++      risk: { score: 55.2, tier: "high", confidence: 91.7 },
++      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
++    };
++
++    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
++    expect(res.status).toBe(200);
++    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
++    expect(createSavedReport).toHaveBeenCalledWith(
++      {},
++      "user_123",
++      expect.objectContaining({
++        address: VALID_ADDRESS,
++        riskScore: 55,
++        riskTier: "high",
++        confidence: 92,
++        window: { lookbackDays: 90 },
++      }),
++    );
++  });
++});
+diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
+new file mode 100644
+index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
+--- /dev/null
++++ b/src/app/api/saved-reports/route.ts
+@@ -0,0 +1,130 @@
++import { NextResponse } from "next/server";
++import { auth } from "@clerk/nextjs/server";
++import { z } from "zod";
++
++import { getDb } from "@/lib/db";
++import { createSavedReport } from "@/lib/db/saved-reports";
++import { getUserSettings } from "@/lib/db/user-settings";
++import { TronAddressSchema } from "@/lib/validators";
++
++export const runtime = "nodejs";
++
++const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
++
++const SaveReportBodySchema = z.object({
++  address: TronAddressSchema,
++  report: z.unknown(),
++});
++
++const AnalyzeReportSchema = z
++  .object({
++    address: TronAddressSchema,
++    risk: z.object({
++      score: z.number(),
++      tier: RiskTierSchema,
++      confidence: z.number(),
++    }),
++    checks: z
++      .object({
++        exposure1hop: z.unknown().optional(),
++        tracing2hop: z.unknown().optional(),
++      })
++      .passthrough()
++      .optional(),
++  })
++  .passthrough();
++
++function clampInt(n: number, min: number, max: number) {
++  return Math.max(min, Math.min(max, Math.round(n)));
++}
++
++function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
++  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
++  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
++    return exposure.window;
++  }
++
++  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
++  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
++    return tracing.window;
++  }
++
++  return { lookbackDays: 90 };
++}
++
++async function getAuthenticatedUserId(): Promise<string | null> {
++  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
++  try {
++    const { userId } = await auth();
++    return userId ?? null;
++  } catch {
++    return null;
++  }
++}
++
++export async function POST(request: Request) {
++  const userId = await getAuthenticatedUserId();
++  if (!userId) {
++    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
++  }
++
++  if (!process.env.ADDRESS_HASH_KEY) {
++    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
++  }
++
++  const db = getDb();
++  if (!db) {
++    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
++  }
++
++  const settings = await getUserSettings(db, userId);
++  if (!settings?.loggingEnabled) {
++    return NextResponse.json(
++      { error: "Saving is disabled. Enable it in Settings first." },
++      { status: 403, headers: { "Cache-Control": "no-store" } },
++    );
++  }
++
++  let json: unknown;
++  try {
++    json = await request.json();
++  } catch {
++    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
++  }
++
++  const parsed = SaveReportBodySchema.safeParse(json);
++  if (!parsed.success) {
++    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
++  }
++
++  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
++  if (!reportParsed.success) {
++    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
++  }
++
++  if (reportParsed.data.address !== parsed.data.address) {
++    return NextResponse.json(
++      { error: "Report address mismatch." },
++      { status: 400, headers: { "Cache-Control": "no-store" } },
++    );
++  }
++
++  const report = reportParsed.data;
++  const created = await createSavedReport(db, userId, {
++    address: parsed.data.address,
++    riskScore: clampInt(report.risk.score, 0, 100),
++    riskTier: report.risk.tier,
++    confidence: clampInt(report.risk.confidence, 0, 100),
++    window: deriveWindow(report),
++    reportJson: parsed.data.report,
++  });
++
++  if (!created) {
++    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
++  }
++
++  return NextResponse.json(
++    { id: created.id, createdAt: created.createdAt },
++    { status: 200, headers: { "Cache-Control": "no-store" } },
++  );
++}
+diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
+index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
+--- a/src/components/blacklist-checker.tsx
++++ b/src/components/blacklist-checker.tsx
+@@ -506,6 +506,108 @@
+   );
+ }
+ 
++function SaveReportControl({ report }: { report: ApiResponse }) {
++  const { isLoaded, isSignedIn } = useAuth();
++  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
++  const [saveState, setSaveState] = React.useState<
++    | { state: "idle" }
++    | { state: "saving" }
++    | { state: "saved"; id?: string }
++  >({ state: "idle" });
++
++  React.useEffect(() => {
++    setSaveState({ state: "idle" });
++  }, [report.address, report.timestamps.checkedAtIso]);
++
++  React.useEffect(() => {
++    if (!isLoaded || !isSignedIn) return;
++    let cancelled = false;
++
++    async function loadSettings() {
++      try {
++        const res = await fetch("/api/user-settings", { credentials: "include" });
++        const json = (await res.json().catch(() => null)) as unknown;
++        if (!res.ok || !json || typeof json !== "object") return;
++
++        const obj = json as Record<string, unknown>;
++        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
++        if (cancelled) return;
++        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
++      } catch {
++        // ignore
++      }
++    }
++
++    loadSettings();
++    return () => {
++      cancelled = true;
++    };
++  }, [isLoaded, isSignedIn]);
++
++  if (!report.access?.authenticated) return null;
++  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
++
++  async function saveReport() {
++    if (saveState.state === "saving" || saveState.state === "saved") return;
++
++    setSaveState({ state: "saving" });
++    try {
++      const res = await fetch("/api/saved-reports", {
++        method: "POST",
++        headers: { "content-type": "application/json" },
++        credentials: "include",
++        body: JSON.stringify({ address: report.address, report }),
++      });
++
++      const json = (await res.json().catch(() => null)) as unknown;
++      if (!res.ok) {
++        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
++        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
++        setSaveState({ state: "idle" });
++        return;
++      }
++
++      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
++      toast.success("Report saved.");
++      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
++    } catch {
++      toast.error("Network error.");
++      setSaveState({ state: "idle" });
++    }
++  }
++
++  const saving = saveState.state === "saving";
++  const saved = saveState.state === "saved";
++
++  return (
++    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
++      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
++        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
++          <div className="min-w-0">
++            <div className="text-sm font-medium text-foreground">Save this report</div>
++            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
++          </div>
++          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
++            {saving ? (
++              <>
++                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
++                Saving…
++              </>
++            ) : saved ? (
++              <>
++                <Check className="mr-2 h-4 w-4" />
++                Saved
++              </>
++            ) : (
++              "Save"
++            )}
++          </Button>
++        </CardContent>
++      </Card>
++    </motion.div>
++  );
++}
++
+ /* ────────────────────────────────────────────────────────────────────────────
+  * Main Component
+  * ──────────────────────────────────────────────────────────────────────────── */
+@@ -963,6 +1065,12 @@
+                 {/* Status Banner */}
+                 <StatusBanner data={load.data} />
+ 
++                {clerkEnabled && (
++                  <SignedIn>
++                    <SaveReportControl report={load.data} />
++                  </SignedIn>
++                )}
++
+                 {/* Summary Card */}
+                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+diff --git a/middleware.ts b/src/middleware.ts
+index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..078996501b70d8cda7ce43e7ec365481c2b6d808
+--- a/middleware.ts
++++ b/src/middleware.ts
+@@ -1,23 +1,24 @@
+ import { NextResponse } from "next/server";
+ import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
+ 
+-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
++// Note: when using `src/app`, Next expects middleware under `src/` as well.
++const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
+ 
+ const isPublicRoute = createRouteMatcher([
+   "/",
+   "/api/check",
+   "/api/analyze",
+   "/api/user-settings",
++  "/api/saved-reports",
+   "/sign-in(.*)",
+   "/sign-up(.*)",
+ ]);
+ 
+-const clerk = clerkMiddleware((auth, req) => {
++const clerk = clerkMiddleware(async (auth, req) => {
++  const { userId, redirectToSignIn } = await auth();
+   if (isPublicRoute(req)) return;
+-  return auth().then(({ userId, redirectToSignIn }) => {
+-    if (!userId) return redirectToSignIn();
+-    return undefined;
+-  });
++  if (!userId) return redirectToSignIn();
++  return undefined;
+ });
+ 
+ export default clerkEnabled ? clerk : () => NextResponse.next();
+
+exec
+/bin/zsh -lc 'rg -n "sk_test_|pk_test_a25v|CLERK_SECRET_KEY=sk_test|NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=pk_test" .ralph/runs/run-20260123-135210-55147-iter-1.log || true' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 76ms:
+3309:  process.env.CLERK_SECRET_KEY = "sk_test_123";
+3438:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+3824:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+4213:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+4608:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+5008:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+5405:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+5813:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+6221:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+6610:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+7005:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+7413:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+7860:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+8256:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+8669:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+9077:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+9478:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+9867:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+10213:   process.env.CLERK_SECRET_KEY = "sk_test_123";
+10273:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
diff --git a/middleware.ts b/src/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..078996501b70d8cda7ce43e7ec365481c2b6d808
--- a/middleware.ts
+++ b/src/middleware.ts
@@ -1,23 +1,24 @@
 import { NextResponse } from "next/server";
 import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
 
-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
+// Note: when using `src/app`, Next expects middleware under `src/` as well.
+const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
 
 const isPublicRoute = createRouteMatcher([
   "/",
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
 
-const clerk = clerkMiddleware((auth, req) => {
+const clerk = clerkMiddleware(async (auth, req) => {
+  const { userId, redirectToSignIn } = await auth();
   if (isPublicRoute(req)) return;
-  return auth().then(({ userId, redirectToSignIn }) => {
-    if (!userId) return redirectToSignIn();
-    return undefined;
-  });
+  if (!userId) return redirectToSignIn();
+  return undefined;
 });
 
 export default clerkEnabled ? clerk : () => NextResponse.next();

exec
/bin/zsh -lc 'rg -n "<redacted>|<redacted>" .ralph/runs/run-20260123-135210-55147-iter-1.log || true' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 75ms:
binary file matches (found "\0" byte around offset 1724417)
file update:
diff --git a/.ralph/runs/run-20260123-135210-55147-iter-1.log b/.ralph/runs/run-20260123-135210-55147-iter-1.log
index ad4c4c1a37085a0cbd6f501aebc6fd931f8fa83c..3f1a372c05f0796bd65bcb290335e7d8ab8eea77
--- a/.ralph/runs/run-20260123-135210-55147-iter-1.log
+++ b/.ralph/runs/run-20260123-135210-55147-iter-1.log
@@ -7796,8 +7796,8 @@
 NEXT_PUBLIC_SITE_URL=https://usdt.chikocorp.com
 
 # Clerk (auth)
-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
-CLERK_SECRET_KEY=<redacted>
+NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+CLERK_SECRET_KEY=<redacted>
 NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
 NEXT_PUBLIC_CLERK_SIGN_UP_URL=/sign-up
 NEXT_PUBLIC_CLERK_AFTER_SIGN_IN_URL=/
@@ -41897,3 +41897,2699 @@
 **Avoiding sensitive information leaks**
 
 I need to ensure we don’t commit any `.env` contents in the future. It’s already done, but I’ll note that any secrets should be redacted in the progress log. The log file will stay untracked after I edit it with `apply_patch`, but I can commit it later. I also considered checking older logs for secrets, but that may not be necessary. I’ll check the `.ralph/.tmp/prompt` file for safety, but it seems fine, so we can go ahead and patch the run log.
+file update
+M /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-135210-55147-iter-1.log
+@@ -7798,4 +7798,4 @@
+ # Clerk (auth)
+-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+-CLERK_SECRET_KEY=<redacted>
++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++CLERK_SECRET_KEY=<redacted>
+ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
+                                                                                    apply_patch(auto_approved=true) exited 0 in 72ms:
+Success. Updated the following files:
+M .ralph/runs/run-20260123-135210-55147-iter-1.log
+file update:
+diff --git a/.ralph/runs/run-20260123-135210-55147-iter-1.log b/.ralph/runs/run-20260123-135210-55147-iter-1.log
+index ad4c4c1a37085a0cbd6f501aebc6fd931f8fa83c..fd591bb7283ace1b8f8af92e2899bbc866e576a9
+--- a/.ralph/runs/run-20260123-135210-55147-iter-1.log
++++ b/.ralph/runs/run-20260123-135210-55147-iter-1.log
+@@ -7796,8 +7796,8 @@
+ NEXT_PUBLIC_SITE_URL=https://usdt.chikocorp.com
+ 
+ # Clerk (auth)
+-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+-CLERK_SECRET_KEY=<redacted>
++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++CLERK_SECRET_KEY=<redacted>
+ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
+ NEXT_PUBLIC_CLERK_SIGN_UP_URL=/sign-up
+ NEXT_PUBLIC_CLERK_AFTER_SIGN_IN_URL=/
+@@ -41897,3 +41897,12 @@
+ **Avoiding sensitive information leaks**
+ 
+ I need to ensure we don’t commit any `.env` contents in the future. It’s already done, but I’ll note that any secrets should be redacted in the progress log. The log file will stay untracked after I edit it with `apply_patch`, but I can commit it later. I also considered checking older logs for secrets, but that may not be necessary. I’ll check the `.ralph/.tmp/prompt` file for safety, but it seems fine, so we can go ahead and patch the run log.
++file update
++M /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-135210-55147-iter-1.log
++@@ -7798,4 +7798,4 @@
++ # Clerk (auth)
++-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++-CLERK_SECRET_KEY=<redacted>
+++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+++CLERK_SECRET_KEY=<redacted>
++ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
+diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
+new file mode 100644
+index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
+--- /dev/null
++++ b/src/__tests__/api-saved-reports.test.ts
+@@ -0,0 +1,107 @@
++import { beforeEach, describe, expect, it, vi } from "vitest";
++
++const auth = vi.fn();
++vi.mock("@clerk/nextjs/server", () => ({ auth }));
++
++const getDb = vi.fn();
++vi.mock("@/lib/db", () => ({ getDb }));
++
++const getUserSettings = vi.fn();
++vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
++
++const createSavedReport = vi.fn();
++vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
++
++const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
++
++async function callPost(body: unknown) {
++  const { POST } = await import("@/app/api/saved-reports/route");
++  const req = new Request("http://localhost/api/saved-reports", {
++    method: "POST",
++    headers: { "content-type": "application/json" },
++    body: JSON.stringify(body),
++  });
++  const res = await POST(req);
++  const json = await res.json().catch(() => null);
++  return { res, json };
++}
++
++beforeEach(() => {
++  vi.resetModules();
++  vi.clearAllMocks();
++  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
++  process.env.CLERK_SECRET_KEY = "sk_test_123";
++  process.env.ADDRESS_HASH_KEY = "test_hash_key";
++});
++
++describe("/api/saved-reports", () => {
++  it("returns 401 when unauthenticated and does not touch the DB", async () => {
++    auth.mockResolvedValue({ userId: null });
++
++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
++    expect(res.status).toBe(401);
++    expect(getDb).not.toHaveBeenCalled();
++    expect(getUserSettings).not.toHaveBeenCalled();
++    expect(createSavedReport).not.toHaveBeenCalled();
++  });
++
++  it("returns 503 when persistence is disabled", async () => {
++    auth.mockResolvedValue({ userId: "user_123" });
++    getDb.mockReturnValue(null);
++
++    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
++    expect(res.status).toBe(503);
++    expect(json?.error).toBeTypeOf("string");
++    expect(getUserSettings).not.toHaveBeenCalled();
++    expect(createSavedReport).not.toHaveBeenCalled();
++  });
++
++  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
++    auth.mockResolvedValue({ userId: "user_123" });
++    getDb.mockReturnValue({});
++    getUserSettings.mockResolvedValue({ loggingEnabled: false });
++
++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
++    expect(res.status).toBe(403);
++    expect(createSavedReport).not.toHaveBeenCalled();
++  });
++
++  it("validates payload and rejects mismatched report addresses", async () => {
++    auth.mockResolvedValue({ userId: "user_123" });
++    getDb.mockReturnValue({});
++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
++
++    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
++    const { res } = await callPost({ address: VALID_ADDRESS, report });
++    expect(res.status).toBe(400);
++    expect(createSavedReport).not.toHaveBeenCalled();
++  });
++
++  it("creates a SavedReport and returns its id", async () => {
++    auth.mockResolvedValue({ userId: "user_123" });
++    getDb.mockReturnValue({});
++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
++    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
++
++    const report = {
++      address: VALID_ADDRESS,
++      risk: { score: 55.2, tier: "high", confidence: 91.7 },
++      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
++    };
++
++    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
++    expect(res.status).toBe(200);
++    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
++    expect(createSavedReport).toHaveBeenCalledWith(
++      {},
++      "user_123",
++      expect.objectContaining({
++        address: VALID_ADDRESS,
++        riskScore: 55,
++        riskTier: "high",
++        confidence: 92,
++        window: { lookbackDays: 90 },
++      }),
++    );
++  });
++});
+diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
+new file mode 100644
+index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
+--- /dev/null
++++ b/src/app/api/saved-reports/route.ts
+@@ -0,0 +1,130 @@
++import { NextResponse } from "next/server";
++import { auth } from "@clerk/nextjs/server";
++import { z } from "zod";
++
++import { getDb } from "@/lib/db";
++import { createSavedReport } from "@/lib/db/saved-reports";
++import { getUserSettings } from "@/lib/db/user-settings";
++import { TronAddressSchema } from "@/lib/validators";
++
++export const runtime = "nodejs";
++
++const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
++
++const SaveReportBodySchema = z.object({
++  address: TronAddressSchema,
++  report: z.unknown(),
++});
++
++const AnalyzeReportSchema = z
++  .object({
++    address: TronAddressSchema,
++    risk: z.object({
++      score: z.number(),
++      tier: RiskTierSchema,
++      confidence: z.number(),
++    }),
++    checks: z
++      .object({
++        exposure1hop: z.unknown().optional(),
++        tracing2hop: z.unknown().optional(),
++      })
++      .passthrough()
++      .optional(),
++  })
++  .passthrough();
++
++function clampInt(n: number, min: number, max: number) {
++  return Math.max(min, Math.min(max, Math.round(n)));
++}
++
++function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
++  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
++  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
++    return exposure.window;
++  }
++
++  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
++  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
++    return tracing.window;
++  }
++
++  return { lookbackDays: 90 };
++}
++
++async function getAuthenticatedUserId(): Promise<string | null> {
++  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
++  try {
++    const { userId } = await auth();
++    return userId ?? null;
++  } catch {
++    return null;
++  }
++}
++
++export async function POST(request: Request) {
++  const userId = await getAuthenticatedUserId();
++  if (!userId) {
++    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
++  }
++
++  if (!process.env.ADDRESS_HASH_KEY) {
++    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
++  }
++
++  const db = getDb();
++  if (!db) {
++    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
++  }
++
++  const settings = await getUserSettings(db, userId);
++  if (!settings?.loggingEnabled) {
++    return NextResponse.json(
++      { error: "Saving is disabled. Enable it in Settings first." },
++      { status: 403, headers: { "Cache-Control": "no-store" } },
++    );
++  }
++
++  let json: unknown;
++  try {
++    json = await request.json();
++  } catch {
++    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
++  }
++
++  const parsed = SaveReportBodySchema.safeParse(json);
++  if (!parsed.success) {
++    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
++  }
++
++  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
++  if (!reportParsed.success) {
++    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
++  }
++
++  if (reportParsed.data.address !== parsed.data.address) {
++    return NextResponse.json(
++      { error: "Report address mismatch." },
++      { status: 400, headers: { "Cache-Control": "no-store" } },
++    );
++  }
++
++  const report = reportParsed.data;
++  const created = await createSavedReport(db, userId, {
++    address: parsed.data.address,
++    riskScore: clampInt(report.risk.score, 0, 100),
++    riskTier: report.risk.tier,
++    confidence: clampInt(report.risk.confidence, 0, 100),
++    window: deriveWindow(report),
++    reportJson: parsed.data.report,
++  });
++
++  if (!created) {
++    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
++  }
++
++  return NextResponse.json(
++    { id: created.id, createdAt: created.createdAt },
++    { status: 200, headers: { "Cache-Control": "no-store" } },
++  );
++}
+diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
+index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
+--- a/src/components/blacklist-checker.tsx
++++ b/src/components/blacklist-checker.tsx
+@@ -506,6 +506,108 @@
+   );
+ }
+ 
++function SaveReportControl({ report }: { report: ApiResponse }) {
++  const { isLoaded, isSignedIn } = useAuth();
++  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
++  const [saveState, setSaveState] = React.useState<
++    | { state: "idle" }
++    | { state: "saving" }
++    | { state: "saved"; id?: string }
++  >({ state: "idle" });
++
++  React.useEffect(() => {
++    setSaveState({ state: "idle" });
++  }, [report.address, report.timestamps.checkedAtIso]);
++
++  React.useEffect(() => {
++    if (!isLoaded || !isSignedIn) return;
++    let cancelled = false;
++
++    async function loadSettings() {
++      try {
++        const res = await fetch("/api/user-settings", { credentials: "include" });
++        const json = (await res.json().catch(() => null)) as unknown;
++        if (!res.ok || !json || typeof json !== "object") return;
++
++        const obj = json as Record<string, unknown>;
++        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
++        if (cancelled) return;
++        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
++      } catch {
++        // ignore
++      }
++    }
++
++    loadSettings();
++    return () => {
++      cancelled = true;
++    };
++  }, [isLoaded, isSignedIn]);
++
++  if (!report.access?.authenticated) return null;
++  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
++
++  async function saveReport() {
++    if (saveState.state === "saving" || saveState.state === "saved") return;
++
++    setSaveState({ state: "saving" });
++    try {
++      const res = await fetch("/api/saved-reports", {
++        method: "POST",
++        headers: { "content-type": "application/json" },
++        credentials: "include",
++        body: JSON.stringify({ address: report.address, report }),
++      });
++
++      const json = (await res.json().catch(() => null)) as unknown;
++      if (!res.ok) {
++        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
++        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
++        setSaveState({ state: "idle" });
++        return;
++      }
++
++      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
++      toast.success("Report saved.");
++      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
++    } catch {
++      toast.error("Network error.");
++      setSaveState({ state: "idle" });
++    }
++  }
++
++  const saving = saveState.state === "saving";
++  const saved = saveState.state === "saved";
++
++  return (
++    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
++      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
++        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
++          <div className="min-w-0">
++            <div className="text-sm font-medium text-foreground">Save this report</div>
++            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
++          </div>
++          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
++            {saving ? (
++              <>
++                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
++                Saving…
++              </>
++            ) : saved ? (
++              <>
++                <Check className="mr-2 h-4 w-4" />
++                Saved
++              </>
++            ) : (
++              "Save"
++            )}
++          </Button>
++        </CardContent>
++      </Card>
++    </motion.div>
++  );
++}
++
+ /* ────────────────────────────────────────────────────────────────────────────
+  * Main Component
+  * ──────────────────────────────────────────────────────────────────────────── */
+@@ -963,6 +1065,12 @@
+                 {/* Status Banner */}
+                 <StatusBanner data={load.data} />
+ 
++                {clerkEnabled && (
++                  <SignedIn>
++                    <SaveReportControl report={load.data} />
++                  </SignedIn>
++                )}
++
+                 {/* Summary Card */}
+                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+diff --git a/middleware.ts b/src/middleware.ts
+index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..078996501b70d8cda7ce43e7ec365481c2b6d808
+--- a/middleware.ts
++++ b/src/middleware.ts
+@@ -1,23 +1,24 @@
+ import { NextResponse } from "next/server";
+ import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
+ 
+-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
++// Note: when using `src/app`, Next expects middleware under `src/` as well.
++const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
+ 
+ const isPublicRoute = createRouteMatcher([
+   "/",
+   "/api/check",
+   "/api/analyze",
+   "/api/user-settings",
++  "/api/saved-reports",
+   "/sign-in(.*)",
+   "/sign-up(.*)",
+ ]);
+ 
+-const clerk = clerkMiddleware((auth, req) => {
++const clerk = clerkMiddleware(async (auth, req) => {
++  const { userId, redirectToSignIn } = await auth();
+   if (isPublicRoute(req)) return;
+-  return auth().then(({ userId, redirectToSignIn }) => {
+-    if (!userId) return redirectToSignIn();
+-    return undefined;
+-  });
++  if (!userId) return redirectToSignIn();
++  return undefined;
+ });
+ 
+ export default clerkEnabled ? clerk : () => NextResponse.next();
+
+file update:
+diff --git a/.ralph/runs/run-20260123-135210-55147-iter-1.log b/.ralph/runs/run-20260123-135210-55147-iter-1.log
+index ad4c4c1a37085a0cbd6f501aebc6fd931f8fa83c..8ff13182c69ae44725abb1e2976f05d93f4e63a2
+--- a/.ralph/runs/run-20260123-135210-55147-iter-1.log
++++ b/.ralph/runs/run-20260123-135210-55147-iter-1.log
+@@ -7796,8 +7796,8 @@
+ NEXT_PUBLIC_SITE_URL=https://usdt.chikocorp.com
+ 
+ # Clerk (auth)
+-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+-CLERK_SECRET_KEY=<redacted>
++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++CLERK_SECRET_KEY=<redacted>
+ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
+ NEXT_PUBLIC_CLERK_SIGN_UP_URL=/sign-up
+ NEXT_PUBLIC_CLERK_AFTER_SIGN_IN_URL=/
+@@ -41897,3 +41897,228 @@
+ **Avoiding sensitive information leaks**
+ 
+ I need to ensure we don’t commit any `.env` contents in the future. It’s already done, but I’ll note that any secrets should be redacted in the progress log. The log file will stay untracked after I edit it with `apply_patch`, but I can commit it later. I also considered checking older logs for secrets, but that may not be necessary. I’ll check the `.ralph/.tmp/prompt` file for safety, but it seems fine, so we can go ahead and patch the run log.
++file update
++M /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-135210-55147-iter-1.log
++@@ -7798,4 +7798,4 @@
++ # Clerk (auth)
++-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++-CLERK_SECRET_KEY=<redacted>
+++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+++CLERK_SECRET_KEY=<redacted>
++ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
++                                                                                    apply_patch(auto_approved=true) exited 0 in 72ms:
++Success. Updated the following files:
++M .ralph/runs/run-20260123-135210-55147-iter-1.log
++file update:
++diff --git a/.ralph/runs/run-20260123-135210-55147-iter-1.log b/.ralph/runs/run-20260123-135210-55147-iter-1.log
++index ad4c4c1a37085a0cbd6f501aebc6fd931f8fa83c..fd591bb7283ace1b8f8af92e2899bbc866e576a9
++--- a/.ralph/runs/run-20260123-135210-55147-iter-1.log
+++++ b/.ralph/runs/run-20260123-135210-55147-iter-1.log
++@@ -7796,8 +7796,8 @@
++ NEXT_PUBLIC_SITE_URL=https://usdt.chikocorp.com
++ 
++ # Clerk (auth)
++-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++-CLERK_SECRET_KEY=<redacted>
+++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+++CLERK_SECRET_KEY=<redacted>
++ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
++ NEXT_PUBLIC_CLERK_SIGN_UP_URL=/sign-up
++ NEXT_PUBLIC_CLERK_AFTER_SIGN_IN_URL=/
++@@ -41897,3 +41897,12 @@
++ **Avoiding sensitive information leaks**
++ 
++ I need to ensure we don’t commit any `.env` contents in the future. It’s already done, but I’ll note that any secrets should be redacted in the progress log. The log file will stay untracked after I edit it with `apply_patch`, but I can commit it later. I also considered checking older logs for secrets, but that may not be necessary. I’ll check the `.ralph/.tmp/prompt` file for safety, but it seems fine, so we can go ahead and patch the run log.
+++file update
+++M /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-135210-55147-iter-1.log
+++@@ -7798,4 +7798,4 @@
+++ # Clerk (auth)
+++-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+++-CLERK_SECRET_KEY=<redacted>
++++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++++CLERK_SECRET_KEY=<redacted>
+++ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
++diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
++new file mode 100644
++index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
++--- /dev/null
+++++ b/src/__tests__/api-saved-reports.test.ts
++@@ -0,0 +1,107 @@
+++import { beforeEach, describe, expect, it, vi } from "vitest";
+++
+++const auth = vi.fn();
+++vi.mock("@clerk/nextjs/server", () => ({ auth }));
+++
+++const getDb = vi.fn();
+++vi.mock("@/lib/db", () => ({ getDb }));
+++
+++const getUserSettings = vi.fn();
+++vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+++
+++const createSavedReport = vi.fn();
+++vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+++
+++const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+++
+++async function callPost(body: unknown) {
+++  const { POST } = await import("@/app/api/saved-reports/route");
+++  const req = new Request("http://localhost/api/saved-reports", {
+++    method: "POST",
+++    headers: { "content-type": "application/json" },
+++    body: JSON.stringify(body),
+++  });
+++  const res = await POST(req);
+++  const json = await res.json().catch(() => null);
+++  return { res, json };
+++}
+++
+++beforeEach(() => {
+++  vi.resetModules();
+++  vi.clearAllMocks();
+++  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+++  process.env.CLERK_SECRET_KEY = "sk_test_123";
+++  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+++});
+++
+++describe("/api/saved-reports", () => {
+++  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+++    auth.mockResolvedValue({ userId: null });
+++
+++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+++    expect(res.status).toBe(401);
+++    expect(getDb).not.toHaveBeenCalled();
+++    expect(getUserSettings).not.toHaveBeenCalled();
+++    expect(createSavedReport).not.toHaveBeenCalled();
+++  });
+++
+++  it("returns 503 when persistence is disabled", async () => {
+++    auth.mockResolvedValue({ userId: "user_123" });
+++    getDb.mockReturnValue(null);
+++
+++    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+++    expect(res.status).toBe(503);
+++    expect(json?.error).toBeTypeOf("string");
+++    expect(getUserSettings).not.toHaveBeenCalled();
+++    expect(createSavedReport).not.toHaveBeenCalled();
+++  });
+++
+++  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+++    auth.mockResolvedValue({ userId: "user_123" });
+++    getDb.mockReturnValue({});
+++    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+++
+++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+++    expect(res.status).toBe(403);
+++    expect(createSavedReport).not.toHaveBeenCalled();
+++  });
+++
+++  it("validates payload and rejects mismatched report addresses", async () => {
+++    auth.mockResolvedValue({ userId: "user_123" });
+++    getDb.mockReturnValue({});
+++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+++
+++    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+++    const { res } = await callPost({ address: VALID_ADDRESS, report });
+++    expect(res.status).toBe(400);
+++    expect(createSavedReport).not.toHaveBeenCalled();
+++  });
+++
+++  it("creates a SavedReport and returns its id", async () => {
+++    auth.mockResolvedValue({ userId: "user_123" });
+++    getDb.mockReturnValue({});
+++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+++    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+++
+++    const report = {
+++      address: VALID_ADDRESS,
+++      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+++      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+++    };
+++
+++    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+++    expect(res.status).toBe(200);
+++    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+++    expect(createSavedReport).toHaveBeenCalledWith(
+++      {},
+++      "user_123",
+++      expect.objectContaining({
+++        address: VALID_ADDRESS,
+++        riskScore: 55,
+++        riskTier: "high",
+++        confidence: 92,
+++        window: { lookbackDays: 90 },
+++      }),
+++    );
+++  });
+++});
++diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
++new file mode 100644
++index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
++--- /dev/null
+++++ b/src/app/api/saved-reports/route.ts
++@@ -0,0 +1,130 @@
+++import { NextResponse } from "next/server";
+++import { auth } from "@clerk/nextjs/server";
+++import { z } from "zod";
+++
+++import { getDb } from "@/lib/db";
+++import { createSavedReport } from "@/lib/db/saved-reports";
+++import { getUserSettings } from "@/lib/db/user-settings";
+++import { TronAddressSchema } from "@/lib/validators";
+++
+++export const runtime = "nodejs";
+++
+++const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+++
+++const SaveReportBodySchema = z.object({
+++  address: TronAddressSchema,
+++  report: z.unknown(),
+++});
+++
+++const AnalyzeReportSchema = z
+++  .object({
+++    address: TronAddressSchema,
+++    risk: z.object({
+++      score: z.number(),
+++      tier: RiskTierSchema,
+++      confidence: z.number(),
+++    }),
+++    checks: z
+++      .object({
+++        exposure1hop: z.unknown().optional(),
+++        tracing2hop: z.unknown().optional(),
+++      })
+++      .passthrough()
+++      .optional(),
+++  })
+++  .passthrough();
+++
+++function clampInt(n: number, min: number, max: number) {
+++  return Math.max(min, Math.min(max, Math.round(n)));
+++}
+++
+++function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+++  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+++  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+++    return exposure.window;
+++  }
+++
+++  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+++  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+++    return tracing.window;
+++  }
+++
+++  return { lookbackDays: 90 };
+++}
+++
+++async function getAuthenticatedUserId(): Promise<string | null> {
+++  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+++  try {
+++    const { userId } = await auth();
+++    return userId ?? null;
+++  } catch {
+++    return null;
+++  }
+++}
+++
+++export async functi
+\ No newline at end of file
+diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
+new file mode 100644
+index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
+--- /dev/null
++++ b/src/__tests__/api-saved-reports.test.ts
+@@ -0,0 +1,107 @@
++import { beforeEach, describe, expect, it, vi } from "vitest";
++
++const auth = vi.fn();
++vi.mock("@clerk/nextjs/server", () => ({ auth }));
++
++const getDb = vi.fn();
++vi.mock("@/lib/db", () => ({ getDb }));
++
++const getUserSettings = vi.fn();
++vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
++
++const createSavedReport = vi.fn();
++vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
++
++const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
++
++async function callPost(body: unknown) {
++  const { POST } = await import("@/app/api/saved-reports/route");
++  const req = new Request("http://localhost/api/saved-reports", {
++    method: "POST",
++    headers: { "content-type": "application/json" },
++    body: JSON.stringify(body),
++  });
++  const res = await POST(req);
++  const json = await res.json().catch(() => null);
++  return { res, json };
++}
++
++beforeEach(() => {
++  vi.resetModules();
++  vi.clearAllMocks();
++  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
++  process.env.CLERK_SECRET_KEY = "sk_test_123";
++  process.env.ADDRESS_HASH_KEY = "test_hash_key";
++});
++
++describe("/api/saved-reports", () => {
++  it("returns 401 when unauthenticated and does not touch the DB", async () => {
++    auth.mockResolvedValue({ userId: null });
++
++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
++    expect(res.status).toBe(401);
++    expect(getDb).not.toHaveBeenCalled();
++    expect(getUserSettings).not.toHaveBeenCalled();
++    expect(createSavedReport).not.toHaveBeenCalled();
++  });
++
++  it("returns 503 when persistence is disabled", async () => {
++    auth.mockResolvedValue({ userId: "user_123" });
++    getDb.mockReturnValue(null);
++
++    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
++    expect(res.status).toBe(503);
++    expect(json?.error).toBeTypeOf("string");
++    expect(getUserSettings).not.toHaveBeenCalled();
++    expect(createSavedReport).not.toHaveBeenCalled();
++  });
++
++  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
++    auth.mockResolvedValue({ userId: "user_123" });
++    getDb.mockReturnValue({});
++    getUserSettings.mockResolvedValue({ loggingEnabled: false });
++
++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
++    expect(res.status).toBe(403);
++    expect(createSavedReport).not.toHaveBeenCalled();
++  });
++
++  it("validates payload and rejects mismatched report addresses", async () => {
++    auth.mockResolvedValue({ userId: "user_123" });
++    getDb.mockReturnValue({});
++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
++
++    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
++    const { res } = await callPost({ address: VALID_ADDRESS, report });
++    expect(res.status).toBe(400);
++    expect(createSavedReport).not.toHaveBeenCalled();
++  });
++
++  it("creates a SavedReport and returns its id", async () => {
++    auth.mockResolvedValue({ userId: "user_123" });
++    getDb.mockReturnValue({});
++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
++    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
++
++    const report = {
++      address: VALID_ADDRESS,
++      risk: { score: 55.2, tier: "high", confidence: 91.7 },
++      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
++    };
++
++    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
++    expect(res.status).toBe(200);
++    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
++    expect(createSavedReport).toHaveBeenCalledWith(
++      {},
++      "user_123",
++      expect.objectContaining({
++        address: VALID_ADDRESS,
++        riskScore: 55,
++        riskTier: "high",
++        confidence: 92,
++        window: { lookbackDays: 90 },
++      }),
++    );
++  });
++});
+diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
+new file mode 100644
+index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
+--- /dev/null
++++ b/src/app/api/saved-reports/route.ts
+@@ -0,0 +1,130 @@
++import { NextResponse } from "next/server";
++import { auth } from "@clerk/nextjs/server";
++import { z } from "zod";
++
++import { getDb } from "@/lib/db";
++import { createSavedReport } from "@/lib/db/saved-reports";
++import { getUserSettings } from "@/lib/db/user-settings";
++import { TronAddressSchema } from "@/lib/validators";
++
++export const runtime = "nodejs";
++
++const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
++
++const SaveReportBodySchema = z.object({
++  address: TronAddressSchema,
++  report: z.unknown(),
++});
++
++const AnalyzeReportSchema = z
++  .object({
++    address: TronAddressSchema,
++    risk: z.object({
++      score: z.number(),
++      tier: RiskTierSchema,
++      confidence: z.number(),
++    }),
++    checks: z
++      .object({
++        exposure1hop: z.unknown().optional(),
++        tracing2hop: z.unknown().optional(),
++      })
++      .passthrough()
++      .optional(),
++  })
++  .passthrough();
++
++function clampInt(n: number, min: number, max: number) {
++  return Math.max(min, Math.min(max, Math.round(n)));
++}
++
++function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
++  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
++  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
++    return exposure.window;
++  }
++
++  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
++  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
++    return tracing.window;
++  }
++
++  return { lookbackDays: 90 };
++}
++
++async function getAuthenticatedUserId(): Promise<string | null> {
++  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
++  try {
++    const { userId } = await auth();
++    return userId ?? null;
++  } catch {
++    return null;
++  }
++}
++
++export async function POST(request: Request) {
++  const userId = await getAuthenticatedUserId();
++  if (!userId) {
++    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
++  }
++
++  if (!process.env.ADDRESS_HASH_KEY) {
++    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
++  }
++
++  const db = getDb();
++  if (!db) {
++    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
++  }
++
++  const settings = await getUserSettings(db, userId);
++  if (!settings?.loggingEnabled) {
++    return NextResponse.json(
++      { error: "Saving is disabled. Enable it in Settings first." },
++      { status: 403, headers: { "Cache-Control": "no-store" } },
++    );
++  }
++
++  let json: unknown;
++  try {
++    json = await request.json();
++  } catch {
++    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
++  }
++
++  const parsed = SaveReportBodySchema.safeParse(json);
++  if (!parsed.success) {
++    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
++  }
++
++  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
++  if (!reportParsed.success) {
++    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
++  }
++
++  if (reportParsed.data.address !== parsed.data.address) {
++    return NextResponse.json(
++      { error: "Report address mismatch." },
++      { status: 400, headers: { "Cache-Control": "no-store" } },
++    );
++  }
++
++  const report = reportParsed.data;
++  const created = await createSavedReport(db, userId, {
++    address: parsed.data.address,
++    riskScore: clampInt(report.risk.score, 0, 100),
++    riskTier: report.risk.tier,
++    confidence: clampInt(report.risk.confidence, 0, 100),
++    window: deriveWindow(report),
++    reportJson: parsed.data.report,
++  });
++
++  if (!created) {
++    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
++  }
++
++  return NextResponse.json(
++    { id: created.id, createdAt: created.createdAt },
++    { status: 200, headers: { "Cache-Control": "no-store" } },
++  );
++}
+diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
+index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
+--- a/src/components/blacklist-checker.tsx
++++ b/src/components/blacklist-checker.tsx
+@@ -506,6 +506,108 @@
+   );
+ }
+ 
++function SaveReportControl({ report }: { report: ApiResponse }) {
++  const { isLoaded, isSignedIn } = useAuth();
++  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
++  const [saveState, setSaveState] = React.useState<
++    | { state: "idle" }
++    | { state: "saving" }
++    | { state: "saved"; id?: string }
++  >({ state: "idle" });
++
++  React.useEffect(() => {
++    setSaveState({ state: "idle" });
++  }, [report.address, report.timestamps.checkedAtIso]);
++
++  React.useEffect(() => {
++    if (!isLoaded || !isSignedIn) return;
++    let cancelled = false;
++
++    async function loadSettings() {
++      try {
++        const res = await fetch("/api/user-settings", { credentials: "include" });
++        const json = (await res.json().catch(() => null)) as unknown;
++        if (!res.ok || !json || typeof json !== "object") return;
++
++        const obj = json as Record<string, unknown>;
++        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
++        if (cancelled) return;
++        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
++      } catch {
++        // ignore
++      }
++    }
++
++    loadSettings();
++    return () => {
++      cancelled = true;
++    };
++  }, [isLoaded, isSignedIn]);
++
++  if (!report.access?.authenticated) return null;
++  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
++
++  async function saveReport() {
++    if (saveState.state === "saving" || saveState.state === "saved") return;
++
++    setSaveState({ state: "saving" });
++    try {
++      const res = await fetch("/api/saved-reports", {
++        method: "POST",
++        headers: { "content-type": "application/json" },
++        credentials: "include",
++        body: JSON.stringify({ address: report.address, report }),
++      });
++
++      const json = (await res.json().catch(() => null)) as unknown;
++      if (!res.ok) {
++        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
++        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
++        setSaveState({ state: "idle" });
++        return;
++      }
++
++      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
++      toast.success("Report saved.");
++      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
++    } catch {
++      toast.error("Network error.");
++      setSaveState({ state: "idle" });
++    }
++  }
++
++  const saving = saveState.state === "saving";
++  const saved = saveState.state === "saved";
++
++  return (
++    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
++      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
++        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
++          <div className="min-w-0">
++            <div className="text-sm font-medium text-foreground">Save this report</div>
++            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
++          </div>
++          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
++            {saving ? (
++              <>
++                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
++                Saving…
++              </>
++            ) : saved ? (
++              <>
++                <Check className="mr-2 h-4 w-4" />
++                Saved
++              </>
++            ) : (
++              "Save"
++            )}
++          </Button>
++        </CardContent>
++      </Card>
++    </motion.div>
++  );
++}
++
+ /* ────────────────────────────────────────────────────────────────────────────
+  * Main Component
+  * ──────────────────────────────────────────────────────────────────────────── */
+@@ -963,6 +1065,12 @@
+                 {/* Status Banner */}
+                 <StatusBanner data={load.data} />
+ 
++                {clerkEnabled && (
++                  <SignedIn>
++                    <SaveReportControl report={load.data} />
++                  </SignedIn>
++                )}
++
+                 {/* Summary Card */}
+                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+diff --git a/middleware.ts b/src/middleware.ts
+index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..078996501b70d8cda7ce43e7ec365481c2b6d808
+--- a/middleware.ts
++++ b/src/middleware.ts
+@@ -1,23 +1,24 @@
+ import { NextResponse } from "next/server";
+ import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
+ 
+-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
++// Note: when using `src/app`, Next expects middleware under `src/` as well.
++const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
+ 
+ const isPublicRoute = createRouteMatcher([
+   "/",
+   "/api/check",
+   "/api/analyze",
+   "/api/user-settings",
++  "/api/saved-reports",
+   "/sign-in(.*)",
+   "/sign-up(.*)",
+ ]);
+ 
+-const clerk = clerkMiddleware((auth, req) => {
++const clerk = clerkMiddleware(async (auth, req) => {
++  const { userId, redirectToSignIn } = await auth();
+   if (isPublicRoute(req)) return;
+-  return auth().then(({ userId, redirectToSignIn }) => {
+-    if (!userId) return redirectToSignIn();
+-    return undefined;
+-  });
++  if (!userId) return redirectToSignIn();
++  return undefined;
+ });
+ 
+ export default clerkEnabled ? clerk : () => NextResponse.next();
+
+exec
+/bin/zsh -lc 'rg -n "sk_test_|pk_test_a25v|CLERK_SECRET_KEY=sk_test|NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=pk_test" .ralph/runs/run-20260123-135210-55147-iter-1.log || true' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 76ms:
+3309:  process.env.CLERK_SECRET_KEY = "sk_test_123";
+3438:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+3824:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+4213:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+4608:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+5008:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+5405:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+5813:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+6221:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+6610:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+7005:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+7413:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+7860:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+8256:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+8669:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+9077:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+9478:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+9867:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+10213:   process.env.CLERK_SECRET_KEY = "sk_test_123";
+10273:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+file update:
+diff --git a/.ralph/runs/run-20260123-135210-55147-iter-1.log b/.ralph/runs/run-20260123-135210-55147-iter-1.log
+index ad4c4c1a37085a0cbd6f501aebc6fd931f8fa83c..952216517f94d24bb59a56b3c137f57854ac883d
+--- a/.ralph/runs/run-20260123-135210-55147-iter-1.log
++++ b/.ralph/runs/run-20260123-135210-55147-iter-1.log
+@@ -7796,8 +7796,8 @@
+ NEXT_PUBLIC_SITE_URL=https://usdt.chikocorp.com
+ 
+ # Clerk (auth)
+-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+-CLERK_SECRET_KEY=<redacted>
++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++CLERK_SECRET_KEY=<redacted>
+ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
+ NEXT_PUBLIC_CLERK_SIGN_UP_URL=/sign-up
+ NEXT_PUBLIC_CLERK_AFTER_SIGN_IN_URL=/
+@@ -41897,3 +41897,1134 @@
+ **Avoiding sensitive information leaks**
+ 
+ I need to ensure we don’t commit any `.env` contents in the future. It’s already done, but I’ll note that any secrets should be redacted in the progress log. The log file will stay untracked after I edit it with `apply_patch`, but I can commit it later. I also considered checking older logs for secrets, but that may not be necessary. I’ll check the `.ralph/.tmp/prompt` file for safety, but it seems fine, so we can go ahead and patch the run log.
++file update
++M /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-135210-55147-iter-1.log
++@@ -7798,4 +7798,4 @@
++ # Clerk (auth)
++-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++-CLERK_SECRET_KEY=<redacted>
+++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+++CLERK_SECRET_KEY=<redacted>
++ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
++                                                                                    apply_patch(auto_approved=true) exited 0 in 72ms:
++Success. Updated the following files:
++M .ralph/runs/run-20260123-135210-55147-iter-1.log
++file update:
++diff --git a/.ralph/runs/run-20260123-135210-55147-iter-1.log b/.ralph/runs/run-20260123-135210-55147-iter-1.log
++index ad4c4c1a37085a0cbd6f501aebc6fd931f8fa83c..fd591bb7283ace1b8f8af92e2899bbc866e576a9
++--- a/.ralph/runs/run-20260123-135210-55147-iter-1.log
+++++ b/.ralph/runs/run-20260123-135210-55147-iter-1.log
++@@ -7796,8 +7796,8 @@
++ NEXT_PUBLIC_SITE_URL=https://usdt.chikocorp.com
++ 
++ # Clerk (auth)
++-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++-CLERK_SECRET_KEY=<redacted>
+++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+++CLERK_SECRET_KEY=<redacted>
++ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
++ NEXT_PUBLIC_CLERK_SIGN_UP_URL=/sign-up
++ NEXT_PUBLIC_CLERK_AFTER_SIGN_IN_URL=/
++@@ -41897,3 +41897,12 @@
++ **Avoiding sensitive information leaks**
++ 
++ I need to ensure we don’t commit any `.env` contents in the future. It’s already done, but I’ll note that any secrets should be redacted in the progress log. The log file will stay untracked after I edit it with `apply_patch`, but I can commit it later. I also considered checking older logs for secrets, but that may not be necessary. I’ll check the `.ralph/.tmp/prompt` file for safety, but it seems fine, so we can go ahead and patch the run log.
+++file update
+++M /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-135210-55147-iter-1.log
+++@@ -7798,4 +7798,4 @@
+++ # Clerk (auth)
+++-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+++-CLERK_SECRET_KEY=<redacted>
++++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++++CLERK_SECRET_KEY=<redacted>
+++ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
++diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
++new file mode 100644
++index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
++--- /dev/null
+++++ b/src/__tests__/api-saved-reports.test.ts
++@@ -0,0 +1,107 @@
+++import { beforeEach, describe, expect, it, vi } from "vitest";
+++
+++const auth = vi.fn();
+++vi.mock("@clerk/nextjs/server", () => ({ auth }));
+++
+++const getDb = vi.fn();
+++vi.mock("@/lib/db", () => ({ getDb }));
+++
+++const getUserSettings = vi.fn();
+++vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+++
+++const createSavedReport = vi.fn();
+++vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+++
+++const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+++
+++async function callPost(body: unknown) {
+++  const { POST } = await import("@/app/api/saved-reports/route");
+++  const req = new Request("http://localhost/api/saved-reports", {
+++    method: "POST",
+++    headers: { "content-type": "application/json" },
+++    body: JSON.stringify(body),
+++  });
+++  const res = await POST(req);
+++  const json = await res.json().catch(() => null);
+++  return { res, json };
+++}
+++
+++beforeEach(() => {
+++  vi.resetModules();
+++  vi.clearAllMocks();
+++  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+++  process.env.CLERK_SECRET_KEY = "sk_test_123";
+++  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+++});
+++
+++describe("/api/saved-reports", () => {
+++  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+++    auth.mockResolvedValue({ userId: null });
+++
+++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+++    expect(res.status).toBe(401);
+++    expect(getDb).not.toHaveBeenCalled();
+++    expect(getUserSettings).not.toHaveBeenCalled();
+++    expect(createSavedReport).not.toHaveBeenCalled();
+++  });
+++
+++  it("returns 503 when persistence is disabled", async () => {
+++    auth.mockResolvedValue({ userId: "user_123" });
+++    getDb.mockReturnValue(null);
+++
+++    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+++    expect(res.status).toBe(503);
+++    expect(json?.error).toBeTypeOf("string");
+++    expect(getUserSettings).not.toHaveBeenCalled();
+++    expect(createSavedReport).not.toHaveBeenCalled();
+++  });
+++
+++  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+++    auth.mockResolvedValue({ userId: "user_123" });
+++    getDb.mockReturnValue({});
+++    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+++
+++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+++    expect(res.status).toBe(403);
+++    expect(createSavedReport).not.toHaveBeenCalled();
+++  });
+++
+++  it("validates payload and rejects mismatched report addresses", async () => {
+++    auth.mockResolvedValue({ userId: "user_123" });
+++    getDb.mockReturnValue({});
+++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+++
+++    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+++    const { res } = await callPost({ address: VALID_ADDRESS, report });
+++    expect(res.status).toBe(400);
+++    expect(createSavedReport).not.toHaveBeenCalled();
+++  });
+++
+++  it("creates a SavedReport and returns its id", async () => {
+++    auth.mockResolvedValue({ userId: "user_123" });
+++    getDb.mockReturnValue({});
+++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+++    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+++
+++    const report = {
+++      address: VALID_ADDRESS,
+++      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+++      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+++    };
+++
+++    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+++    expect(res.status).toBe(200);
+++    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+++    expect(createSavedReport).toHaveBeenCalledWith(
+++      {},
+++      "user_123",
+++      expect.objectContaining({
+++        address: VALID_ADDRESS,
+++        riskScore: 55,
+++        riskTier: "high",
+++        confidence: 92,
+++        window: { lookbackDays: 90 },
+++      }),
+++    );
+++  });
+++});
++diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
++new file mode 100644
++index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
++--- /dev/null
+++++ b/src/app/api/saved-reports/route.ts
++@@ -0,0 +1,130 @@
+++import { NextResponse } from "next/server";
+++import { auth } from "@clerk/nextjs/server";
+++import { z } from "zod";
+++
+++import { getDb } from "@/lib/db";
+++import { createSavedReport } from "@/lib/db/saved-reports";
+++import { getUserSettings } from "@/lib/db/user-settings";
+++import { TronAddressSchema } from "@/lib/validators";
+++
+++export const runtime = "nodejs";
+++
+++const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+++
+++const SaveReportBodySchema = z.object({
+++  address: TronAddressSchema,
+++  report: z.unknown(),
+++});
+++
+++const AnalyzeReportSchema = z
+++  .object({
+++    address: TronAddressSchema,
+++    risk: z.object({
+++      score: z.number(),
+++      tier: RiskTierSchema,
+++      confidence: z.number(),
+++    }),
+++    checks: z
+++      .object({
+++        exposure1hop: z.unknown().optional(),
+++        tracing2hop: z.unknown().optional(),
+++      })
+++      .passthrough()
+++      .optional(),
+++  })
+++  .passthrough();
+++
+++function clampInt(n: number, min: number, max: number) {
+++  return Math.max(min, Math.min(max, Math.round(n)));
+++}
+++
+++function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+++  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+++  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+++    return exposure.window;
+++  }
+++
+++  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+++  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+++    return tracing.window;
+++  }
+++
+++  return { lookbackDays: 90 };
+++}
+++
+++async function getAuthenticatedUserId(): Promise<string | null> {
+++  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+++  try {
+++    const { userId } = await auth();
+++    return userId ?? null;
+++  } catch {
+++    return null;
+++  }
+++}
+++
+++export async function POST(request: Request) {
+++  const userId = await getAuthenticatedUserId();
+++  if (!userId) {
+++    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+++  }
+++
+++  if (!process.env.ADDRESS_HASH_KEY) {
+++    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+++  }
+++
+++  const db = getDb();
+++  if (!db) {
+++    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+++  }
+++
+++  const settings = await getUserSettings(db, userId);
+++  if (!settings?.loggingEnabled) {
+++    return NextResponse.json(
+++      { error: "Saving is disabled. Enable it in Settings first." },
+++      { status: 403, headers: { "Cache-Control": "no-store" } },
+++    );
+++  }
+++
+++  let json: unknown;
+++  try {
+++    json = await request.json();
+++  } catch {
+++    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+++  }
+++
+++  const parsed = SaveReportBodySchema.safeParse(json);
+++  if (!parsed.success) {
+++    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+++  }
+++
+++  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+++  if (!reportParsed.success) {
+++    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+++  }
+++
+++  if (reportParsed.data.address !== parsed.data.address) {
+++    return NextResponse.json(
+++      { error: "Report address mismatch." },
+++      { status: 400, headers: { "Cache-Control": "no-store" } },
+++    );
+++  }
+++
+++  const report = reportParsed.data;
+++  const created = await createSavedReport(db, userId, {
+++    address: parsed.data.address,
+++    riskScore: clampInt(report.risk.score, 0, 100),
+++    riskTier: report.risk.tier,
+++    confidence: clampInt(report.risk.confidence, 0, 100),
+++    window: deriveWindow(report),
+++    reportJson: parsed.data.report,
+++  });
+++
+++  if (!created) {
+++    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+++  }
+++
+++  return NextResponse.json(
+++    { id: created.id, createdAt: created.createdAt },
+++    { status: 200, headers: { "Cache-Control": "no-store" } },
+++  );
+++}
++diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
++index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
++--- a/src/components/blacklist-checker.tsx
+++++ b/src/components/blacklist-checker.tsx
++@@ -506,6 +506,108 @@
++   );
++ }
++ 
+++function SaveReportControl({ report }: { report: ApiResponse }) {
+++  const { isLoaded, isSignedIn } = useAuth();
+++  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+++  const [saveState, setSaveState] = React.useState<
+++    | { state: "idle" }
+++    | { state: "saving" }
+++    | { state: "saved"; id?: string }
+++  >({ state: "idle" });
+++
+++  React.useEffect(() => {
+++    setSaveState({ state: "idle" });
+++  }, [report.address, report.timestamps.checkedAtIso]);
+++
+++  React.useEffect(() => {
+++    if (!isLoaded || !isSignedIn) return;
+++    let cancelled = false;
+++
+++    async function loadSettings() {
+++      try {
+++        const res = await fetch("/api/user-settings", { credentials: "include" });
+++        const json = (await res.json().catch(() => null)) as unknown;
+++        if (!res.ok || !json || typeof json !== "object") return;
+++
+++        const obj = json as Record<string, unknown>;
+++        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+++        if (cancelled) return;
+++        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+++      } catch {
+++        // ignore
+++      }
+++    }
+++
+++    loadSettings();
+++    return () => {
+++      cancelled = true;
+++    };
+++  }, [isLoaded, isSignedIn]);
+++
+++  if (!report.access?.authenticated) return null;
+++  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+++
+++  async function saveReport() {
+++    if (saveState.state === "saving" || saveState.state === "saved") return;
+++
+++    setSaveState({ state: "saving" });
+++    try {
+++      const res = await fetch("/api/saved-reports", {
+++        method: "POST",
+++        headers: { "content-type": "application/json" },
+++        credentials: "include",
+++        body: JSON.stringify({ address: report.address, report }),
+++      });
+++
+++      const json = (await res.json().catch(() => null)) as unknown;
+++      if (!res.ok) {
+++        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+++        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+++        setSaveState({ state: "idle" });
+++        return;
+++      }
+++
+++      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+++      toast.success("Report saved.");
+++      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+++    } catch {
+++      toast.error("Network error.");
+++      setSaveState({ state: "idle" });
+++    }
+++  }
+++
+++  const saving = saveState.state === "saving";
+++  const saved = saveState.state === "saved";
+++
+++  return (
+++    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+++      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+++        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+++          <div className="min-w-0">
+++            <div className="text-sm font-medium text-foreground">Save this report</div>
+++            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+++          </div>
+++          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+++            {saving ? (
+++              <>
+++                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+++                Saving…
+++              </>
+++            ) : saved ? (
+++              <>
+++                <Check className="mr-2 h-4 w-4" />
+++                Saved
+++              </>
+++            ) : (
+++              "Save"
+++            )}
+++          </Button>
+++        </CardContent>
+++      </Card>
+++    </motion.div>
+++  );
+++}
+++
++ /* ────────────────────────────────────────────────────────────────────────────
++  * Main Component
++  * ──────────────────────────────────────────────────────────────────────────── */
++@@ -963,6 +1065,12 @@
++                 {/* Status Banner */}
++                 <StatusBanner data={load.data} />
++ 
+++                {clerkEnabled && (
+++                  <SignedIn>
+++                    <SaveReportControl report={load.data} />
+++                  </SignedIn>
+++                )}
+++
++                 {/* Summary Card */}
++                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
++                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
++diff --git a/middleware.ts b/src/middleware.ts
++index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..078996501b70d8cda7ce43e7ec365481c2b6d808
++--- a/middleware.ts
+++++ b/src/middleware.ts
++@@ -1,23 +1,24 @@
++ import { NextResponse } from "next/server";
++ import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
++ 
++-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
+++// Note: when using `src/app`, Next expects middleware under `src/` as well.
+++const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
++ 
++ const isPublicRoute = createRouteMatcher([
++   "/",
++   "/api/check",
++   "/api/analyze",
++   "/api/user-settings",
+++  "/api/saved-reports",
++   "/sign-in(.*)",
++   "/sign-up(.*)",
++ ]);
++ 
++-const clerk = clerkMiddleware((auth, req) => {
+++const clerk = clerkMiddleware(async (auth, req) => {
+++  const { userId, redirectToSignIn } = await auth();
++   if (isPublicRoute(req)) return;
++-  return auth().then(({ userId, redirectToSignIn }) => {
++-    if (!userId) return redirectToSignIn();
++-    return undefined;
++-  });
+++  if (!userId) return redirectToSignIn();
+++  return undefined;
++ });
++ 
++ export default clerkEnabled ? clerk : () => NextResponse.next();
++
++file update:
++diff --git a/.ralph/runs/run-20260123-135210-55147-iter-1.log b/.ralph/runs/run-20260123-135210-55147-iter-1.log
++index ad4c4c1a37085a0cbd6f501aebc6fd931f8fa83c..8ff13182c69ae44725abb1e2976f05d93f4e63a2
++--- a/.ralph/runs/run-20260123-135210-55147-iter-1.log
+++++ b/.ralph/runs/run-20260123-135210-55147-iter-1.log
++@@ -7796,8 +7796,8 @@
++ NEXT_PUBLIC_SITE_URL=https://usdt.chikocorp.com
++ 
++ # Clerk (auth)
++-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++-CLERK_SECRET_KEY=<redacted>
+++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+++CLERK_SECRET_KEY=<redacted>
++ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
++ NEXT_PUBLIC_CLERK_SIGN_UP_URL=/sign-up
++ NEXT_PUBLIC_CLERK_AFTER_SIGN_IN_URL=/
++@@ -41897,3 +41897,228 @@
++ **Avoiding sensitive information leaks**
++ 
++ I need to ensure we don’t commit any `.env` contents in the future. It’s already done, but I’ll note that any secrets should be redacted in the progress log. The log file will stay untracked after I edit it with `apply_patch`, but I can commit it later. I also considered checking older logs for secrets, but that may not be necessary. I’ll check the `.ralph/.tmp/prompt` file for safety, but it seems fine, so we can go ahead and patch the run log.
+++file update
+++M /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-135210-55147-iter-1.log
+++@@ -7798,4 +7798,4 @@
+++ # Clerk (auth)
+++-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+++-CLERK_SECRET_KEY=<redacted>
++++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++++CLERK_SECRET_KEY=<redacted>
+++ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
+++                                                                                    apply_patch(auto_approved=true) exited 0 in 72ms:
+++Success. Updated the following files:
+++M .ralph/runs/run-20260123-135210-55147-iter-1.log
+++file update:
+++diff --git a/.ralph/runs/run-20260123-135210-55147-iter-1.log b/.ralph/runs/run-20260123-135210-55147-iter-1.log
+++index ad4c4c1a37085a0cbd6f501aebc6fd931f8fa83c..fd591bb7283ace1b8f8af92e2899bbc866e576a9
+++--- a/.ralph/runs/run-20260123-135210-55147-iter-1.log
++++++ b/.ralph/runs/run-20260123-135210-55147-iter-1.log
+++@@ -7796,8 +7796,8 @@
+++ NEXT_PUBLIC_SITE_URL=https://usdt.chikocorp.com
+++ 
+++ # Clerk (auth)
+++-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+++-CLERK_SECRET_KEY=<redacted>
++++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++++CLERK_SECRET_KEY=<redacted>
+++ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
+++ NEXT_PUBLIC_CLERK_SIGN_UP_URL=/sign-up
+++ NEXT_PUBLIC_CLERK_AFTER_SIGN_IN_URL=/
+++@@ -41897,3 +41897,12 @@
+++ **Avoiding sensitive information leaks**
+++ 
+++ I need to ensure we don’t commit any `.env` contents in the future. It’s already done, but I’ll note that any secrets should be redacted in the progress log. The log file will stay untracked after I edit it with `apply_patch`, but I can commit it later. I also considered checking older logs for secrets, but that may not be necessary. I’ll check the `.ralph/.tmp/prompt` file for safety, but it seems fine, so we can go ahead and patch the run log.
++++file update
++++M /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-135210-55147-iter-1.log
++++@@ -7798,4 +7798,4 @@
++++ # Clerk (auth)
++++-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++++-CLERK_SECRET_KEY=<redacted>
+++++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+++++CLERK_SECRET_KEY=<redacted>
++++ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
+++diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
+++new file mode 100644
+++index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
+++--- /dev/null
++++++ b/src/__tests__/api-saved-reports.test.ts
+++@@ -0,0 +1,107 @@
++++import { beforeEach, describe, expect, it, vi } from "vitest";
++++
++++const auth = vi.fn();
++++vi.mock("@clerk/nextjs/server", () => ({ auth }));
++++
++++const getDb = vi.fn();
++++vi.mock("@/lib/db", () => ({ getDb }));
++++
++++const getUserSettings = vi.fn();
++++vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
++++
++++const createSavedReport = vi.fn();
++++vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
++++
++++const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
++++
++++async function callPost(body: unknown) {
++++  const { POST } = await import("@/app/api/saved-reports/route");
++++  const req = new Request("http://localhost/api/saved-reports", {
++++    method: "POST",
++++    headers: { "content-type": "application/json" },
++++    body: JSON.stringify(body),
++++  });
++++  const res = await POST(req);
++++  const json = await res.json().catch(() => null);
++++  return { res, json };
++++}
++++
++++beforeEach(() => {
++++  vi.resetModules();
++++  vi.clearAllMocks();
++++  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
++++  process.env.CLERK_SECRET_KEY = "sk_test_123";
++++  process.env.ADDRESS_HASH_KEY = "test_hash_key";
++++});
++++
++++describe("/api/saved-reports", () => {
++++  it("returns 401 when unauthenticated and does not touch the DB", async () => {
++++    auth.mockResolvedValue({ userId: null });
++++
++++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
++++    expect(res.status).toBe(401);
++++    expect(getDb).not.toHaveBeenCalled();
++++    expect(getUserSettings).not.toHaveBeenCalled();
++++    expect(createSavedReport).not.toHaveBeenCalled();
++++  });
++++
++++  it("returns 503 when persistence is disabled", async () => {
++++    auth.mockResolvedValue({ userId: "user_123" });
++++    getDb.mockReturnValue(null);
++++
++++    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
++++    expect(res.status).toBe(503);
++++    expect(json?.error).toBeTypeOf("string");
++++    expect(getUserSettings).not.toHaveBeenCalled();
++++    expect(createSavedReport).not.toHaveBeenCalled();
++++  });
++++
++++  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
++++    auth.mockResolvedValue({ userId: "user_123" });
++++    getDb.mockReturnValue({});
++++    getUserSettings.mockResolvedValue({ loggingEnabled: false });
++++
++++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
++++    expect(res.status).toBe(403);
++++    expect(createSavedReport).not.toHaveBeenCalled();
++++  });
++++
++++  it("validates payload and rejects mismatched report addresses", async () => {
++++    auth.mockResolvedValue({ userId: "user_123" });
++++    getDb.mockReturnValue({});
++++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
++++
++++    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
++++    const { res } = await callPost({ address: VALID_ADDRESS, report });
++++    expect(res.status).toBe(400);
++++    expect(createSavedReport).not.toHaveBeenCalled();
++++  });
++++
++++  it("creates a SavedReport and returns its id", async () => {
++++    auth.mockResolvedValue({ userId: "user_123" });
++++    getDb.mockReturnValue({});
++++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
++++    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
++++
++++    const report = {
++++      address: VALID_ADDRESS,
++++      risk: { score: 55.2, tier: "high", confidence: 91.7 },
++++      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
++++    };
++++
++++    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
++++    expect(res.status).toBe(200);
++++    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
++++    expect(createSavedReport).toHaveBeenCalledWith(
++++      {},
++++      "user_123",
++++      expect.objectContaining({
++++        address: VALID_ADDRESS,
++++        riskScore: 55,
++++        riskTier: "high",
++++        confidence: 92,
++++        window: { lookbackDays: 90 },
++++      }),
++++    );
++++  });
++++});
+++diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
+++new file mode 100644
+++index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
+++--- /dev/null
++++++ b/src/app/api/saved-reports/route.ts
+++@@ -0,0 +1,130 @@
++++import { NextResponse } from "next/server";
++++import { auth } from "@clerk/nextjs/server";
++++import { z } from "zod";
++++
++++import { getDb } from "@/lib/db";
++++import { createSavedReport } from "@/lib/db/saved-reports";
++++import { getUserSettings } from "@/lib/db/user-settings";
++++import { TronAddressSchema } from "@/lib/validators";
++++
++++export const runtime = "nodejs";
++++
++++const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
++++
++++const SaveReportBodySchema = z.object({
++++  address: TronAddressSchema,
++++  report: z.unknown(),
++++});
++++
++++const AnalyzeReportSchema = z
++++  .object({
++++    address: TronAddressSchema,
++++    risk: z.object({
++++      score: z.number(),
++++      tier: RiskTierSchema,
++++      confidence: z.number(),
++++    }),
++++    checks: z
++++      .object({
++++        exposure1hop: z.unknown().optional(),
++++        tracing2hop: z.unknown().optional(),
++++      })
++++      .passthrough()
++++      .optional(),
++++  })
++++  .passthrough();
++++
++++function clampInt(n: number, min: number, max: number) {
++++  return Math.max(min, Math.min(max, Math.round(n)));
++++}
++++
++++function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
++++  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
++++  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
++++    return exposure.window;
++++  }
++++
++++  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
++++  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
++++    return tracing.window;
++++  }
++++
++++  return { lookbackDays: 90 };
++++}
++++
++++async function getAuthenticatedUserId(): Promise<string | null> {
++++  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
++++  try {
++++    const { userId } = await auth();
++++    return userId ?? null;
++++  } catch {
++++    return null;
++++  }
++++}
++++
++++export async functi
++\ No newline at end of file
++diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
++new file mode 100644
++index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
++--- /dev/null
+++++ b/src/__tests__/api-saved-reports.test.ts
++@@ -0,0 +1,107 @@
+++import { beforeEach, describe, expect, it, vi } from "vitest";
+++
+++const auth = vi.fn();
+++vi.mock("@clerk/nextjs/server", () => ({ auth }));
+++
+++const getDb = vi.fn();
+++vi.mock("@/lib/db", () => ({ getDb }));
+++
+++const getUserSettings = vi.fn();
+++vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+++
+++const createSavedReport = vi.fn();
+++vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+++
+++const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+++
+++async function callPost(body: unknown) {
+++  const { POST } = await import("@/app/api/saved-reports/route");
+++  const req = new Request("http://localhost/api/saved-reports", {
+++    method: "POST",
+++    headers: { "content-type": "application/json" },
+++    body: JSON.stringify(body),
+++  });
+++  const res = await POST(req);
+++  const json = await res.json().catch(() => null);
+++  return { res, json };
+++}
+++
+++beforeEach(() => {
+++  vi.resetModules();
+++  vi.clearAllMocks();
+++  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+++  process.env.CLERK_SECRET_KEY = "sk_test_123";
+++  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+++});
+++
+++describe("/api/saved-reports", () => {
+++  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+++    auth.mockResolvedValue({ userId: null });
+++
+++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+++    expect(res.status).toBe(401);
+++    expect(getDb).not.toHaveBeenCalled();
+++    expect(getUserSettings).not.toHaveBeenCalled();
+++    expect(createSavedReport).not.toHaveBeenCalled();
+++  });
+++
+++  it("returns 503 when persistence is disabled", async () => {
+++    auth.mockResolvedValue({ userId: "user_123" });
+++    getDb.mockReturnValue(null);
+++
+++    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+++    expect(res.status).toBe(503);
+++    expect(json?.error).toBeTypeOf("string");
+++    expect(getUserSettings).not.toHaveBeenCalled();
+++    expect(createSavedReport).not.toHaveBeenCalled();
+++  });
+++
+++  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+++    auth.mockResolvedValue({ userId: "user_123" });
+++    getDb.mockReturnValue({});
+++    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+++
+++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+++    expect(res.status).toBe(403);
+++    expect(createSavedReport).not.toHaveBeenCalled();
+++  });
+++
+++  it("validates payload and rejects mismatched report addresses", async () => {
+++    auth.mockResolvedValue({ userId: "user_123" });
+++    getDb.mockReturnValue({});
+++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+++
+++    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+++    const { res } = await callPost({ address: VALID_ADDRESS, report });
+++    expect(res.status).toBe(400);
+++    expect(createSavedReport).not.toHaveBeenCalled();
+++  });
+++
+++  it("creates a SavedReport and returns its id", async () => {
+++    auth.mockResolvedValue({ userId: "user_123" });
+++    getDb.mockReturnValue({});
+++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+++    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+++
+++    const report = {
+++      address: VALID_ADDRESS,
+++      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+++      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+++    };
+++
+++    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+++    expect(res.status).toBe(200);
+++    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+++    expect(createSavedReport).toHaveBeenCalledWith(
+++      {},
+++      "user_123",
+++      expect.objectContaining({
+++        address: VALID_ADDRESS,
+++        riskScore: 55,
+++        riskTier: "high",
+++        confidence: 92,
+++        window: { lookbackDays: 90 },
+++      }),
+++    );
+++  });
+++});
++diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
++new file mode 100644
++index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
++--- /dev/null
+++++ b/src/app/api/saved-reports/route.ts
++@@ -0,0 +1,130 @@
+++import { NextResponse } from "next/server";
+++import { auth } from "@clerk/nextjs/server";
+++import { z } from "zod";
+++
+++import { getDb } from "@/lib/db";
+++import { createSavedReport } from "@/lib/db/saved-reports";
+++import { getUserSettings } from "@/lib/db/user-settings";
+++import { TronAddressSchema } from "@/lib/validators";
+++
+++export const runtime = "nodejs";
+++
+++const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+++
+++const SaveReportBodySchema = z.object({
+++  address: TronAddressSchema,
+++  report: z.unknown(),
+++});
+++
+++const AnalyzeReportSchema = z
+++  .object({
+++    address: TronAddressSchema,
+++    risk: z.object({
+++      score: z.number(),
+++      tier: RiskTierSchema,
+++      confidence: z.number(),
+++    }),
+++    checks: z
+++      .object({
+++        exposure1hop: z.unknown().optional(),
+++        tracing2hop: z.unknown().optional(),
+++      })
+++      .passthrough()
+++      .optional(),
+++  })
+++  .passthrough();
+++
+++function clampInt(n: number, min: number, max: number) {
+++  return Math.max(min, Math.min(max, Math.round(n)));
+++}
+++
+++function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+++  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+++  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+++    return exposure.window;
+++  }
+++
+++  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+++  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+++    return tracing.window;
+++  }
+++
+++  return { lookbackDays: 90 };
+++}
+++
+++async function getAuthenticatedUserId(): Promise<string | null> {
+++  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+++  try {
+++    const { userId } = await auth();
+++    return userId ?? null;
+++  } catch {
+++    return null;
+++  }
+++}
+++
+++export async function POST(request: Request) {
+++  const userId = await getAuthenticatedUserId();
+++  if (!userId) {
+++    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+++  }
+++
+++  if (!process.env.ADDRESS_HASH_KEY) {
+++    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+++  }
+++
+++  const db = getDb();
+++  if (!db) {
+++    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+++  }
+++
+++  const settings = await getUserSettings(db, userId);
+++  if (!settings?.loggingEnabled) {
+++    return NextResponse.json(
+++      { error: "Saving is disabled. Enable it in Settings first." },
+++      { status: 403, headers: { "Cache-Control": "no-store" } },
+++    );
+++  }
+++
+++  let json: unknown;
+++  try {
+++    json = await request.json();
+++  } catch {
+++    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+++  }
+++
+++  const parsed = SaveReportBodySchema.safeParse(json);
+++  if (!parsed.success) {
+++    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+++  }
+++
+++  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+++  if (!reportParsed.success) {
+++    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+++  }
+++
+++  if (reportParsed.data.address !== parsed.data.address) {
+++    return NextResponse.json(
+++      { error: "Report address mismatch." },
+++      { status: 400, headers: { "Cache-Control": "no-store" } },
+++    );
+++  }
+++
+++  const report = reportParsed.data;
+++  const created = await createSavedReport(db, userId, {
+++    address: parsed.data.address,
+++    riskScore: clampInt(report.risk.score, 0, 100),
+++    riskTier: report.risk.tier,
+++    confidence: clampInt(report.risk.confidence, 0, 100),
+++    window: deriveWindow(report),
+++    reportJson: parsed.data.report,
+++  });
+++
+++  if (!created) {
+++    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+++  }
+++
+++  return NextResponse.json(
+++    { id: created.id, createdAt: created.createdAt },
+++    { status: 200, headers: { "Cache-Control": "no-store" } },
+++  );
+++}
++diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
++index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
++--- a/src/components/blacklist-checker.tsx
+++++ b/src/components/blacklist-checker.tsx
++@@ -506,6 +506,108 @@
++   );
++ }
++ 
+++function SaveReportControl({ report }: { report: ApiResponse }) {
+++  const { isLoaded, isSignedIn } = useAuth();
+++  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+++  const [saveState, setSaveState] = React.useState<
+++    | { state: "idle" }
+++    | { state: "saving" }
+++    | { state: "saved"; id?: string }
+++  >({ state: "idle" });
+++
+++  React.useEffect(() => {
+++    setSaveState({ state: "idle" });
+++  }, [report.address, report.timestamps.checkedAtIso]);
+++
+++  React.useEffect(() => {
+++    if (!isLoaded || !isSignedIn) return;
+++    let cancelled = false;
+++
+++    async function loadSettings() {
+++      try {
+++        const res = await fetch("/api/user-settings", { credentials: "include" });
+++        const json = (await res.json().catch(() => null)) as unknown;
+++        if (!res.ok || !json || typeof json !== "object") return;
+++
+++        const obj = json as Record<string, unknown>;
+++        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+++        if (cancelled) return;
+++        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+++      } catch {
+++        // ignore
+++      }
+++    }
+++
+++    loadSettings();
+++    return () => {
+++      cancelled = true;
+++    };
+++  }, [isLoaded, isSignedIn]);
+++
+++  if (!report.access?.authenticated) return null;
+++  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+++
+++  async function saveReport() {
+++    if (saveState.state === "saving" || saveState.state === "saved") return;
+++
+++    setSaveState({ state: "saving" });
+++    try {
+++      const res = await fetch("/api/saved-reports", {
+++        method: "POST",
+++        headers: { "content-type": "application/json" },
+++        credentials: "include",
+++        body: JSON.stringify({ address: report.address, report }),
+++      });
+++
+++      const json = (await res.json().catch(() => null)) as unknown;
+++      if (!res.ok) {
+++        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+++        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+++        setSaveState({ state: "idle" });
+++        return;
+++      }
+++
+++      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+++      toast.success("Report saved.");
+++      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+++    } catch {
+++      toast.error("Network error.");
+++      setSaveState({ state: "idle" });
+++    }
+++  }
+++
+++  const saving = saveState.state === "saving";
+++  const saved = saveState.state === "saved";
+++
+++  return (
+++    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+++      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+++        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+++          <div className="min-w-0">
+++            <div className="text-sm font-medium text-foreground">Save this report</div>
+++            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+++          </div>
+++          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+++            {saving ? (
+++              <>
+++                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+++                Saving…
+++              </>
+++            ) : saved ? (
+++              <>
+++                <Check className="mr-2 h-4 w-4" />
+++                Saved
+++              </>
+++            ) : (
+++              "Save"
+++            )}
+++          </Button>
+++        </CardContent>
+++      </Card>
+++    </motion.div>
+++  );
+++}
+++
++ /* ────────────────────────────────────────────────────────────────────────────
++  * Main Component
++  * ──────────────────────────────────────────────────────────────────────────── */
++@@ -963,6 +1065,12 @@
++                 {/* Status Banner */}
++                 <StatusBanner data={load.data} />
++ 
+++                {clerkEnabled && (
+++                  <SignedIn>
+++                    <SaveReportControl report={load.data} />
+++                  </SignedIn>
+++                )}
+++
++                 {/* Summary Card */}
++                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
++                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
++diff --git a/middleware.ts b/src/middleware.ts
++index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..078996501b70d8cda7ce43e7ec365481c2b6d808
++--- a/middleware.ts
+++++ b/src/middleware.ts
++@@ -1,23 +1,24 @@
++ import { NextResponse } from "next/server";
++ import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
++ 
++-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
+++// Note: when using `src/app`, Next expects middleware under `src/` as well.
+++const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
++ 
++ const isPublicRoute = createRouteMatcher([
++   "/",
++   "/api/check",
++   "/api/analyze",
++   "/api/user-settings",
+++  "/api/saved-reports",
++   "/sign-in(.*)",
++   "/sign-up(.*)",
++ ]);
++ 
++-const clerk = clerkMiddleware((auth, req) => {
+++const clerk = clerkMiddleware(async (auth, req) => {
+++  const { userId, redirectToSignIn } = await auth();
++   if (isPublicRoute(req)) return;
++-  return auth().then(({ userId, redirectToSignIn }) => {
++-    if (!userId) return redirectToSignIn();
++-    return undefined;
++-  });
+++  if (!userId) return redirectToSignIn();
+++  return undefined;
++ });
++ 
++ export default clerkEnabled ? clerk : () => NextResponse.next();
++
++exec
++/bin/zsh -lc 'rg -n "sk_test_|pk_test_a25v|CLERK_SECRET_KEY=sk_test|NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=pk_test" .ralph/runs/run-20260123-135210-55147-iter-1.log || true' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 76ms:
++3309:  process.env.CLERK_SECRET_KEY = "sk_test_123";
++3438:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++3824:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++4213:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++4608:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++5008:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++5405:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++5813:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++6221:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++6610:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++7005:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++7413:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++7860:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++8256:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++8669:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++9077:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++9478:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++9867:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++10213:   process.env.CLERK_SECRET_KEY = "sk_test_123";
++10273:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
+new file mode 100644
+index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
+--- /dev/null
++++ b/src/__tests__/api-saved-reports.test.ts
+@@ -0,0 +1,107 @@
++import { beforeEach, describe, expect, it, vi } from "vitest";
++
++const auth = vi.fn();
++vi.mock("@clerk/nextjs/server", () => ({ auth }));
++
++const getDb = vi.fn();
++vi.mock("@/lib/db", () => ({ getDb }));
++
++const getUserSettings = vi.fn();
++vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
++
++const createSavedReport = vi.fn();
++vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
++
++const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
++
++async function callPost(body: unknown) {
++  const { POST } = await import("@/app/api/saved-reports/route");
++  const req = new Request("http://localhost/api/saved-reports", {
++    method: "POST",
++    headers: { "content-type": "application/json" },
++    body: JSON.stringify(body),
++  });
++  const res = await POST(req);
++  const json = await res.json().catch(() => null);
++  return { res, json };
++}
++
++beforeEach(() => {
++  vi.resetModules();
++  vi.clearAllMocks();
++  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
++  process.env.CLERK_SECRET_KEY = "sk_test_123";
++  process.env.ADDRESS_HASH_KEY = "test_hash_key";
++});
++
++describe("/api/saved-reports", () => {
++  it("returns 401 when unauthenticated and does not touch the DB", async () => {
++    auth.mockResolvedValue({ userId: null });
++
++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
++    expect(res.status).toBe(401);
++    expect(getDb).not.toHaveBeenCalled();
++    expect(getUserSettings).not.toHaveBeenCalled();
++    expect(createSavedReport).not.toHaveBeenCalled();
++  });
++
++  it("returns 503 when persistence is disabled", async () => {
++    auth.mockResolvedValue({ userId: "user_123" });
++    getDb.mockReturnValue(null);
++
++    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
++    expect(res.status).toBe(503);
++    expect(json?.error).toBeTypeOf("string");
++    expect(getUserSettings).not.toHaveBeenCalled();
++    expect(createSavedReport).not.toHaveBeenCalled();
++  });
++
++  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
++    auth.mockResolvedValue({ userId: "user_123" });
++    getDb.mockReturnValue({});
++    getUserSettings.mockResolvedValue({ loggingEnabled: false });
++
++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
++    expect(res.status).toBe(403);
++    expect(createSavedReport).not.toHaveBeenCalled();
++  });
++
++  it("validates payload and rejects mismatched report addresses", async () => {
++    auth.mockResolvedValue({ userId: "user_123" });
++    getDb.mockReturnValue({});
++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
++
++    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
++    const { res } = await callPost({ address: VALID_ADDRESS, report });
++    expect(res.status).toBe(400);
++    expect(createSavedReport).not.toHaveBeenCalled();
++  });
++
++  it("creates a SavedReport and returns its id", async () => {
++    auth.mockResolvedValue({ userId: "user_123" });
++    getDb.mockReturnValue({});
++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
++    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
++
++    const report = {
++      address: VALID_ADDRESS,
++      risk: { score: 55.2, tier: "high", confidence: 91.7 },
++      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
++    };
++
++    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
++    expect(res.status).toBe(200);
++    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
++    expect(createSavedReport).toHaveBeenCalledWith(
++      {},
++      "user_123",
++      expect.objectContaining({
++        address: VALID_ADDRESS,
++        riskScore: 55,
++        riskTier: "high",
++        confidence: 92,
++        window: { lookbackDays: 90 },
++      }),
++    );
++  });
++});
+diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
+new file mode 100644
+index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
+--- /dev/null
++++ b/src/app/api/saved-reports/route.ts
+@@ -0,0 +1,130 @@
++import { NextResponse } from "next/server";
++import { auth } from "@clerk/nextjs/server";
++import { z } from "zod";
++
++import { getDb } from "@/lib/db";
++import { createSavedReport } from "@/lib/db/saved-reports";
++import { getUserSettings } from "@/lib/db/user-settings";
++import { TronAddressSchema } from "@/lib/validators";
++
++export const runtime = "nodejs";
++
++const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
++
++const SaveReportBodySchema = z.object({
++  address: TronAddressSchema,
++  report: z.unknown(),
++});
++
++const AnalyzeReportSchema = z
++  .object({
++    address: TronAddressSchema,
++    risk: z.object({
++      score: z.number(),
++      tier: RiskTierSchema,
++      confidence: z.number(),
++    }),
++    checks: z
++      .object({
++        exposure1hop: z.unknown().optional(),
++        tracing2hop: z.unknown().optional(),
++      })
++      .passthrough()
++      .optional(),
++  })
++  .passthrough();
++
++function clampInt(n: number, min: number, max: number) {
++  return Math.max(min, Math.min(max, Math.round(n)));
++}
++
++function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
++  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
++  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
++    return exposure.window;
++  }
++
++  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
++  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
++    return tracing.window;
++  }
++
++  return { lookbackDays: 90 };
++}
++
++async function getAuthenticatedUserId(): Promise<string | null> {
++  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
++  try {
++    const { userId } = await auth();
++    return userId ?? null;
++  } catch {
++    return null;
++  }
++}
++
++export async function POST(request: Request) {
++  const userId = await getAuthenticatedUserId();
++  if (!userId) {
++    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
++  }
++
++  if (!process.env.ADDRESS_HASH_KEY) {
++    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
++  }
++
++  const db = getDb();
++  if (!db) {
++    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
++  }
++
++  const settings = await getUserSettings(db, userId);
++  if (!settings?.loggingEnabled) {
++    return NextResponse.json(
++      { error: "Saving is disabled. Enable it in Settings first." },
++      { status: 403, headers: { "Cache-Control": "no-store" } },
++    );
++  }
++
++  let json: unknown;
++  try {
++    json = await request.json();
++  } catch {
++    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
++  }
++
++  const parsed = SaveReportBodySchema.safeParse(json);
++  if (!parsed.success) {
++    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
++  }
++
++  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
++  if (!reportParsed.success) {
++    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
++  }
++
++  if (reportParsed.data.address !== parsed.data.address) {
++    return NextResponse.json(
++      { error: "Report address mismatch." },
++      { status: 400, headers: { "Cache-Control": "no-store" } },
++    );
++  }
++
++  const report = reportParsed.data;
++  const created = await createSavedReport(db, userId, {
++    address: parsed.data.address,
++    riskScore: clampInt(report.risk.score, 0, 100),
++    riskTier: report.risk.tier,
++    confidence: clampInt(report.risk.confidence, 0, 100),
++    window: deriveWindow(report),
++    reportJson: parsed.data.report,
++  });
++
++  if (!created) {
++    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
++  }
++
++  return NextResponse.json(
++    { id: created.id, createdAt: created.createdAt },
++    { status: 200, headers: { "Cache-Control": "no-store" } },
++  );
++}
+diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
+index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
+--- a/src/components/blacklist-checker.tsx
++++ b/src/components/blacklist-checker.tsx
+@@ -506,6 +506,108 @@
+   );
+ }
+ 
++function SaveReportControl({ report }: { report: ApiResponse }) {
++  const { isLoaded, isSignedIn } = useAuth();
++  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
++  const [saveState, setSaveState] = React.useState<
++    | { state: "idle" }
++    | { state: "saving" }
++    | { state: "saved"; id?: string }
++  >({ state: "idle" });
++
++  React.useEffect(() => {
++    setSaveState({ state: "idle" });
++  }, [report.address, report.timestamps.checkedAtIso]);
++
++  React.useEffect(() => {
++    if (!isLoaded || !isSignedIn) return;
++    let cancelled = false;
++
++    async function loadSettings() {
++      try {
++        const res = await fetch("/api/user-settings", { credentials: "include" });
++        const json = (await res.json().catch(() => null)) as unknown;
++        if (!res.ok || !json || typeof json !== "object") return;
++
++        const obj = json as Record<string, unknown>;
++        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
++        if (cancelled) return;
++        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
++      } catch {
++        // ignore
++      }
++    }
++
++    loadSettings();
++    return () => {
++      cancelled = true;
++    };
++  }, [isLoaded, isSignedIn]);
++
++  if (!report.access?.authenticated) return null;
++  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
++
++  async function saveReport() {
++    if (saveState.state === "saving" || saveState.state === "saved") return;
++
++    setSaveState({ state: "saving" });
++    try {
++      const res = await fetch("/api/saved-reports", {
++        method: "POST",
++        headers: { "content-type": "application/json" },
++        credentials: "include",
++        body: JSON.stringify({ address: report.address, report }),
++      });
++
++      const json = (await res.json().catch(() => null)) as unknown;
++      if (!res.ok) {
++        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
++        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
++        setSaveState({ state: "idle" });
++        return;
++      }
++
++      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
++      toast.success("Report saved.");
++      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
++    } catch {
++      toast.error("Network error.");
++      setSaveState({ state: "idle" });
++    }
++  }
++
++  const saving = saveState.state === "saving";
++  const saved = saveState.state === "saved";
++
++  return (
++    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
++      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
++        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
++          <div className="min-w-0">
++            <div className="text-sm font-medium text-foreground">Save this report</div>
++            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
++          </div>
++          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
++            {saving ? (
++              <>
++                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
++                Saving…
++              </>
++            ) : saved ? (
++              <>
++                <Check className="mr-2 h-4 w-4" />
++                Saved
++              </>
++            ) : (
++              "Save"
++            )}
++          </Button>
++        </CardContent>
++      </Card>
++    </motion.div>
++  );
++}
++
+ /* ────────────────────────────────────────────────────────────────────────────
+  * Main Component
+  * ──────────────────────────────────────────────────────────────────────────── */
+@@ -963,6 +1065,12 @@
+                 {/* Status Banner */}
+                 <StatusBanner data={load.data} />
+ 
++                {clerkEnabled && (
++                  <SignedIn>
++                    <SaveReportControl report={load.data} />
++                  </SignedIn>
++                )}
++
+                 {/* Summary Card */}
+                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+diff --git a/middleware.ts b/src/middleware.ts
+index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..078996501b70d8cda7ce43e7ec365481c2b6d808
+--- a/middleware.ts
++++ b/src/middleware.ts
+@@ -1,23 +1,24 @@
+ import { NextResponse } from "next/server";
+ import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
+ 
+-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
++// Note: when using `src/app`, Next expects middleware under `src/` as well.
++const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
+ 
+ const isPublicRoute = createRouteMatcher([
+   "/",
+   "/api/check",
+   "/api/analyze",
+   "/api/user-settings",
++  "/api/saved-reports",
+   "/sign-in(.*)",
+   "/sign-up(.*)",
+ ]);
+ 
+-const clerk = clerkMiddleware((auth, req) => {
++const clerk = clerkMiddleware(async (auth, req) => {
++  const { userId, redirectToSignIn } = await auth();
+   if (isPublicRoute(req)) return;
+-  return auth().then(({ userId, redirectToSignIn }) => {
+-    if (!userId) return redirectToSignIn();
+-    return undefined;
+-  });
++  if (!userId) return redirectToSignIn();
++  return undefined;
+ });
+ 
+ export default clerkEnabled ? clerk : () => NextResponse.next();
+
+exec
+/bin/zsh -lc 'rg -n "<redacted>|<redacted>" .ralph/runs/run-20260123-135210-55147-iter-1.log || true' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 75ms:
+binary file matches (found "\0" byte around offset 1724417)
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
diff --git a/middleware.ts b/src/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..078996501b70d8cda7ce43e7ec365481c2b6d808
--- a/middleware.ts
+++ b/src/middleware.ts
@@ -1,23 +1,24 @@
 import { NextResponse } from "next/server";
 import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
 
-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
+// Note: when using `src/app`, Next expects middleware under `src/` as well.
+const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
 
 const isPublicRoute = createRouteMatcher([
   "/",
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
 
-const clerk = clerkMiddleware((auth, req) => {
+const clerk = clerkMiddleware(async (auth, req) => {
+  const { userId, redirectToSignIn } = await auth();
   if (isPublicRoute(req)) return;
-  return auth().then(({ userId, redirectToSignIn }) => {
-    if (!userId) return redirectToSignIn();
-    return undefined;
-  });
+  if (!userId) return redirectToSignIn();
+  return undefined;
 });
 
 export default clerkEnabled ? clerk : () => NextResponse.next();


thinking
**Adjusting file matches**

I noticed that `rg` is reporting binary file matches because of a null byte, which throws things off. To get around this, I can use the command `rg -a` to treat the files as text. That should help solve the issue! I'll go ahead and try it out to see if it works as I expect. Hopefully, this will clean up the results and make it easier to work with. Let's give it a shot!
exec
/bin/zsh -lc 'rg -a -n "<redacted>|<redacted>" .ralph/runs/run-20260123-135210-55147-iter-1.log || true' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 64ms:
41469:NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
41470:CLERK_SECRET_KEY=<redacted>
41904:-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
41905:-CLERK_SECRET_KEY=<redacted>
41921:-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
41922:-CLERK_SECRET_KEY=<redacted>
41936:+-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
41937:+-CLERK_SECRET_KEY=<redacted>
42361:-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
42362:-CLERK_SECRET_KEY=<redacted>
42376:+-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
42377:+-CLERK_SECRET_KEY=<redacted>
42393:+-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
42394:+-CLERK_SECRET_KEY=<redacted>
42408:++-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
42409:++-CLERK_SECRET_KEY=<redacted>
43040:-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
43041:-CLERK_SECRET_KEY=<redacted>
43055:+-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
43056:+-CLERK_SECRET_KEY=<redacted>
file update:
diff --git a/.ralph/runs/run-20260123-135210-55147-iter-1.log b/.ralph/runs/run-20260123-135210-55147-iter-1.log
index ad4c4c1a37085a0cbd6f501aebc6fd931f8fa83c..ecc02bb5b04d9c6df667450d1ffebeca134d3d6c
--- a/.ralph/runs/run-20260123-135210-55147-iter-1.log
+++ b/.ralph/runs/run-20260123-135210-55147-iter-1.log
@@ -7796,8 +7796,8 @@
 NEXT_PUBLIC_SITE_URL=https://usdt.chikocorp.com
 
 # Clerk (auth)
-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
-CLERK_SECRET_KEY=<redacted>
+NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+CLERK_SECRET_KEY=<redacted>
 NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
 NEXT_PUBLIC_CLERK_SIGN_UP_URL=/sign-up
 NEXT_PUBLIC_CLERK_AFTER_SIGN_IN_URL=/
@@ -41897,3 +41897,5853 @@
 **Avoiding sensitive information leaks**
 
 I need to ensure we don’t commit any `.env` contents in the future. It’s already done, but I’ll note that any secrets should be redacted in the progress log. The log file will stay untracked after I edit it with `apply_patch`, but I can commit it later. I also considered checking older logs for secrets, but that may not be necessary. I’ll check the `.ralph/.tmp/prompt` file for safety, but it seems fine, so we can go ahead and patch the run log.
+file update
+M /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-135210-55147-iter-1.log
+@@ -7798,4 +7798,4 @@
+ # Clerk (auth)
+-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+-CLERK_SECRET_KEY=<redacted>
++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++CLERK_SECRET_KEY=<redacted>
+ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
+                                                                                    apply_patch(auto_approved=true) exited 0 in 72ms:
+Success. Updated the following files:
+M .ralph/runs/run-20260123-135210-55147-iter-1.log
+file update:
+diff --git a/.ralph/runs/run-20260123-135210-55147-iter-1.log b/.ralph/runs/run-20260123-135210-55147-iter-1.log
+index ad4c4c1a37085a0cbd6f501aebc6fd931f8fa83c..fd591bb7283ace1b8f8af92e2899bbc866e576a9
+--- a/.ralph/runs/run-20260123-135210-55147-iter-1.log
++++ b/.ralph/runs/run-20260123-135210-55147-iter-1.log
+@@ -7796,8 +7796,8 @@
+ NEXT_PUBLIC_SITE_URL=https://usdt.chikocorp.com
+ 
+ # Clerk (auth)
+-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+-CLERK_SECRET_KEY=<redacted>
++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++CLERK_SECRET_KEY=<redacted>
+ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
+ NEXT_PUBLIC_CLERK_SIGN_UP_URL=/sign-up
+ NEXT_PUBLIC_CLERK_AFTER_SIGN_IN_URL=/
+@@ -41897,3 +41897,12 @@
+ **Avoiding sensitive information leaks**
+ 
+ I need to ensure we don’t commit any `.env` contents in the future. It’s already done, but I’ll note that any secrets should be redacted in the progress log. The log file will stay untracked after I edit it with `apply_patch`, but I can commit it later. I also considered checking older logs for secrets, but that may not be necessary. I’ll check the `.ralph/.tmp/prompt` file for safety, but it seems fine, so we can go ahead and patch the run log.
++file update
++M /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-135210-55147-iter-1.log
++@@ -7798,4 +7798,4 @@
++ # Clerk (auth)
++-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++-CLERK_SECRET_KEY=<redacted>
+++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+++CLERK_SECRET_KEY=<redacted>
++ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
+diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
+new file mode 100644
+index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
+--- /dev/null
++++ b/src/__tests__/api-saved-reports.test.ts
+@@ -0,0 +1,107 @@
++import { beforeEach, describe, expect, it, vi } from "vitest";
++
++const auth = vi.fn();
++vi.mock("@clerk/nextjs/server", () => ({ auth }));
++
++const getDb = vi.fn();
++vi.mock("@/lib/db", () => ({ getDb }));
++
++const getUserSettings = vi.fn();
++vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
++
++const createSavedReport = vi.fn();
++vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
++
++const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
++
++async function callPost(body: unknown) {
++  const { POST } = await import("@/app/api/saved-reports/route");
++  const req = new Request("http://localhost/api/saved-reports", {
++    method: "POST",
++    headers: { "content-type": "application/json" },
++    body: JSON.stringify(body),
++  });
++  const res = await POST(req);
++  const json = await res.json().catch(() => null);
++  return { res, json };
++}
++
++beforeEach(() => {
++  vi.resetModules();
++  vi.clearAllMocks();
++  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
++  process.env.CLERK_SECRET_KEY = "sk_test_123";
++  process.env.ADDRESS_HASH_KEY = "test_hash_key";
++});
++
++describe("/api/saved-reports", () => {
++  it("returns 401 when unauthenticated and does not touch the DB", async () => {
++    auth.mockResolvedValue({ userId: null });
++
++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
++    expect(res.status).toBe(401);
++    expect(getDb).not.toHaveBeenCalled();
++    expect(getUserSettings).not.toHaveBeenCalled();
++    expect(createSavedReport).not.toHaveBeenCalled();
++  });
++
++  it("returns 503 when persistence is disabled", async () => {
++    auth.mockResolvedValue({ userId: "user_123" });
++    getDb.mockReturnValue(null);
++
++    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
++    expect(res.status).toBe(503);
++    expect(json?.error).toBeTypeOf("string");
++    expect(getUserSettings).not.toHaveBeenCalled();
++    expect(createSavedReport).not.toHaveBeenCalled();
++  });
++
++  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
++    auth.mockResolvedValue({ userId: "user_123" });
++    getDb.mockReturnValue({});
++    getUserSettings.mockResolvedValue({ loggingEnabled: false });
++
++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
++    expect(res.status).toBe(403);
++    expect(createSavedReport).not.toHaveBeenCalled();
++  });
++
++  it("validates payload and rejects mismatched report addresses", async () => {
++    auth.mockResolvedValue({ userId: "user_123" });
++    getDb.mockReturnValue({});
++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
++
++    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
++    const { res } = await callPost({ address: VALID_ADDRESS, report });
++    expect(res.status).toBe(400);
++    expect(createSavedReport).not.toHaveBeenCalled();
++  });
++
++  it("creates a SavedReport and returns its id", async () => {
++    auth.mockResolvedValue({ userId: "user_123" });
++    getDb.mockReturnValue({});
++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
++    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
++
++    const report = {
++      address: VALID_ADDRESS,
++      risk: { score: 55.2, tier: "high", confidence: 91.7 },
++      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
++    };
++
++    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
++    expect(res.status).toBe(200);
++    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
++    expect(createSavedReport).toHaveBeenCalledWith(
++      {},
++      "user_123",
++      expect.objectContaining({
++        address: VALID_ADDRESS,
++        riskScore: 55,
++        riskTier: "high",
++        confidence: 92,
++        window: { lookbackDays: 90 },
++      }),
++    );
++  });
++});
+diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
+new file mode 100644
+index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
+--- /dev/null
++++ b/src/app/api/saved-reports/route.ts
+@@ -0,0 +1,130 @@
++import { NextResponse } from "next/server";
++import { auth } from "@clerk/nextjs/server";
++import { z } from "zod";
++
++import { getDb } from "@/lib/db";
++import { createSavedReport } from "@/lib/db/saved-reports";
++import { getUserSettings } from "@/lib/db/user-settings";
++import { TronAddressSchema } from "@/lib/validators";
++
++export const runtime = "nodejs";
++
++const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
++
++const SaveReportBodySchema = z.object({
++  address: TronAddressSchema,
++  report: z.unknown(),
++});
++
++const AnalyzeReportSchema = z
++  .object({
++    address: TronAddressSchema,
++    risk: z.object({
++      score: z.number(),
++      tier: RiskTierSchema,
++      confidence: z.number(),
++    }),
++    checks: z
++      .object({
++        exposure1hop: z.unknown().optional(),
++        tracing2hop: z.unknown().optional(),
++      })
++      .passthrough()
++      .optional(),
++  })
++  .passthrough();
++
++function clampInt(n: number, min: number, max: number) {
++  return Math.max(min, Math.min(max, Math.round(n)));
++}
++
++function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
++  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
++  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
++    return exposure.window;
++  }
++
++  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
++  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
++    return tracing.window;
++  }
++
++  return { lookbackDays: 90 };
++}
++
++async function getAuthenticatedUserId(): Promise<string | null> {
++  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
++  try {
++    const { userId } = await auth();
++    return userId ?? null;
++  } catch {
++    return null;
++  }
++}
++
++export async function POST(request: Request) {
++  const userId = await getAuthenticatedUserId();
++  if (!userId) {
++    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
++  }
++
++  if (!process.env.ADDRESS_HASH_KEY) {
++    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
++  }
++
++  const db = getDb();
++  if (!db) {
++    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
++  }
++
++  const settings = await getUserSettings(db, userId);
++  if (!settings?.loggingEnabled) {
++    return NextResponse.json(
++      { error: "Saving is disabled. Enable it in Settings first." },
++      { status: 403, headers: { "Cache-Control": "no-store" } },
++    );
++  }
++
++  let json: unknown;
++  try {
++    json = await request.json();
++  } catch {
++    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
++  }
++
++  const parsed = SaveReportBodySchema.safeParse(json);
++  if (!parsed.success) {
++    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
++  }
++
++  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
++  if (!reportParsed.success) {
++    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
++  }
++
++  if (reportParsed.data.address !== parsed.data.address) {
++    return NextResponse.json(
++      { error: "Report address mismatch." },
++      { status: 400, headers: { "Cache-Control": "no-store" } },
++    );
++  }
++
++  const report = reportParsed.data;
++  const created = await createSavedReport(db, userId, {
++    address: parsed.data.address,
++    riskScore: clampInt(report.risk.score, 0, 100),
++    riskTier: report.risk.tier,
++    confidence: clampInt(report.risk.confidence, 0, 100),
++    window: deriveWindow(report),
++    reportJson: parsed.data.report,
++  });
++
++  if (!created) {
++    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
++  }
++
++  return NextResponse.json(
++    { id: created.id, createdAt: created.createdAt },
++    { status: 200, headers: { "Cache-Control": "no-store" } },
++  );
++}
+diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
+index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
+--- a/src/components/blacklist-checker.tsx
++++ b/src/components/blacklist-checker.tsx
+@@ -506,6 +506,108 @@
+   );
+ }
+ 
++function SaveReportControl({ report }: { report: ApiResponse }) {
++  const { isLoaded, isSignedIn } = useAuth();
++  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
++  const [saveState, setSaveState] = React.useState<
++    | { state: "idle" }
++    | { state: "saving" }
++    | { state: "saved"; id?: string }
++  >({ state: "idle" });
++
++  React.useEffect(() => {
++    setSaveState({ state: "idle" });
++  }, [report.address, report.timestamps.checkedAtIso]);
++
++  React.useEffect(() => {
++    if (!isLoaded || !isSignedIn) return;
++    let cancelled = false;
++
++    async function loadSettings() {
++      try {
++        const res = await fetch("/api/user-settings", { credentials: "include" });
++        const json = (await res.json().catch(() => null)) as unknown;
++        if (!res.ok || !json || typeof json !== "object") return;
++
++        const obj = json as Record<string, unknown>;
++        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
++        if (cancelled) return;
++        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
++      } catch {
++        // ignore
++      }
++    }
++
++    loadSettings();
++    return () => {
++      cancelled = true;
++    };
++  }, [isLoaded, isSignedIn]);
++
++  if (!report.access?.authenticated) return null;
++  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
++
++  async function saveReport() {
++    if (saveState.state === "saving" || saveState.state === "saved") return;
++
++    setSaveState({ state: "saving" });
++    try {
++      const res = await fetch("/api/saved-reports", {
++        method: "POST",
++        headers: { "content-type": "application/json" },
++        credentials: "include",
++        body: JSON.stringify({ address: report.address, report }),
++      });
++
++      const json = (await res.json().catch(() => null)) as unknown;
++      if (!res.ok) {
++        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
++        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
++        setSaveState({ state: "idle" });
++        return;
++      }
++
++      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
++      toast.success("Report saved.");
++      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
++    } catch {
++      toast.error("Network error.");
++      setSaveState({ state: "idle" });
++    }
++  }
++
++  const saving = saveState.state === "saving";
++  const saved = saveState.state === "saved";
++
++  return (
++    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
++      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
++        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
++          <div className="min-w-0">
++            <div className="text-sm font-medium text-foreground">Save this report</div>
++            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
++          </div>
++          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
++            {saving ? (
++              <>
++                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
++                Saving…
++              </>
++            ) : saved ? (
++              <>
++                <Check className="mr-2 h-4 w-4" />
++                Saved
++              </>
++            ) : (
++              "Save"
++            )}
++          </Button>
++        </CardContent>
++      </Card>
++    </motion.div>
++  );
++}
++
+ /* ────────────────────────────────────────────────────────────────────────────
+  * Main Component
+  * ──────────────────────────────────────────────────────────────────────────── */
+@@ -963,6 +1065,12 @@
+                 {/* Status Banner */}
+                 <StatusBanner data={load.data} />
+ 
++                {clerkEnabled && (
++                  <SignedIn>
++                    <SaveReportControl report={load.data} />
++                  </SignedIn>
++                )}
++
+                 {/* Summary Card */}
+                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+diff --git a/middleware.ts b/src/middleware.ts
+index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..078996501b70d8cda7ce43e7ec365481c2b6d808
+--- a/middleware.ts
++++ b/src/middleware.ts
+@@ -1,23 +1,24 @@
+ import { NextResponse } from "next/server";
+ import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
+ 
+-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
++// Note: when using `src/app`, Next expects middleware under `src/` as well.
++const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
+ 
+ const isPublicRoute = createRouteMatcher([
+   "/",
+   "/api/check",
+   "/api/analyze",
+   "/api/user-settings",
++  "/api/saved-reports",
+   "/sign-in(.*)",
+   "/sign-up(.*)",
+ ]);
+ 
+-const clerk = clerkMiddleware((auth, req) => {
++const clerk = clerkMiddleware(async (auth, req) => {
++  const { userId, redirectToSignIn } = await auth();
+   if (isPublicRoute(req)) return;
+-  return auth().then(({ userId, redirectToSignIn }) => {
+-    if (!userId) return redirectToSignIn();
+-    return undefined;
+-  });
++  if (!userId) return redirectToSignIn();
++  return undefined;
+ });
+ 
+ export default clerkEnabled ? clerk : () => NextResponse.next();
+
+file update:
+diff --git a/.ralph/runs/run-20260123-135210-55147-iter-1.log b/.ralph/runs/run-20260123-135210-55147-iter-1.log
+index ad4c4c1a37085a0cbd6f501aebc6fd931f8fa83c..8ff13182c69ae44725abb1e2976f05d93f4e63a2
+--- a/.ralph/runs/run-20260123-135210-55147-iter-1.log
++++ b/.ralph/runs/run-20260123-135210-55147-iter-1.log
+@@ -7796,8 +7796,8 @@
+ NEXT_PUBLIC_SITE_URL=https://usdt.chikocorp.com
+ 
+ # Clerk (auth)
+-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+-CLERK_SECRET_KEY=<redacted>
++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++CLERK_SECRET_KEY=<redacted>
+ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
+ NEXT_PUBLIC_CLERK_SIGN_UP_URL=/sign-up
+ NEXT_PUBLIC_CLERK_AFTER_SIGN_IN_URL=/
+@@ -41897,3 +41897,228 @@
+ **Avoiding sensitive information leaks**
+ 
+ I need to ensure we don’t commit any `.env` contents in the future. It’s already done, but I’ll note that any secrets should be redacted in the progress log. The log file will stay untracked after I edit it with `apply_patch`, but I can commit it later. I also considered checking older logs for secrets, but that may not be necessary. I’ll check the `.ralph/.tmp/prompt` file for safety, but it seems fine, so we can go ahead and patch the run log.
++file update
++M /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-135210-55147-iter-1.log
++@@ -7798,4 +7798,4 @@
++ # Clerk (auth)
++-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++-CLERK_SECRET_KEY=<redacted>
+++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+++CLERK_SECRET_KEY=<redacted>
++ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
++                                                                                    apply_patch(auto_approved=true) exited 0 in 72ms:
++Success. Updated the following files:
++M .ralph/runs/run-20260123-135210-55147-iter-1.log
++file update:
++diff --git a/.ralph/runs/run-20260123-135210-55147-iter-1.log b/.ralph/runs/run-20260123-135210-55147-iter-1.log
++index ad4c4c1a37085a0cbd6f501aebc6fd931f8fa83c..fd591bb7283ace1b8f8af92e2899bbc866e576a9
++--- a/.ralph/runs/run-20260123-135210-55147-iter-1.log
+++++ b/.ralph/runs/run-20260123-135210-55147-iter-1.log
++@@ -7796,8 +7796,8 @@
++ NEXT_PUBLIC_SITE_URL=https://usdt.chikocorp.com
++ 
++ # Clerk (auth)
++-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++-CLERK_SECRET_KEY=<redacted>
+++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+++CLERK_SECRET_KEY=<redacted>
++ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
++ NEXT_PUBLIC_CLERK_SIGN_UP_URL=/sign-up
++ NEXT_PUBLIC_CLERK_AFTER_SIGN_IN_URL=/
++@@ -41897,3 +41897,12 @@
++ **Avoiding sensitive information leaks**
++ 
++ I need to ensure we don’t commit any `.env` contents in the future. It’s already done, but I’ll note that any secrets should be redacted in the progress log. The log file will stay untracked after I edit it with `apply_patch`, but I can commit it later. I also considered checking older logs for secrets, but that may not be necessary. I’ll check the `.ralph/.tmp/prompt` file for safety, but it seems fine, so we can go ahead and patch the run log.
+++file update
+++M /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-135210-55147-iter-1.log
+++@@ -7798,4 +7798,4 @@
+++ # Clerk (auth)
+++-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+++-CLERK_SECRET_KEY=<redacted>
++++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++++CLERK_SECRET_KEY=<redacted>
+++ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
++diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
++new file mode 100644
++index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
++--- /dev/null
+++++ b/src/__tests__/api-saved-reports.test.ts
++@@ -0,0 +1,107 @@
+++import { beforeEach, describe, expect, it, vi } from "vitest";
+++
+++const auth = vi.fn();
+++vi.mock("@clerk/nextjs/server", () => ({ auth }));
+++
+++const getDb = vi.fn();
+++vi.mock("@/lib/db", () => ({ getDb }));
+++
+++const getUserSettings = vi.fn();
+++vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+++
+++const createSavedReport = vi.fn();
+++vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+++
+++const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+++
+++async function callPost(body: unknown) {
+++  const { POST } = await import("@/app/api/saved-reports/route");
+++  const req = new Request("http://localhost/api/saved-reports", {
+++    method: "POST",
+++    headers: { "content-type": "application/json" },
+++    body: JSON.stringify(body),
+++  });
+++  const res = await POST(req);
+++  const json = await res.json().catch(() => null);
+++  return { res, json };
+++}
+++
+++beforeEach(() => {
+++  vi.resetModules();
+++  vi.clearAllMocks();
+++  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+++  process.env.CLERK_SECRET_KEY = "sk_test_123";
+++  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+++});
+++
+++describe("/api/saved-reports", () => {
+++  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+++    auth.mockResolvedValue({ userId: null });
+++
+++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+++    expect(res.status).toBe(401);
+++    expect(getDb).not.toHaveBeenCalled();
+++    expect(getUserSettings).not.toHaveBeenCalled();
+++    expect(createSavedReport).not.toHaveBeenCalled();
+++  });
+++
+++  it("returns 503 when persistence is disabled", async () => {
+++    auth.mockResolvedValue({ userId: "user_123" });
+++    getDb.mockReturnValue(null);
+++
+++    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+++    expect(res.status).toBe(503);
+++    expect(json?.error).toBeTypeOf("string");
+++    expect(getUserSettings).not.toHaveBeenCalled();
+++    expect(createSavedReport).not.toHaveBeenCalled();
+++  });
+++
+++  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+++    auth.mockResolvedValue({ userId: "user_123" });
+++    getDb.mockReturnValue({});
+++    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+++
+++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+++    expect(res.status).toBe(403);
+++    expect(createSavedReport).not.toHaveBeenCalled();
+++  });
+++
+++  it("validates payload and rejects mismatched report addresses", async () => {
+++    auth.mockResolvedValue({ userId: "user_123" });
+++    getDb.mockReturnValue({});
+++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+++
+++    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+++    const { res } = await callPost({ address: VALID_ADDRESS, report });
+++    expect(res.status).toBe(400);
+++    expect(createSavedReport).not.toHaveBeenCalled();
+++  });
+++
+++  it("creates a SavedReport and returns its id", async () => {
+++    auth.mockResolvedValue({ userId: "user_123" });
+++    getDb.mockReturnValue({});
+++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+++    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+++
+++    const report = {
+++      address: VALID_ADDRESS,
+++      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+++      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+++    };
+++
+++    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+++    expect(res.status).toBe(200);
+++    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+++    expect(createSavedReport).toHaveBeenCalledWith(
+++      {},
+++      "user_123",
+++      expect.objectContaining({
+++        address: VALID_ADDRESS,
+++        riskScore: 55,
+++        riskTier: "high",
+++        confidence: 92,
+++        window: { lookbackDays: 90 },
+++      }),
+++    );
+++  });
+++});
++diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
++new file mode 100644
++index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
++--- /dev/null
+++++ b/src/app/api/saved-reports/route.ts
++@@ -0,0 +1,130 @@
+++import { NextResponse } from "next/server";
+++import { auth } from "@clerk/nextjs/server";
+++import { z } from "zod";
+++
+++import { getDb } from "@/lib/db";
+++import { createSavedReport } from "@/lib/db/saved-reports";
+++import { getUserSettings } from "@/lib/db/user-settings";
+++import { TronAddressSchema } from "@/lib/validators";
+++
+++export const runtime = "nodejs";
+++
+++const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+++
+++const SaveReportBodySchema = z.object({
+++  address: TronAddressSchema,
+++  report: z.unknown(),
+++});
+++
+++const AnalyzeReportSchema = z
+++  .object({
+++    address: TronAddressSchema,
+++    risk: z.object({
+++      score: z.number(),
+++      tier: RiskTierSchema,
+++      confidence: z.number(),
+++    }),
+++    checks: z
+++      .object({
+++        exposure1hop: z.unknown().optional(),
+++        tracing2hop: z.unknown().optional(),
+++      })
+++      .passthrough()
+++      .optional(),
+++  })
+++  .passthrough();
+++
+++function clampInt(n: number, min: number, max: number) {
+++  return Math.max(min, Math.min(max, Math.round(n)));
+++}
+++
+++function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+++  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+++  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+++    return exposure.window;
+++  }
+++
+++  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+++  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+++    return tracing.window;
+++  }
+++
+++  return { lookbackDays: 90 };
+++}
+++
+++async function getAuthenticatedUserId(): Promise<string | null> {
+++  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+++  try {
+++    const { userId } = await auth();
+++    return userId ?? null;
+++  } catch {
+++    return null;
+++  }
+++}
+++
+++export async functi
+\ No newline at end of file
+diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
+new file mode 100644
+index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
+--- /dev/null
++++ b/src/__tests__/api-saved-reports.test.ts
+@@ -0,0 +1,107 @@
++import { beforeEach, describe, expect, it, vi } from "vitest";
++
++const auth = vi.fn();
++vi.mock("@clerk/nextjs/server", () => ({ auth }));
++
++const getDb = vi.fn();
++vi.mock("@/lib/db", () => ({ getDb }));
++
++const getUserSettings = vi.fn();
++vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
++
++const createSavedReport = vi.fn();
++vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
++
++const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
++
++async function callPost(body: unknown) {
++  const { POST } = await import("@/app/api/saved-reports/route");
++  const req = new Request("http://localhost/api/saved-reports", {
++    method: "POST",
++    headers: { "content-type": "application/json" },
++    body: JSON.stringify(body),
++  });
++  const res = await POST(req);
++  const json = await res.json().catch(() => null);
++  return { res, json };
++}
++
++beforeEach(() => {
++  vi.resetModules();
++  vi.clearAllMocks();
++  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
++  process.env.CLERK_SECRET_KEY = "sk_test_123";
++  process.env.ADDRESS_HASH_KEY = "test_hash_key";
++});
++
++describe("/api/saved-reports", () => {
++  it("returns 401 when unauthenticated and does not touch the DB", async () => {
++    auth.mockResolvedValue({ userId: null });
++
++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
++    expect(res.status).toBe(401);
++    expect(getDb).not.toHaveBeenCalled();
++    expect(getUserSettings).not.toHaveBeenCalled();
++    expect(createSavedReport).not.toHaveBeenCalled();
++  });
++
++  it("returns 503 when persistence is disabled", async () => {
++    auth.mockResolvedValue({ userId: "user_123" });
++    getDb.mockReturnValue(null);
++
++    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
++    expect(res.status).toBe(503);
++    expect(json?.error).toBeTypeOf("string");
++    expect(getUserSettings).not.toHaveBeenCalled();
++    expect(createSavedReport).not.toHaveBeenCalled();
++  });
++
++  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
++    auth.mockResolvedValue({ userId: "user_123" });
++    getDb.mockReturnValue({});
++    getUserSettings.mockResolvedValue({ loggingEnabled: false });
++
++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
++    expect(res.status).toBe(403);
++    expect(createSavedReport).not.toHaveBeenCalled();
++  });
++
++  it("validates payload and rejects mismatched report addresses", async () => {
++    auth.mockResolvedValue({ userId: "user_123" });
++    getDb.mockReturnValue({});
++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
++
++    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
++    const { res } = await callPost({ address: VALID_ADDRESS, report });
++    expect(res.status).toBe(400);
++    expect(createSavedReport).not.toHaveBeenCalled();
++  });
++
++  it("creates a SavedReport and returns its id", async () => {
++    auth.mockResolvedValue({ userId: "user_123" });
++    getDb.mockReturnValue({});
++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
++    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
++
++    const report = {
++      address: VALID_ADDRESS,
++      risk: { score: 55.2, tier: "high", confidence: 91.7 },
++      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
++    };
++
++    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
++    expect(res.status).toBe(200);
++    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
++    expect(createSavedReport).toHaveBeenCalledWith(
++      {},
++      "user_123",
++      expect.objectContaining({
++        address: VALID_ADDRESS,
++        riskScore: 55,
++        riskTier: "high",
++        confidence: 92,
++        window: { lookbackDays: 90 },
++      }),
++    );
++  });
++});
+diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
+new file mode 100644
+index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
+--- /dev/null
++++ b/src/app/api/saved-reports/route.ts
+@@ -0,0 +1,130 @@
++import { NextResponse } from "next/server";
++import { auth } from "@clerk/nextjs/server";
++import { z } from "zod";
++
++import { getDb } from "@/lib/db";
++import { createSavedReport } from "@/lib/db/saved-reports";
++import { getUserSettings } from "@/lib/db/user-settings";
++import { TronAddressSchema } from "@/lib/validators";
++
++export const runtime = "nodejs";
++
++const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
++
++const SaveReportBodySchema = z.object({
++  address: TronAddressSchema,
++  report: z.unknown(),
++});
++
++const AnalyzeReportSchema = z
++  .object({
++    address: TronAddressSchema,
++    risk: z.object({
++      score: z.number(),
++      tier: RiskTierSchema,
++      confidence: z.number(),
++    }),
++    checks: z
++      .object({
++        exposure1hop: z.unknown().optional(),
++        tracing2hop: z.unknown().optional(),
++      })
++      .passthrough()
++      .optional(),
++  })
++  .passthrough();
++
++function clampInt(n: number, min: number, max: number) {
++  return Math.max(min, Math.min(max, Math.round(n)));
++}
++
++function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
++  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
++  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
++    return exposure.window;
++  }
++
++  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
++  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
++    return tracing.window;
++  }
++
++  return { lookbackDays: 90 };
++}
++
++async function getAuthenticatedUserId(): Promise<string | null> {
++  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
++  try {
++    const { userId } = await auth();
++    return userId ?? null;
++  } catch {
++    return null;
++  }
++}
++
++export async function POST(request: Request) {
++  const userId = await getAuthenticatedUserId();
++  if (!userId) {
++    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
++  }
++
++  if (!process.env.ADDRESS_HASH_KEY) {
++    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
++  }
++
++  const db = getDb();
++  if (!db) {
++    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
++  }
++
++  const settings = await getUserSettings(db, userId);
++  if (!settings?.loggingEnabled) {
++    return NextResponse.json(
++      { error: "Saving is disabled. Enable it in Settings first." },
++      { status: 403, headers: { "Cache-Control": "no-store" } },
++    );
++  }
++
++  let json: unknown;
++  try {
++    json = await request.json();
++  } catch {
++    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
++  }
++
++  const parsed = SaveReportBodySchema.safeParse(json);
++  if (!parsed.success) {
++    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
++  }
++
++  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
++  if (!reportParsed.success) {
++    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
++  }
++
++  if (reportParsed.data.address !== parsed.data.address) {
++    return NextResponse.json(
++      { error: "Report address mismatch." },
++      { status: 400, headers: { "Cache-Control": "no-store" } },
++    );
++  }
++
++  const report = reportParsed.data;
++  const created = await createSavedReport(db, userId, {
++    address: parsed.data.address,
++    riskScore: clampInt(report.risk.score, 0, 100),
++    riskTier: report.risk.tier,
++    confidence: clampInt(report.risk.confidence, 0, 100),
++    window: deriveWindow(report),
++    reportJson: parsed.data.report,
++  });
++
++  if (!created) {
++    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
++  }
++
++  return NextResponse.json(
++    { id: created.id, createdAt: created.createdAt },
++    { status: 200, headers: { "Cache-Control": "no-store" } },
++  );
++}
+diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
+index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
+--- a/src/components/blacklist-checker.tsx
++++ b/src/components/blacklist-checker.tsx
+@@ -506,6 +506,108 @@
+   );
+ }
+ 
++function SaveReportControl({ report }: { report: ApiResponse }) {
++  const { isLoaded, isSignedIn } = useAuth();
++  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
++  const [saveState, setSaveState] = React.useState<
++    | { state: "idle" }
++    | { state: "saving" }
++    | { state: "saved"; id?: string }
++  >({ state: "idle" });
++
++  React.useEffect(() => {
++    setSaveState({ state: "idle" });
++  }, [report.address, report.timestamps.checkedAtIso]);
++
++  React.useEffect(() => {
++    if (!isLoaded || !isSignedIn) return;
++    let cancelled = false;
++
++    async function loadSettings() {
++      try {
++        const res = await fetch("/api/user-settings", { credentials: "include" });
++        const json = (await res.json().catch(() => null)) as unknown;
++        if (!res.ok || !json || typeof json !== "object") return;
++
++        const obj = json as Record<string, unknown>;
++        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
++        if (cancelled) return;
++        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
++      } catch {
++        // ignore
++      }
++    }
++
++    loadSettings();
++    return () => {
++      cancelled = true;
++    };
++  }, [isLoaded, isSignedIn]);
++
++  if (!report.access?.authenticated) return null;
++  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
++
++  async function saveReport() {
++    if (saveState.state === "saving" || saveState.state === "saved") return;
++
++    setSaveState({ state: "saving" });
++    try {
++      const res = await fetch("/api/saved-reports", {
++        method: "POST",
++        headers: { "content-type": "application/json" },
++        credentials: "include",
++        body: JSON.stringify({ address: report.address, report }),
++      });
++
++      const json = (await res.json().catch(() => null)) as unknown;
++      if (!res.ok) {
++        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
++        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
++        setSaveState({ state: "idle" });
++        return;
++      }
++
++      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
++      toast.success("Report saved.");
++      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
++    } catch {
++      toast.error("Network error.");
++      setSaveState({ state: "idle" });
++    }
++  }
++
++  const saving = saveState.state === "saving";
++  const saved = saveState.state === "saved";
++
++  return (
++    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
++      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
++        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
++          <div className="min-w-0">
++            <div className="text-sm font-medium text-foreground">Save this report</div>
++            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
++          </div>
++          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
++            {saving ? (
++              <>
++                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
++                Saving…
++              </>
++            ) : saved ? (
++              <>
++                <Check className="mr-2 h-4 w-4" />
++                Saved
++              </>
++            ) : (
++              "Save"
++            )}
++          </Button>
++        </CardContent>
++      </Card>
++    </motion.div>
++  );
++}
++
+ /* ────────────────────────────────────────────────────────────────────────────
+  * Main Component
+  * ──────────────────────────────────────────────────────────────────────────── */
+@@ -963,6 +1065,12 @@
+                 {/* Status Banner */}
+                 <StatusBanner data={load.data} />
+ 
++                {clerkEnabled && (
++                  <SignedIn>
++                    <SaveReportControl report={load.data} />
++                  </SignedIn>
++                )}
++
+                 {/* Summary Card */}
+                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+diff --git a/middleware.ts b/src/middleware.ts
+index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..078996501b70d8cda7ce43e7ec365481c2b6d808
+--- a/middleware.ts
++++ b/src/middleware.ts
+@@ -1,23 +1,24 @@
+ import { NextResponse } from "next/server";
+ import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
+ 
+-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
++// Note: when using `src/app`, Next expects middleware under `src/` as well.
++const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
+ 
+ const isPublicRoute = createRouteMatcher([
+   "/",
+   "/api/check",
+   "/api/analyze",
+   "/api/user-settings",
++  "/api/saved-reports",
+   "/sign-in(.*)",
+   "/sign-up(.*)",
+ ]);
+ 
+-const clerk = clerkMiddleware((auth, req) => {
++const clerk = clerkMiddleware(async (auth, req) => {
++  const { userId, redirectToSignIn } = await auth();
+   if (isPublicRoute(req)) return;
+-  return auth().then(({ userId, redirectToSignIn }) => {
+-    if (!userId) return redirectToSignIn();
+-    return undefined;
+-  });
++  if (!userId) return redirectToSignIn();
++  return undefined;
+ });
+ 
+ export default clerkEnabled ? clerk : () => NextResponse.next();
+
+exec
+/bin/zsh -lc 'rg -n "sk_test_|pk_test_a25v|CLERK_SECRET_KEY=sk_test|NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=pk_test" .ralph/runs/run-20260123-135210-55147-iter-1.log || true' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 76ms:
+3309:  process.env.CLERK_SECRET_KEY = "sk_test_123";
+3438:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+3824:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+4213:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+4608:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+5008:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+5405:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+5813:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+6221:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+6610:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+7005:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+7413:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+7860:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+8256:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+8669:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+9077:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+9478:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+9867:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+10213:   process.env.CLERK_SECRET_KEY = "sk_test_123";
+10273:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+file update:
+diff --git a/.ralph/runs/run-20260123-135210-55147-iter-1.log b/.ralph/runs/run-20260123-135210-55147-iter-1.log
+index ad4c4c1a37085a0cbd6f501aebc6fd931f8fa83c..952216517f94d24bb59a56b3c137f57854ac883d
+--- a/.ralph/runs/run-20260123-135210-55147-iter-1.log
++++ b/.ralph/runs/run-20260123-135210-55147-iter-1.log
+@@ -7796,8 +7796,8 @@
+ NEXT_PUBLIC_SITE_URL=https://usdt.chikocorp.com
+ 
+ # Clerk (auth)
+-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+-CLERK_SECRET_KEY=<redacted>
++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++CLERK_SECRET_KEY=<redacted>
+ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
+ NEXT_PUBLIC_CLERK_SIGN_UP_URL=/sign-up
+ NEXT_PUBLIC_CLERK_AFTER_SIGN_IN_URL=/
+@@ -41897,3 +41897,1134 @@
+ **Avoiding sensitive information leaks**
+ 
+ I need to ensure we don’t commit any `.env` contents in the future. It’s already done, but I’ll note that any secrets should be redacted in the progress log. The log file will stay untracked after I edit it with `apply_patch`, but I can commit it later. I also considered checking older logs for secrets, but that may not be necessary. I’ll check the `.ralph/.tmp/prompt` file for safety, but it seems fine, so we can go ahead and patch the run log.
++file update
++M /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-135210-55147-iter-1.log
++@@ -7798,4 +7798,4 @@
++ # Clerk (auth)
++-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++-CLERK_SECRET_KEY=<redacted>
+++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+++CLERK_SECRET_KEY=<redacted>
++ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
++                                                                                    apply_patch(auto_approved=true) exited 0 in 72ms:
++Success. Updated the following files:
++M .ralph/runs/run-20260123-135210-55147-iter-1.log
++file update:
++diff --git a/.ralph/runs/run-20260123-135210-55147-iter-1.log b/.ralph/runs/run-20260123-135210-55147-iter-1.log
++index ad4c4c1a37085a0cbd6f501aebc6fd931f8fa83c..fd591bb7283ace1b8f8af92e2899bbc866e576a9
++--- a/.ralph/runs/run-20260123-135210-55147-iter-1.log
+++++ b/.ralph/runs/run-20260123-135210-55147-iter-1.log
++@@ -7796,8 +7796,8 @@
++ NEXT_PUBLIC_SITE_URL=https://usdt.chikocorp.com
++ 
++ # Clerk (auth)
++-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++-CLERK_SECRET_KEY=<redacted>
+++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+++CLERK_SECRET_KEY=<redacted>
++ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
++ NEXT_PUBLIC_CLERK_SIGN_UP_URL=/sign-up
++ NEXT_PUBLIC_CLERK_AFTER_SIGN_IN_URL=/
++@@ -41897,3 +41897,12 @@
++ **Avoiding sensitive information leaks**
++ 
++ I need to ensure we don’t commit any `.env` contents in the future. It’s already done, but I’ll note that any secrets should be redacted in the progress log. The log file will stay untracked after I edit it with `apply_patch`, but I can commit it later. I also considered checking older logs for secrets, but that may not be necessary. I’ll check the `.ralph/.tmp/prompt` file for safety, but it seems fine, so we can go ahead and patch the run log.
+++file update
+++M /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-135210-55147-iter-1.log
+++@@ -7798,4 +7798,4 @@
+++ # Clerk (auth)
+++-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+++-CLERK_SECRET_KEY=<redacted>
++++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++++CLERK_SECRET_KEY=<redacted>
+++ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
++diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
++new file mode 100644
++index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
++--- /dev/null
+++++ b/src/__tests__/api-saved-reports.test.ts
++@@ -0,0 +1,107 @@
+++import { beforeEach, describe, expect, it, vi } from "vitest";
+++
+++const auth = vi.fn();
+++vi.mock("@clerk/nextjs/server", () => ({ auth }));
+++
+++const getDb = vi.fn();
+++vi.mock("@/lib/db", () => ({ getDb }));
+++
+++const getUserSettings = vi.fn();
+++vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+++
+++const createSavedReport = vi.fn();
+++vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+++
+++const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+++
+++async function callPost(body: unknown) {
+++  const { POST } = await import("@/app/api/saved-reports/route");
+++  const req = new Request("http://localhost/api/saved-reports", {
+++    method: "POST",
+++    headers: { "content-type": "application/json" },
+++    body: JSON.stringify(body),
+++  });
+++  const res = await POST(req);
+++  const json = await res.json().catch(() => null);
+++  return { res, json };
+++}
+++
+++beforeEach(() => {
+++  vi.resetModules();
+++  vi.clearAllMocks();
+++  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+++  process.env.CLERK_SECRET_KEY = "sk_test_123";
+++  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+++});
+++
+++describe("/api/saved-reports", () => {
+++  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+++    auth.mockResolvedValue({ userId: null });
+++
+++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+++    expect(res.status).toBe(401);
+++    expect(getDb).not.toHaveBeenCalled();
+++    expect(getUserSettings).not.toHaveBeenCalled();
+++    expect(createSavedReport).not.toHaveBeenCalled();
+++  });
+++
+++  it("returns 503 when persistence is disabled", async () => {
+++    auth.mockResolvedValue({ userId: "user_123" });
+++    getDb.mockReturnValue(null);
+++
+++    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+++    expect(res.status).toBe(503);
+++    expect(json?.error).toBeTypeOf("string");
+++    expect(getUserSettings).not.toHaveBeenCalled();
+++    expect(createSavedReport).not.toHaveBeenCalled();
+++  });
+++
+++  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+++    auth.mockResolvedValue({ userId: "user_123" });
+++    getDb.mockReturnValue({});
+++    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+++
+++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+++    expect(res.status).toBe(403);
+++    expect(createSavedReport).not.toHaveBeenCalled();
+++  });
+++
+++  it("validates payload and rejects mismatched report addresses", async () => {
+++    auth.mockResolvedValue({ userId: "user_123" });
+++    getDb.mockReturnValue({});
+++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+++
+++    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+++    const { res } = await callPost({ address: VALID_ADDRESS, report });
+++    expect(res.status).toBe(400);
+++    expect(createSavedReport).not.toHaveBeenCalled();
+++  });
+++
+++  it("creates a SavedReport and returns its id", async () => {
+++    auth.mockResolvedValue({ userId: "user_123" });
+++    getDb.mockReturnValue({});
+++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+++    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+++
+++    const report = {
+++      address: VALID_ADDRESS,
+++      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+++      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+++    };
+++
+++    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+++    expect(res.status).toBe(200);
+++    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+++    expect(createSavedReport).toHaveBeenCalledWith(
+++      {},
+++      "user_123",
+++      expect.objectContaining({
+++        address: VALID_ADDRESS,
+++        riskScore: 55,
+++        riskTier: "high",
+++        confidence: 92,
+++        window: { lookbackDays: 90 },
+++      }),
+++    );
+++  });
+++});
++diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
++new file mode 100644
++index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
++--- /dev/null
+++++ b/src/app/api/saved-reports/route.ts
++@@ -0,0 +1,130 @@
+++import { NextResponse } from "next/server";
+++import { auth } from "@clerk/nextjs/server";
+++import { z } from "zod";
+++
+++import { getDb } from "@/lib/db";
+++import { createSavedReport } from "@/lib/db/saved-reports";
+++import { getUserSettings } from "@/lib/db/user-settings";
+++import { TronAddressSchema } from "@/lib/validators";
+++
+++export const runtime = "nodejs";
+++
+++const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+++
+++const SaveReportBodySchema = z.object({
+++  address: TronAddressSchema,
+++  report: z.unknown(),
+++});
+++
+++const AnalyzeReportSchema = z
+++  .object({
+++    address: TronAddressSchema,
+++    risk: z.object({
+++      score: z.number(),
+++      tier: RiskTierSchema,
+++      confidence: z.number(),
+++    }),
+++    checks: z
+++      .object({
+++        exposure1hop: z.unknown().optional(),
+++        tracing2hop: z.unknown().optional(),
+++      })
+++      .passthrough()
+++      .optional(),
+++  })
+++  .passthrough();
+++
+++function clampInt(n: number, min: number, max: number) {
+++  return Math.max(min, Math.min(max, Math.round(n)));
+++}
+++
+++function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+++  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+++  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+++    return exposure.window;
+++  }
+++
+++  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+++  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+++    return tracing.window;
+++  }
+++
+++  return { lookbackDays: 90 };
+++}
+++
+++async function getAuthenticatedUserId(): Promise<string | null> {
+++  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+++  try {
+++    const { userId } = await auth();
+++    return userId ?? null;
+++  } catch {
+++    return null;
+++  }
+++}
+++
+++export async function POST(request: Request) {
+++  const userId = await getAuthenticatedUserId();
+++  if (!userId) {
+++    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+++  }
+++
+++  if (!process.env.ADDRESS_HASH_KEY) {
+++    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+++  }
+++
+++  const db = getDb();
+++  if (!db) {
+++    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+++  }
+++
+++  const settings = await getUserSettings(db, userId);
+++  if (!settings?.loggingEnabled) {
+++    return NextResponse.json(
+++      { error: "Saving is disabled. Enable it in Settings first." },
+++      { status: 403, headers: { "Cache-Control": "no-store" } },
+++    );
+++  }
+++
+++  let json: unknown;
+++  try {
+++    json = await request.json();
+++  } catch {
+++    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+++  }
+++
+++  const parsed = SaveReportBodySchema.safeParse(json);
+++  if (!parsed.success) {
+++    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+++  }
+++
+++  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+++  if (!reportParsed.success) {
+++    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+++  }
+++
+++  if (reportParsed.data.address !== parsed.data.address) {
+++    return NextResponse.json(
+++      { error: "Report address mismatch." },
+++      { status: 400, headers: { "Cache-Control": "no-store" } },
+++    );
+++  }
+++
+++  const report = reportParsed.data;
+++  const created = await createSavedReport(db, userId, {
+++    address: parsed.data.address,
+++    riskScore: clampInt(report.risk.score, 0, 100),
+++    riskTier: report.risk.tier,
+++    confidence: clampInt(report.risk.confidence, 0, 100),
+++    window: deriveWindow(report),
+++    reportJson: parsed.data.report,
+++  });
+++
+++  if (!created) {
+++    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+++  }
+++
+++  return NextResponse.json(
+++    { id: created.id, createdAt: created.createdAt },
+++    { status: 200, headers: { "Cache-Control": "no-store" } },
+++  );
+++}
++diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
++index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
++--- a/src/components/blacklist-checker.tsx
+++++ b/src/components/blacklist-checker.tsx
++@@ -506,6 +506,108 @@
++   );
++ }
++ 
+++function SaveReportControl({ report }: { report: ApiResponse }) {
+++  const { isLoaded, isSignedIn } = useAuth();
+++  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+++  const [saveState, setSaveState] = React.useState<
+++    | { state: "idle" }
+++    | { state: "saving" }
+++    | { state: "saved"; id?: string }
+++  >({ state: "idle" });
+++
+++  React.useEffect(() => {
+++    setSaveState({ state: "idle" });
+++  }, [report.address, report.timestamps.checkedAtIso]);
+++
+++  React.useEffect(() => {
+++    if (!isLoaded || !isSignedIn) return;
+++    let cancelled = false;
+++
+++    async function loadSettings() {
+++      try {
+++        const res = await fetch("/api/user-settings", { credentials: "include" });
+++        const json = (await res.json().catch(() => null)) as unknown;
+++        if (!res.ok || !json || typeof json !== "object") return;
+++
+++        const obj = json as Record<string, unknown>;
+++        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+++        if (cancelled) return;
+++        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+++      } catch {
+++        // ignore
+++      }
+++    }
+++
+++    loadSettings();
+++    return () => {
+++      cancelled = true;
+++    };
+++  }, [isLoaded, isSignedIn]);
+++
+++  if (!report.access?.authenticated) return null;
+++  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+++
+++  async function saveReport() {
+++    if (saveState.state === "saving" || saveState.state === "saved") return;
+++
+++    setSaveState({ state: "saving" });
+++    try {
+++      const res = await fetch("/api/saved-reports", {
+++        method: "POST",
+++        headers: { "content-type": "application/json" },
+++        credentials: "include",
+++        body: JSON.stringify({ address: report.address, report }),
+++      });
+++
+++      const json = (await res.json().catch(() => null)) as unknown;
+++      if (!res.ok) {
+++        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+++        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+++        setSaveState({ state: "idle" });
+++        return;
+++      }
+++
+++      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+++      toast.success("Report saved.");
+++      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+++    } catch {
+++      toast.error("Network error.");
+++      setSaveState({ state: "idle" });
+++    }
+++  }
+++
+++  const saving = saveState.state === "saving";
+++  const saved = saveState.state === "saved";
+++
+++  return (
+++    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+++      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+++        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+++          <div className="min-w-0">
+++            <div className="text-sm font-medium text-foreground">Save this report</div>
+++            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+++          </div>
+++          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+++            {saving ? (
+++              <>
+++                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+++                Saving…
+++              </>
+++            ) : saved ? (
+++              <>
+++                <Check className="mr-2 h-4 w-4" />
+++                Saved
+++              </>
+++            ) : (
+++              "Save"
+++            )}
+++          </Button>
+++        </CardContent>
+++      </Card>
+++    </motion.div>
+++  );
+++}
+++
++ /* ────────────────────────────────────────────────────────────────────────────
++  * Main Component
++  * ──────────────────────────────────────────────────────────────────────────── */
++@@ -963,6 +1065,12 @@
++                 {/* Status Banner */}
++                 <StatusBanner data={load.data} />
++ 
+++                {clerkEnabled && (
+++                  <SignedIn>
+++                    <SaveReportControl report={load.data} />
+++                  </SignedIn>
+++                )}
+++
++                 {/* Summary Card */}
++                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
++                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
++diff --git a/middleware.ts b/src/middleware.ts
++index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..078996501b70d8cda7ce43e7ec365481c2b6d808
++--- a/middleware.ts
+++++ b/src/middleware.ts
++@@ -1,23 +1,24 @@
++ import { NextResponse } from "next/server";
++ import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
++ 
++-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
+++// Note: when using `src/app`, Next expects middleware under `src/` as well.
+++const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
++ 
++ const isPublicRoute = createRouteMatcher([
++   "/",
++   "/api/check",
++   "/api/analyze",
++   "/api/user-settings",
+++  "/api/saved-reports",
++   "/sign-in(.*)",
++   "/sign-up(.*)",
++ ]);
++ 
++-const clerk = clerkMiddleware((auth, req) => {
+++const clerk = clerkMiddleware(async (auth, req) => {
+++  const { userId, redirectToSignIn } = await auth();
++   if (isPublicRoute(req)) return;
++-  return auth().then(({ userId, redirectToSignIn }) => {
++-    if (!userId) return redirectToSignIn();
++-    return undefined;
++-  });
+++  if (!userId) return redirectToSignIn();
+++  return undefined;
++ });
++ 
++ export default clerkEnabled ? clerk : () => NextResponse.next();
++
++file update:
++diff --git a/.ralph/runs/run-20260123-135210-55147-iter-1.log b/.ralph/runs/run-20260123-135210-55147-iter-1.log
++index ad4c4c1a37085a0cbd6f501aebc6fd931f8fa83c..8ff13182c69ae44725abb1e2976f05d93f4e63a2
++--- a/.ralph/runs/run-20260123-135210-55147-iter-1.log
+++++ b/.ralph/runs/run-20260123-135210-55147-iter-1.log
++@@ -7796,8 +7796,8 @@
++ NEXT_PUBLIC_SITE_URL=https://usdt.chikocorp.com
++ 
++ # Clerk (auth)
++-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++-CLERK_SECRET_KEY=<redacted>
+++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+++CLERK_SECRET_KEY=<redacted>
++ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
++ NEXT_PUBLIC_CLERK_SIGN_UP_URL=/sign-up
++ NEXT_PUBLIC_CLERK_AFTER_SIGN_IN_URL=/
++@@ -41897,3 +41897,228 @@
++ **Avoiding sensitive information leaks**
++ 
++ I need to ensure we don’t commit any `.env` contents in the future. It’s already done, but I’ll note that any secrets should be redacted in the progress log. The log file will stay untracked after I edit it with `apply_patch`, but I can commit it later. I also considered checking older logs for secrets, but that may not be necessary. I’ll check the `.ralph/.tmp/prompt` file for safety, but it seems fine, so we can go ahead and patch the run log.
+++file update
+++M /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-135210-55147-iter-1.log
+++@@ -7798,4 +7798,4 @@
+++ # Clerk (auth)
+++-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+++-CLERK_SECRET_KEY=<redacted>
++++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++++CLERK_SECRET_KEY=<redacted>
+++ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
+++                                                                                    apply_patch(auto_approved=true) exited 0 in 72ms:
+++Success. Updated the following files:
+++M .ralph/runs/run-20260123-135210-55147-iter-1.log
+++file update:
+++diff --git a/.ralph/runs/run-20260123-135210-55147-iter-1.log b/.ralph/runs/run-20260123-135210-55147-iter-1.log
+++index ad4c4c1a37085a0cbd6f501aebc6fd931f8fa83c..fd591bb7283ace1b8f8af92e2899bbc866e576a9
+++--- a/.ralph/runs/run-20260123-135210-55147-iter-1.log
++++++ b/.ralph/runs/run-20260123-135210-55147-iter-1.log
+++@@ -7796,8 +7796,8 @@
+++ NEXT_PUBLIC_SITE_URL=https://usdt.chikocorp.com
+++ 
+++ # Clerk (auth)
+++-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+++-CLERK_SECRET_KEY=<redacted>
++++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++++CLERK_SECRET_KEY=<redacted>
+++ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
+++ NEXT_PUBLIC_CLERK_SIGN_UP_URL=/sign-up
+++ NEXT_PUBLIC_CLERK_AFTER_SIGN_IN_URL=/
+++@@ -41897,3 +41897,12 @@
+++ **Avoiding sensitive information leaks**
+++ 
+++ I need to ensure we don’t commit any `.env` contents in the future. It’s already done, but I’ll note that any secrets should be redacted in the progress log. The log file will stay untracked after I edit it with `apply_patch`, but I can commit it later. I also considered checking older logs for secrets, but that may not be necessary. I’ll check the `.ralph/.tmp/prompt` file for safety, but it seems fine, so we can go ahead and patch the run log.
++++file update
++++M /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-135210-55147-iter-1.log
++++@@ -7798,4 +7798,4 @@
++++ # Clerk (auth)
++++-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++++-CLERK_SECRET_KEY=<redacted>
+++++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+++++CLERK_SECRET_KEY=<redacted>
++++ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
+++diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
+++new file mode 100644
+++index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
+++--- /dev/null
++++++ b/src/__tests__/api-saved-reports.test.ts
+++@@ -0,0 +1,107 @@
++++import { beforeEach, describe, expect, it, vi } from "vitest";
++++
++++const auth = vi.fn();
++++vi.mock("@clerk/nextjs/server", () => ({ auth }));
++++
++++const getDb = vi.fn();
++++vi.mock("@/lib/db", () => ({ getDb }));
++++
++++const getUserSettings = vi.fn();
++++vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
++++
++++const createSavedReport = vi.fn();
++++vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
++++
++++const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
++++
++++async function callPost(body: unknown) {
++++  const { POST } = await import("@/app/api/saved-reports/route");
++++  const req = new Request("http://localhost/api/saved-reports", {
++++    method: "POST",
++++    headers: { "content-type": "application/json" },
++++    body: JSON.stringify(body),
++++  });
++++  const res = await POST(req);
++++  const json = await res.json().catch(() => null);
++++  return { res, json };
++++}
++++
++++beforeEach(() => {
++++  vi.resetModules();
++++  vi.clearAllMocks();
++++  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
++++  process.env.CLERK_SECRET_KEY = "sk_test_123";
++++  process.env.ADDRESS_HASH_KEY = "test_hash_key";
++++});
++++
++++describe("/api/saved-reports", () => {
++++  it("returns 401 when unauthenticated and does not touch the DB", async () => {
++++    auth.mockResolvedValue({ userId: null });
++++
++++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
++++    expect(res.status).toBe(401);
++++    expect(getDb).not.toHaveBeenCalled();
++++    expect(getUserSettings).not.toHaveBeenCalled();
++++    expect(createSavedReport).not.toHaveBeenCalled();
++++  });
++++
++++  it("returns 503 when persistence is disabled", async () => {
++++    auth.mockResolvedValue({ userId: "user_123" });
++++    getDb.mockReturnValue(null);
++++
++++    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
++++    expect(res.status).toBe(503);
++++    expect(json?.error).toBeTypeOf("string");
++++    expect(getUserSettings).not.toHaveBeenCalled();
++++    expect(createSavedReport).not.toHaveBeenCalled();
++++  });
++++
++++  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
++++    auth.mockResolvedValue({ userId: "user_123" });
++++    getDb.mockReturnValue({});
++++    getUserSettings.mockResolvedValue({ loggingEnabled: false });
++++
++++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
++++    expect(res.status).toBe(403);
++++    expect(createSavedReport).not.toHaveBeenCalled();
++++  });
++++
++++  it("validates payload and rejects mismatched report addresses", async () => {
++++    auth.mockResolvedValue({ userId: "user_123" });
++++    getDb.mockReturnValue({});
++++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
++++
++++    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
++++    const { res } = await callPost({ address: VALID_ADDRESS, report });
++++    expect(res.status).toBe(400);
++++    expect(createSavedReport).not.toHaveBeenCalled();
++++  });
++++
++++  it("creates a SavedReport and returns its id", async () => {
++++    auth.mockResolvedValue({ userId: "user_123" });
++++    getDb.mockReturnValue({});
++++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
++++    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
++++
++++    const report = {
++++      address: VALID_ADDRESS,
++++      risk: { score: 55.2, tier: "high", confidence: 91.7 },
++++      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
++++    };
++++
++++    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
++++    expect(res.status).toBe(200);
++++    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
++++    expect(createSavedReport).toHaveBeenCalledWith(
++++      {},
++++      "user_123",
++++      expect.objectContaining({
++++        address: VALID_ADDRESS,
++++        riskScore: 55,
++++        riskTier: "high",
++++        confidence: 92,
++++        window: { lookbackDays: 90 },
++++      }),
++++    );
++++  });
++++});
+++diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
+++new file mode 100644
+++index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
+++--- /dev/null
++++++ b/src/app/api/saved-reports/route.ts
+++@@ -0,0 +1,130 @@
++++import { NextResponse } from "next/server";
++++import { auth } from "@clerk/nextjs/server";
++++import { z } from "zod";
++++
++++import { getDb } from "@/lib/db";
++++import { createSavedReport } from "@/lib/db/saved-reports";
++++import { getUserSettings } from "@/lib/db/user-settings";
++++import { TronAddressSchema } from "@/lib/validators";
++++
++++export const runtime = "nodejs";
++++
++++const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
++++
++++const SaveReportBodySchema = z.object({
++++  address: TronAddressSchema,
++++  report: z.unknown(),
++++});
++++
++++const AnalyzeReportSchema = z
++++  .object({
++++    address: TronAddressSchema,
++++    risk: z.object({
++++      score: z.number(),
++++      tier: RiskTierSchema,
++++      confidence: z.number(),
++++    }),
++++    checks: z
++++      .object({
++++        exposure1hop: z.unknown().optional(),
++++        tracing2hop: z.unknown().optional(),
++++      })
++++      .passthrough()
++++      .optional(),
++++  })
++++  .passthrough();
++++
++++function clampInt(n: number, min: number, max: number) {
++++  return Math.max(min, Math.min(max, Math.round(n)));
++++}
++++
++++function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
++++  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
++++  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
++++    return exposure.window;
++++  }
++++
++++  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
++++  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
++++    return tracing.window;
++++  }
++++
++++  return { lookbackDays: 90 };
++++}
++++
++++async function getAuthenticatedUserId(): Promise<string | null> {
++++  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
++++  try {
++++    const { userId } = await auth();
++++    return userId ?? null;
++++  } catch {
++++    return null;
++++  }
++++}
++++
++++export async functi
++\ No newline at end of file
++diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
++new file mode 100644
++index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
++--- /dev/null
+++++ b/src/__tests__/api-saved-reports.test.ts
++@@ -0,0 +1,107 @@
+++import { beforeEach, describe, expect, it, vi } from "vitest";
+++
+++const auth = vi.fn();
+++vi.mock("@clerk/nextjs/server", () => ({ auth }));
+++
+++const getDb = vi.fn();
+++vi.mock("@/lib/db", () => ({ getDb }));
+++
+++const getUserSettings = vi.fn();
+++vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+++
+++const createSavedReport = vi.fn();
+++vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+++
+++const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+++
+++async function callPost(body: unknown) {
+++  const { POST } = await import("@/app/api/saved-reports/route");
+++  const req = new Request("http://localhost/api/saved-reports", {
+++    method: "POST",
+++    headers: { "content-type": "application/json" },
+++    body: JSON.stringify(body),
+++  });
+++  const res = await POST(req);
+++  const json = await res.json().catch(() => null);
+++  return { res, json };
+++}
+++
+++beforeEach(() => {
+++  vi.resetModules();
+++  vi.clearAllMocks();
+++  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+++  process.env.CLERK_SECRET_KEY = "sk_test_123";
+++  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+++});
+++
+++describe("/api/saved-reports", () => {
+++  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+++    auth.mockResolvedValue({ userId: null });
+++
+++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+++    expect(res.status).toBe(401);
+++    expect(getDb).not.toHaveBeenCalled();
+++    expect(getUserSettings).not.toHaveBeenCalled();
+++    expect(createSavedReport).not.toHaveBeenCalled();
+++  });
+++
+++  it("returns 503 when persistence is disabled", async () => {
+++    auth.mockResolvedValue({ userId: "user_123" });
+++    getDb.mockReturnValue(null);
+++
+++    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+++    expect(res.status).toBe(503);
+++    expect(json?.error).toBeTypeOf("string");
+++    expect(getUserSettings).not.toHaveBeenCalled();
+++    expect(createSavedReport).not.toHaveBeenCalled();
+++  });
+++
+++  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+++    auth.mockResolvedValue({ userId: "user_123" });
+++    getDb.mockReturnValue({});
+++    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+++
+++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+++    expect(res.status).toBe(403);
+++    expect(createSavedReport).not.toHaveBeenCalled();
+++  });
+++
+++  it("validates payload and rejects mismatched report addresses", async () => {
+++    auth.mockResolvedValue({ userId: "user_123" });
+++    getDb.mockReturnValue({});
+++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+++
+++    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+++    const { res } = await callPost({ address: VALID_ADDRESS, report });
+++    expect(res.status).toBe(400);
+++    expect(createSavedReport).not.toHaveBeenCalled();
+++  });
+++
+++  it("creates a SavedReport and returns its id", async () => {
+++    auth.mockResolvedValue({ userId: "user_123" });
+++    getDb.mockReturnValue({});
+++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+++    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+++
+++    const report = {
+++      address: VALID_ADDRESS,
+++      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+++      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+++    };
+++
+++    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+++    expect(res.status).toBe(200);
+++    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+++    expect(createSavedReport).toHaveBeenCalledWith(
+++      {},
+++      "user_123",
+++      expect.objectContaining({
+++        address: VALID_ADDRESS,
+++        riskScore: 55,
+++        riskTier: "high",
+++        confidence: 92,
+++        window: { lookbackDays: 90 },
+++      }),
+++    );
+++  });
+++});
++diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
++new file mode 100644
++index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
++--- /dev/null
+++++ b/src/app/api/saved-reports/route.ts
++@@ -0,0 +1,130 @@
+++import { NextResponse } from "next/server";
+++import { auth } from "@clerk/nextjs/server";
+++import { z } from "zod";
+++
+++import { getDb } from "@/lib/db";
+++import { createSavedReport } from "@/lib/db/saved-reports";
+++import { getUserSettings } from "@/lib/db/user-settings";
+++import { TronAddressSchema } from "@/lib/validators";
+++
+++export const runtime = "nodejs";
+++
+++const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+++
+++const SaveReportBodySchema = z.object({
+++  address: TronAddressSchema,
+++  report: z.unknown(),
+++});
+++
+++const AnalyzeReportSchema = z
+++  .object({
+++    address: TronAddressSchema,
+++    risk: z.object({
+++      score: z.number(),
+++      tier: RiskTierSchema,
+++      confidence: z.number(),
+++    }),
+++    checks: z
+++      .object({
+++        exposure1hop: z.unknown().optional(),
+++        tracing2hop: z.unknown().optional(),
+++      })
+++      .passthrough()
+++      .optional(),
+++  })
+++  .passthrough();
+++
+++function clampInt(n: number, min: number, max: number) {
+++  return Math.max(min, Math.min(max, Math.round(n)));
+++}
+++
+++function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+++  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+++  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+++    return exposure.window;
+++  }
+++
+++  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+++  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+++    return tracing.window;
+++  }
+++
+++  return { lookbackDays: 90 };
+++}
+++
+++async function getAuthenticatedUserId(): Promise<string | null> {
+++  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+++  try {
+++    const { userId } = await auth();
+++    return userId ?? null;
+++  } catch {
+++    return null;
+++  }
+++}
+++
+++export async function POST(request: Request) {
+++  const userId = await getAuthenticatedUserId();
+++  if (!userId) {
+++    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+++  }
+++
+++  if (!process.env.ADDRESS_HASH_KEY) {
+++    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+++  }
+++
+++  const db = getDb();
+++  if (!db) {
+++    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+++  }
+++
+++  const settings = await getUserSettings(db, userId);
+++  if (!settings?.loggingEnabled) {
+++    return NextResponse.json(
+++      { error: "Saving is disabled. Enable it in Settings first." },
+++      { status: 403, headers: { "Cache-Control": "no-store" } },
+++    );
+++  }
+++
+++  let json: unknown;
+++  try {
+++    json = await request.json();
+++  } catch {
+++    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+++  }
+++
+++  const parsed = SaveReportBodySchema.safeParse(json);
+++  if (!parsed.success) {
+++    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+++  }
+++
+++  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+++  if (!reportParsed.success) {
+++    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+++  }
+++
+++  if (reportParsed.data.address !== parsed.data.address) {
+++    return NextResponse.json(
+++      { error: "Report address mismatch." },
+++      { status: 400, headers: { "Cache-Control": "no-store" } },
+++    );
+++  }
+++
+++  const report = reportParsed.data;
+++  const created = await createSavedReport(db, userId, {
+++    address: parsed.data.address,
+++    riskScore: clampInt(report.risk.score, 0, 100),
+++    riskTier: report.risk.tier,
+++    confidence: clampInt(report.risk.confidence, 0, 100),
+++    window: deriveWindow(report),
+++    reportJson: parsed.data.report,
+++  });
+++
+++  if (!created) {
+++    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+++  }
+++
+++  return NextResponse.json(
+++    { id: created.id, createdAt: created.createdAt },
+++    { status: 200, headers: { "Cache-Control": "no-store" } },
+++  );
+++}
++diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
++index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
++--- a/src/components/blacklist-checker.tsx
+++++ b/src/components/blacklist-checker.tsx
++@@ -506,6 +506,108 @@
++   );
++ }
++ 
+++function SaveReportControl({ report }: { report: ApiResponse }) {
+++  const { isLoaded, isSignedIn } = useAuth();
+++  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+++  const [saveState, setSaveState] = React.useState<
+++    | { state: "idle" }
+++    | { state: "saving" }
+++    | { state: "saved"; id?: string }
+++  >({ state: "idle" });
+++
+++  React.useEffect(() => {
+++    setSaveState({ state: "idle" });
+++  }, [report.address, report.timestamps.checkedAtIso]);
+++
+++  React.useEffect(() => {
+++    if (!isLoaded || !isSignedIn) return;
+++    let cancelled = false;
+++
+++    async function loadSettings() {
+++      try {
+++        const res = await fetch("/api/user-settings", { credentials: "include" });
+++        const json = (await res.json().catch(() => null)) as unknown;
+++        if (!res.ok || !json || typeof json !== "object") return;
+++
+++        const obj = json as Record<string, unknown>;
+++        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+++        if (cancelled) return;
+++        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+++      } catch {
+++        // ignore
+++      }
+++    }
+++
+++    loadSettings();
+++    return () => {
+++      cancelled = true;
+++    };
+++  }, [isLoaded, isSignedIn]);
+++
+++  if (!report.access?.authenticated) return null;
+++  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+++
+++  async function saveReport() {
+++    if (saveState.state === "saving" || saveState.state === "saved") return;
+++
+++    setSaveState({ state: "saving" });
+++    try {
+++      const res = await fetch("/api/saved-reports", {
+++        method: "POST",
+++        headers: { "content-type": "application/json" },
+++        credentials: "include",
+++        body: JSON.stringify({ address: report.address, report }),
+++      });
+++
+++      const json = (await res.json().catch(() => null)) as unknown;
+++      if (!res.ok) {
+++        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+++        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+++        setSaveState({ state: "idle" });
+++        return;
+++      }
+++
+++      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+++      toast.success("Report saved.");
+++      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+++    } catch {
+++      toast.error("Network error.");
+++      setSaveState({ state: "idle" });
+++    }
+++  }
+++
+++  const saving = saveState.state === "saving";
+++  const saved = saveState.state === "saved";
+++
+++  return (
+++    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+++      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+++        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+++          <div className="min-w-0">
+++            <div className="text-sm font-medium text-foreground">Save this report</div>
+++            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+++          </div>
+++          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+++            {saving ? (
+++              <>
+++                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+++                Saving…
+++              </>
+++            ) : saved ? (
+++              <>
+++                <Check className="mr-2 h-4 w-4" />
+++                Saved
+++              </>
+++            ) : (
+++              "Save"
+++            )}
+++          </Button>
+++        </CardContent>
+++      </Card>
+++    </motion.div>
+++  );
+++}
+++
++ /* ────────────────────────────────────────────────────────────────────────────
++  * Main Component
++  * ──────────────────────────────────────────────────────────────────────────── */
++@@ -963,6 +1065,12 @@
++                 {/* Status Banner */}
++                 <StatusBanner data={load.data} />
++ 
+++                {clerkEnabled && (
+++                  <SignedIn>
+++                    <SaveReportControl report={load.data} />
+++                  </SignedIn>
+++                )}
+++
++                 {/* Summary Card */}
++                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
++                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
++diff --git a/middleware.ts b/src/middleware.ts
++index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..078996501b70d8cda7ce43e7ec365481c2b6d808
++--- a/middleware.ts
+++++ b/src/middleware.ts
++@@ -1,23 +1,24 @@
++ import { NextResponse } from "next/server";
++ import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
++ 
++-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
+++// Note: when using `src/app`, Next expects middleware under `src/` as well.
+++const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
++ 
++ const isPublicRoute = createRouteMatcher([
++   "/",
++   "/api/check",
++   "/api/analyze",
++   "/api/user-settings",
+++  "/api/saved-reports",
++   "/sign-in(.*)",
++   "/sign-up(.*)",
++ ]);
++ 
++-const clerk = clerkMiddleware((auth, req) => {
+++const clerk = clerkMiddleware(async (auth, req) => {
+++  const { userId, redirectToSignIn } = await auth();
++   if (isPublicRoute(req)) return;
++-  return auth().then(({ userId, redirectToSignIn }) => {
++-    if (!userId) return redirectToSignIn();
++-    return undefined;
++-  });
+++  if (!userId) return redirectToSignIn();
+++  return undefined;
++ });
++ 
++ export default clerkEnabled ? clerk : () => NextResponse.next();
++
++exec
++/bin/zsh -lc 'rg -n "sk_test_|pk_test_a25v|CLERK_SECRET_KEY=sk_test|NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=pk_test" .ralph/runs/run-20260123-135210-55147-iter-1.log || true' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 76ms:
++3309:  process.env.CLERK_SECRET_KEY = "sk_test_123";
++3438:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++3824:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++4213:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++4608:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++5008:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++5405:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++5813:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++6221:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++6610:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++7005:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++7413:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++7860:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++8256:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++8669:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++9077:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++9478:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++9867:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++10213:   process.env.CLERK_SECRET_KEY = "sk_test_123";
++10273:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
+new file mode 100644
+index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
+--- /dev/null
++++ b/src/__tests__/api-saved-reports.test.ts
+@@ -0,0 +1,107 @@
++import { beforeEach, describe, expect, it, vi } from "vitest";
++
++const auth = vi.fn();
++vi.mock("@clerk/nextjs/server", () => ({ auth }));
++
++const getDb = vi.fn();
++vi.mock("@/lib/db", () => ({ getDb }));
++
++const getUserSettings = vi.fn();
++vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
++
++const createSavedReport = vi.fn();
++vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
++
++const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
++
++async function callPost(body: unknown) {
++  const { POST } = await import("@/app/api/saved-reports/route");
++  const req = new Request("http://localhost/api/saved-reports", {
++    method: "POST",
++    headers: { "content-type": "application/json" },
++    body: JSON.stringify(body),
++  });
++  const res = await POST(req);
++  const json = await res.json().catch(() => null);
++  return { res, json };
++}
++
++beforeEach(() => {
++  vi.resetModules();
++  vi.clearAllMocks();
++  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
++  process.env.CLERK_SECRET_KEY = "sk_test_123";
++  process.env.ADDRESS_HASH_KEY = "test_hash_key";
++});
++
++describe("/api/saved-reports", () => {
++  it("returns 401 when unauthenticated and does not touch the DB", async () => {
++    auth.mockResolvedValue({ userId: null });
++
++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
++    expect(res.status).toBe(401);
++    expect(getDb).not.toHaveBeenCalled();
++    expect(getUserSettings).not.toHaveBeenCalled();
++    expect(createSavedReport).not.toHaveBeenCalled();
++  });
++
++  it("returns 503 when persistence is disabled", async () => {
++    auth.mockResolvedValue({ userId: "user_123" });
++    getDb.mockReturnValue(null);
++
++    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
++    expect(res.status).toBe(503);
++    expect(json?.error).toBeTypeOf("string");
++    expect(getUserSettings).not.toHaveBeenCalled();
++    expect(createSavedReport).not.toHaveBeenCalled();
++  });
++
++  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
++    auth.mockResolvedValue({ userId: "user_123" });
++    getDb.mockReturnValue({});
++    getUserSettings.mockResolvedValue({ loggingEnabled: false });
++
++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
++    expect(res.status).toBe(403);
++    expect(createSavedReport).not.toHaveBeenCalled();
++  });
++
++  it("validates payload and rejects mismatched report addresses", async () => {
++    auth.mockResolvedValue({ userId: "user_123" });
++    getDb.mockReturnValue({});
++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
++
++    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
++    const { res } = await callPost({ address: VALID_ADDRESS, report });
++    expect(res.status).toBe(400);
++    expect(createSavedReport).not.toHaveBeenCalled();
++  });
++
++  it("creates a SavedReport and returns its id", async () => {
++    auth.mockResolvedValue({ userId: "user_123" });
++    getDb.mockReturnValue({});
++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
++    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
++
++    const report = {
++      address: VALID_ADDRESS,
++      risk: { score: 55.2, tier: "high", confidence: 91.7 },
++      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
++    };
++
++    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
++    expect(res.status).toBe(200);
++    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
++    expect(createSavedReport).toHaveBeenCalledWith(
++      {},
++      "user_123",
++      expect.objectContaining({
++        address: VALID_ADDRESS,
++        riskScore: 55,
++        riskTier: "high",
++        confidence: 92,
++        window: { lookbackDays: 90 },
++      }),
++    );
++  });
++});
+diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
+new file mode 100644
+index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
+--- /dev/null
++++ b/src/app/api/saved-reports/route.ts
+@@ -0,0 +1,130 @@
++import { NextResponse } from "next/server";
++import { auth } from "@clerk/nextjs/server";
++import { z } from "zod";
++
++import { getDb } from "@/lib/db";
++import { createSavedReport } from "@/lib/db/saved-reports";
++import { getUserSettings } from "@/lib/db/user-settings";
++import { TronAddressSchema } from "@/lib/validators";
++
++export const runtime = "nodejs";
++
++const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
++
++const SaveReportBodySchema = z.object({
++  address: TronAddressSchema,
++  report: z.unknown(),
++});
++
++const AnalyzeReportSchema = z
++  .object({
++    address: TronAddressSchema,
++    risk: z.object({
++      score: z.number(),
++      tier: RiskTierSchema,
++      confidence: z.number(),
++    }),
++    checks: z
++      .object({
++        exposure1hop: z.unknown().optional(),
++        tracing2hop: z.unknown().optional(),
++      })
++      .passthrough()
++      .optional(),
++  })
++  .passthrough();
++
++function clampInt(n: number, min: number, max: number) {
++  return Math.max(min, Math.min(max, Math.round(n)));
++}
++
++function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
++  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
++  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
++    return exposure.window;
++  }
++
++  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
++  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
++    return tracing.window;
++  }
++
++  return { lookbackDays: 90 };
++}
++
++async function getAuthenticatedUserId(): Promise<string | null> {
++  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
++  try {
++    const { userId } = await auth();
++    return userId ?? null;
++  } catch {
++    return null;
++  }
++}
++
++export async function POST(request: Request) {
++  const userId = await getAuthenticatedUserId();
++  if (!userId) {
++    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
++  }
++
++  if (!process.env.ADDRESS_HASH_KEY) {
++    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
++  }
++
++  const db = getDb();
++  if (!db) {
++    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
++  }
++
++  const settings = await getUserSettings(db, userId);
++  if (!settings?.loggingEnabled) {
++    return NextResponse.json(
++      { error: "Saving is disabled. Enable it in Settings first." },
++      { status: 403, headers: { "Cache-Control": "no-store" } },
++    );
++  }
++
++  let json: unknown;
++  try {
++    json = await request.json();
++  } catch {
++    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
++  }
++
++  const parsed = SaveReportBodySchema.safeParse(json);
++  if (!parsed.success) {
++    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
++  }
++
++  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
++  if (!reportParsed.success) {
++    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
++  }
++
++  if (reportParsed.data.address !== parsed.data.address) {
++    return NextResponse.json(
++      { error: "Report address mismatch." },
++      { status: 400, headers: { "Cache-Control": "no-store" } },
++    );
++  }
++
++  const report = reportParsed.data;
++  const created = await createSavedReport(db, userId, {
++    address: parsed.data.address,
++    riskScore: clampInt(report.risk.score, 0, 100),
++    riskTier: report.risk.tier,
++    confidence: clampInt(report.risk.confidence, 0, 100),
++    window: deriveWindow(report),
++    reportJson: parsed.data.report,
++  });
++
++  if (!created) {
++    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
++  }
++
++  return NextResponse.json(
++    { id: created.id, createdAt: created.createdAt },
++    { status: 200, headers: { "Cache-Control": "no-store" } },
++  );
++}
+diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
+index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
+--- a/src/components/blacklist-checker.tsx
++++ b/src/components/blacklist-checker.tsx
+@@ -506,6 +506,108 @@
+   );
+ }
+ 
++function SaveReportControl({ report }: { report: ApiResponse }) {
++  const { isLoaded, isSignedIn } = useAuth();
++  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
++  const [saveState, setSaveState] = React.useState<
++    | { state: "idle" }
++    | { state: "saving" }
++    | { state: "saved"; id?: string }
++  >({ state: "idle" });
++
++  React.useEffect(() => {
++    setSaveState({ state: "idle" });
++  }, [report.address, report.timestamps.checkedAtIso]);
++
++  React.useEffect(() => {
++    if (!isLoaded || !isSignedIn) return;
++    let cancelled = false;
++
++    async function loadSettings() {
++      try {
++        const res = await fetch("/api/user-settings", { credentials: "include" });
++        const json = (await res.json().catch(() => null)) as unknown;
++        if (!res.ok || !json || typeof json !== "object") return;
++
++        const obj = json as Record<string, unknown>;
++        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
++        if (cancelled) return;
++        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
++      } catch {
++        // ignore
++      }
++    }
++
++    loadSettings();
++    return () => {
++      cancelled = true;
++    };
++  }, [isLoaded, isSignedIn]);
++
++  if (!report.access?.authenticated) return null;
++  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
++
++  async function saveReport() {
++    if (saveState.state === "saving" || saveState.state === "saved") return;
++
++    setSaveState({ state: "saving" });
++    try {
++      const res = await fetch("/api/saved-reports", {
++        method: "POST",
++        headers: { "content-type": "application/json" },
++        credentials: "include",
++        body: JSON.stringify({ address: report.address, report }),
++      });
++
++      const json = (await res.json().catch(() => null)) as unknown;
++      if (!res.ok) {
++        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
++        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
++        setSaveState({ state: "idle" });
++        return;
++      }
++
++      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
++      toast.success("Report saved.");
++      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
++    } catch {
++      toast.error("Network error.");
++      setSaveState({ state: "idle" });
++    }
++  }
++
++  const saving = saveState.state === "saving";
++  const saved = saveState.state === "saved";
++
++  return (
++    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
++      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
++        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
++          <div className="min-w-0">
++            <div className="text-sm font-medium text-foreground">Save this report</div>
++            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
++          </div>
++          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
++            {saving ? (
++              <>
++                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
++                Saving…
++              </>
++            ) : saved ? (
++              <>
++                <Check className="mr-2 h-4 w-4" />
++                Saved
++              </>
++            ) : (
++              "Save"
++            )}
++          </Button>
++        </CardContent>
++      </Card>
++    </motion.div>
++  );
++}
++
+ /* ────────────────────────────────────────────────────────────────────────────
+  * Main Component
+  * ──────────────────────────────────────────────────────────────────────────── */
+@@ -963,6 +1065,12 @@
+                 {/* Status Banner */}
+                 <StatusBanner data={load.data} />
+ 
++                {clerkEnabled && (
++                  <SignedIn>
++                    <SaveReportControl report={load.data} />
++                  </SignedIn>
++                )}
++
+                 {/* Summary Card */}
+                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+diff --git a/middleware.ts b/src/middleware.ts
+index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..078996501b70d8cda7ce43e7ec365481c2b6d808
+--- a/middleware.ts
++++ b/src/middleware.ts
+@@ -1,23 +1,24 @@
+ import { NextResponse } from "next/server";
+ import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
+ 
+-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
++// Note: when using `src/app`, Next expects middleware under `src/` as well.
++const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
+ 
+ const isPublicRoute = createRouteMatcher([
+   "/",
+   "/api/check",
+   "/api/analyze",
+   "/api/user-settings",
++  "/api/saved-reports",
+   "/sign-in(.*)",
+   "/sign-up(.*)",
+ ]);
+ 
+-const clerk = clerkMiddleware((auth, req) => {
++const clerk = clerkMiddleware(async (auth, req) => {
++  const { userId, redirectToSignIn } = await auth();
+   if (isPublicRoute(req)) return;
+-  return auth().then(({ userId, redirectToSignIn }) => {
+-    if (!userId) return redirectToSignIn();
+-    return undefined;
+-  });
++  if (!userId) return redirectToSignIn();
++  return undefined;
+ });
+ 
+ export default clerkEnabled ? clerk : () => NextResponse.next();
+
+exec
+/bin/zsh -lc 'rg -n "<redacted>|<redacted>" .ralph/runs/run-20260123-135210-55147-iter-1.log || true' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 75ms:
+binary file matches (found "\0" byte around offset 1724417)
+file update:
+diff --git a/.ralph/runs/run-20260123-135210-55147-iter-1.log b/.ralph/runs/run-20260123-135210-55147-iter-1.log
+index ad4c4c1a37085a0cbd6f501aebc6fd931f8fa83c..3f1a372c05f0796bd65bcb290335e7d8ab8eea77
+--- a/.ralph/runs/run-20260123-135210-55147-iter-1.log
++++ b/.ralph/runs/run-20260123-135210-55147-iter-1.log
+@@ -7796,8 +7796,8 @@
+ NEXT_PUBLIC_SITE_URL=https://usdt.chikocorp.com
+ 
+ # Clerk (auth)
+-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+-CLERK_SECRET_KEY=<redacted>
++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++CLERK_SECRET_KEY=<redacted>
+ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
+ NEXT_PUBLIC_CLERK_SIGN_UP_URL=/sign-up
+ NEXT_PUBLIC_CLERK_AFTER_SIGN_IN_URL=/
+@@ -41897,3 +41897,2699 @@
+ **Avoiding sensitive information leaks**
+ 
+ I need to ensure we don’t commit any `.env` contents in the future. It’s already done, but I’ll note that any secrets should be redacted in the progress log. The log file will stay untracked after I edit it with `apply_patch`, but I can commit it later. I also considered checking older logs for secrets, but that may not be necessary. I’ll check the `.ralph/.tmp/prompt` file for safety, but it seems fine, so we can go ahead and patch the run log.
++file update
++M /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-135210-55147-iter-1.log
++@@ -7798,4 +7798,4 @@
++ # Clerk (auth)
++-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++-CLERK_SECRET_KEY=<redacted>
+++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+++CLERK_SECRET_KEY=<redacted>
++ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
++                                                                                    apply_patch(auto_approved=true) exited 0 in 72ms:
++Success. Updated the following files:
++M .ralph/runs/run-20260123-135210-55147-iter-1.log
++file update:
++diff --git a/.ralph/runs/run-20260123-135210-55147-iter-1.log b/.ralph/runs/run-20260123-135210-55147-iter-1.log
++index ad4c4c1a37085a0cbd6f501aebc6fd931f8fa83c..fd591bb7283ace1b8f8af92e2899bbc866e576a9
++--- a/.ralph/runs/run-20260123-135210-55147-iter-1.log
+++++ b/.ralph/runs/run-20260123-135210-55147-iter-1.log
++@@ -7796,8 +7796,8 @@
++ NEXT_PUBLIC_SITE_URL=https://usdt.chikocorp.com
++ 
++ # Clerk (auth)
++-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++-CLERK_SECRET_KEY=<redacted>
+++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+++CLERK_SECRET_KEY=<redacted>
++ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
++ NEXT_PUBLIC_CLERK_SIGN_UP_URL=/sign-up
++ NEXT_PUBLIC_CLERK_AFTER_SIGN_IN_URL=/
++@@ -41897,3 +41897,12 @@
++ **Avoiding sensitive information leaks**
++ 
++ I need to ensure we don’t commit any `.env` contents in the future. It’s already done, but I’ll note that any secrets should be redacted in the progress log. The log file will stay untracked after I edit it with `apply_patch`, but I can commit it later. I also considered checking older logs for secrets, but that may not be necessary. I’ll check the `.ralph/.tmp/prompt` file for safety, but it seems fine, so we can go ahead and patch the run log.
+++file update
+++M /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-135210-55147-iter-1.log
+++@@ -7798,4 +7798,4 @@
+++ # Clerk (auth)
+++-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+++-CLERK_SECRET_KEY=<redacted>
++++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++++CLERK_SECRET_KEY=<redacted>
+++ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
++diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
++new file mode 100644
++index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
++--- /dev/null
+++++ b/src/__tests__/api-saved-reports.test.ts
++@@ -0,0 +1,107 @@
+++import { beforeEach, describe, expect, it, vi } from "vitest";
+++
+++const auth = vi.fn();
+++vi.mock("@clerk/nextjs/server", () => ({ auth }));
+++
+++const getDb = vi.fn();
+++vi.mock("@/lib/db", () => ({ getDb }));
+++
+++const getUserSettings = vi.fn();
+++vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+++
+++const createSavedReport = vi.fn();
+++vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+++
+++const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+++
+++async function callPost(body: unknown) {
+++  const { POST } = await import("@/app/api/saved-reports/route");
+++  const req = new Request("http://localhost/api/saved-reports", {
+++    method: "POST",
+++    headers: { "content-type": "application/json" },
+++    body: JSON.stringify(body),
+++  });
+++  const res = await POST(req);
+++  const json = await res.json().catch(() => null);
+++  return { res, json };
+++}
+++
+++beforeEach(() => {
+++  vi.resetModules();
+++  vi.clearAllMocks();
+++  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+++  process.env.CLERK_SECRET_KEY = "sk_test_123";
+++  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+++});
+++
+++describe("/api/saved-reports", () => {
+++  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+++    auth.mockResolvedValue({ userId: null });
+++
+++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+++    expect(res.status).toBe(401);
+++    expect(getDb).not.toHaveBeenCalled();
+++    expect(getUserSettings).not.toHaveBeenCalled();
+++    expect(createSavedReport).not.toHaveBeenCalled();
+++  });
+++
+++  it("returns 503 when persistence is disabled", async () => {
+++    auth.mockResolvedValue({ userId: "user_123" });
+++    getDb.mockReturnValue(null);
+++
+++    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+++    expect(res.status).toBe(503);
+++    expect(json?.error).toBeTypeOf("string");
+++    expect(getUserSettings).not.toHaveBeenCalled();
+++    expect(createSavedReport).not.toHaveBeenCalled();
+++  });
+++
+++  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+++    auth.mockResolvedValue({ userId: "user_123" });
+++    getDb.mockReturnValue({});
+++    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+++
+++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+++    expect(res.status).toBe(403);
+++    expect(createSavedReport).not.toHaveBeenCalled();
+++  });
+++
+++  it("validates payload and rejects mismatched report addresses", async () => {
+++    auth.mockResolvedValue({ userId: "user_123" });
+++    getDb.mockReturnValue({});
+++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+++
+++    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+++    const { res } = await callPost({ address: VALID_ADDRESS, report });
+++    expect(res.status).toBe(400);
+++    expect(createSavedReport).not.toHaveBeenCalled();
+++  });
+++
+++  it("creates a SavedReport and returns its id", async () => {
+++    auth.mockResolvedValue({ userId: "user_123" });
+++    getDb.mockReturnValue({});
+++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+++    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+++
+++    const report = {
+++      address: VALID_ADDRESS,
+++      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+++      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+++    };
+++
+++    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+++    expect(res.status).toBe(200);
+++    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+++    expect(createSavedReport).toHaveBeenCalledWith(
+++      {},
+++      "user_123",
+++      expect.objectContaining({
+++        address: VALID_ADDRESS,
+++        riskScore: 55,
+++        riskTier: "high",
+++        confidence: 92,
+++        window: { lookbackDays: 90 },
+++      }),
+++    );
+++  });
+++});
++diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
++new file mode 100644
++index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
++--- /dev/null
+++++ b/src/app/api/saved-reports/route.ts
++@@ -0,0 +1,130 @@
+++import { NextResponse } from "next/server";
+++import { auth } from "@clerk/nextjs/server";
+++import { z } from "zod";
+++
+++import { getDb } from "@/lib/db";
+++import { createSavedReport } from "@/lib/db/saved-reports";
+++import { getUserSettings } from "@/lib/db/user-settings";
+++import { TronAddressSchema } from "@/lib/validators";
+++
+++export const runtime = "nodejs";
+++
+++const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+++
+++const SaveReportBodySchema = z.object({
+++  address: TronAddressSchema,
+++  report: z.unknown(),
+++});
+++
+++const AnalyzeReportSchema = z
+++  .object({
+++    address: TronAddressSchema,
+++    risk: z.object({
+++      score: z.number(),
+++      tier: RiskTierSchema,
+++      confidence: z.number(),
+++    }),
+++    checks: z
+++      .object({
+++        exposure1hop: z.unknown().optional(),
+++        tracing2hop: z.unknown().optional(),
+++      })
+++      .passthrough()
+++      .optional(),
+++  })
+++  .passthrough();
+++
+++function clampInt(n: number, min: number, max: number) {
+++  return Math.max(min, Math.min(max, Math.round(n)));
+++}
+++
+++function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+++  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+++  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+++    return exposure.window;
+++  }
+++
+++  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+++  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+++    return tracing.window;
+++  }
+++
+++  return { lookbackDays: 90 };
+++}
+++
+++async function getAuthenticatedUserId(): Promise<string | null> {
+++  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+++  try {
+++    const { userId } = await auth();
+++    return userId ?? null;
+++  } catch {
+++    return null;
+++  }
+++}
+++
+++export async function POST(request: Request) {
+++  const userId = await getAuthenticatedUserId();
+++  if (!userId) {
+++    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+++  }
+++
+++  if (!process.env.ADDRESS_HASH_KEY) {
+++    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+++  }
+++
+++  const db = getDb();
+++  if (!db) {
+++    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+++  }
+++
+++  const settings = await getUserSettings(db, userId);
+++  if (!settings?.loggingEnabled) {
+++    return NextResponse.json(
+++      { error: "Saving is disabled. Enable it in Settings first." },
+++      { status: 403, headers: { "Cache-Control": "no-store" } },
+++    );
+++  }
+++
+++  let json: unknown;
+++  try {
+++    json = await request.json();
+++  } catch {
+++    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+++  }
+++
+++  const parsed = SaveReportBodySchema.safeParse(json);
+++  if (!parsed.success) {
+++    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+++  }
+++
+++  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+++  if (!reportParsed.success) {
+++    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+++  }
+++
+++  if (reportParsed.data.address !== parsed.data.address) {
+++    return NextResponse.json(
+++      { error: "Report address mismatch." },
+++      { status: 400, headers: { "Cache-Control": "no-store" } },
+++    );
+++  }
+++
+++  const report = reportParsed.data;
+++  const created = await createSavedReport(db, userId, {
+++    address: parsed.data.address,
+++    riskScore: clampInt(report.risk.score, 0, 100),
+++    riskTier: report.risk.tier,
+++    confidence: clampInt(report.risk.confidence, 0, 100),
+++    window: deriveWindow(report),
+++    reportJson: parsed.data.report,
+++  });
+++
+++  if (!created) {
+++    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+++  }
+++
+++  return NextResponse.json(
+++    { id: created.id, createdAt: created.createdAt },
+++    { status: 200, headers: { "Cache-Control": "no-store" } },
+++  );
+++}
++diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
++index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
++--- a/src/components/blacklist-checker.tsx
+++++ b/src/components/blacklist-checker.tsx
++@@ -506,6 +506,108 @@
++   );
++ }
++ 
+++function SaveReportControl({ report }: { report: ApiResponse }) {
+++  const { isLoaded, isSignedIn } = useAuth();
+++  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+++  const [saveState, setSaveState] = React.useState<
+++    | { state: "idle" }
+++    | { state: "saving" }
+++    | { state: "saved"; id?: string }
+++  >({ state: "idle" });
+++
+++  React.useEffect(() => {
+++    setSaveState({ state: "idle" });
+++  }, [report.address, report.timestamps.checkedAtIso]);
+++
+++  React.useEffect(() => {
+++    if (!isLoaded || !isSignedIn) return;
+++    let cancelled = false;
+++
+++    async function loadSettings() {
+++      try {
+++        const res = await fetch("/api/user-settings", { credentials: "include" });
+++        const json = (await res.json().catch(() => null)) as unknown;
+++        if (!res.ok || !json || typeof json !== "object") return;
+++
+++        const obj = json as Record<string, unknown>;
+++        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+++        if (cancelled) return;
+++        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+++      } catch {
+++        // ignore
+++      }
+++    }
+++
+++    loadSettings();
+++    return () => {
+++      cancelled = true;
+++    };
+++  }, [isLoaded, isSignedIn]);
+++
+++  if (!report.access?.authenticated) return null;
+++  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+++
+++  async function saveReport() {
+++    if (saveState.state === "saving" || saveState.state === "saved") return;
+++
+++    setSaveState({ state: "saving" });
+++    try {
+++      const res = await fetch("/api/saved-reports", {
+++        method: "POST",
+++        headers: { "content-type": "application/json" },
+++        credentials: "include",
+++        body: JSON.stringify({ address: report.address, report }),
+++      });
+++
+++      const json = (await res.json().catch(() => null)) as unknown;
+++      if (!res.ok) {
+++        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+++        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+++        setSaveState({ state: "idle" });
+++        return;
+++      }
+++
+++      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+++      toast.success("Report saved.");
+++      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+++    } catch {
+++      toast.error("Network error.");
+++      setSaveState({ state: "idle" });
+++    }
+++  }
+++
+++  const saving = saveState.state === "saving";
+++  const saved = saveState.state === "saved";
+++
+++  return (
+++    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+++      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+++        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+++          <div className="min-w-0">
+++            <div className="text-sm font-medium text-foreground">Save this report</div>
+++            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+++          </div>
+++          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+++            {saving ? (
+++              <>
+++                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+++                Saving…
+++              </>
+++            ) : saved ? (
+++              <>
+++                <Check className="mr-2 h-4 w-4" />
+++                Saved
+++              </>
+++            ) : (
+++              "Save"
+++            )}
+++          </Button>
+++        </CardContent>
+++      </Card>
+++    </motion.div>
+++  );
+++}
+++
++ /* ────────────────────────────────────────────────────────────────────────────
++  * Main Component
++  * ──────────────────────────────────────────────────────────────────────────── */
++@@ -963,6 +1065,12 @@
++                 {/* Status Banner */}
++                 <StatusBanner data={load.data} />
++ 
+++                {clerkEnabled && (
+++                  <SignedIn>
+++                    <SaveReportControl report={load.data} />
+++                  </SignedIn>
+++                )}
+++
++                 {/* Summary Card */}
++                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
++                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
++diff --git a/middleware.ts b/src/middleware.ts
++index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..078996501b70d8cda7ce43e7ec365481c2b6d808
++--- a/middleware.ts
+++++ b/src/middleware.ts
++@@ -1,23 +1,24 @@
++ import { NextResponse } from "next/server";
++ import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
++ 
++-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
+++// Note: when using `src/app`, Next expects middleware under `src/` as well.
+++const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
++ 
++ const isPublicRoute = createRouteMatcher([
++   "/",
++   "/api/check",
++   "/api/analyze",
++   "/api/user-settings",
+++  "/api/saved-reports",
++   "/sign-in(.*)",
++   "/sign-up(.*)",
++ ]);
++ 
++-const clerk = clerkMiddleware((auth, req) => {
+++const clerk = clerkMiddleware(async (auth, req) => {
+++  const { userId, redirectToSignIn } = await auth();
++   if (isPublicRoute(req)) return;
++-  return auth().then(({ userId, redirectToSignIn }) => {
++-    if (!userId) return redirectToSignIn();
++-    return undefined;
++-  });
+++  if (!userId) return redirectToSignIn();
+++  return undefined;
++ });
++ 
++ export default clerkEnabled ? clerk : () => NextResponse.next();
++
++file update:
++diff --git a/.ralph/runs/run-20260123-135210-55147-iter-1.log b/.ralph/runs/run-20260123-135210-55147-iter-1.log
++index ad4c4c1a37085a0cbd6f501aebc6fd931f8fa83c..8ff13182c69ae44725abb1e2976f05d93f4e63a2
++--- a/.ralph/runs/run-20260123-135210-55147-iter-1.log
+++++ b/.ralph/runs/run-20260123-135210-55147-iter-1.log
++@@ -7796,8 +7796,8 @@
++ NEXT_PUBLIC_SITE_URL=https://usdt.chikocorp.com
++ 
++ # Clerk (auth)
++-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++-CLERK_SECRET_KEY=<redacted>
+++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+++CLERK_SECRET_KEY=<redacted>
++ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
++ NEXT_PUBLIC_CLERK_SIGN_UP_URL=/sign-up
++ NEXT_PUBLIC_CLERK_AFTER_SIGN_IN_URL=/
++@@ -41897,3 +41897,228 @@
++ **Avoiding sensitive information leaks**
++ 
++ I need to ensure we don’t commit any `.env` contents in the future. It’s already done, but I’ll note that any secrets should be redacted in the progress log. The log file will stay untracked after I edit it with `apply_patch`, but I can commit it later. I also considered checking older logs for secrets, but that may not be necessary. I’ll check the `.ralph/.tmp/prompt` file for safety, but it seems fine, so we can go ahead and patch the run log.
+++file update
+++M /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-135210-55147-iter-1.log
+++@@ -7798,4 +7798,4 @@
+++ # Clerk (auth)
+++-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+++-CLERK_SECRET_KEY=<redacted>
++++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++++CLERK_SECRET_KEY=<redacted>
+++ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
+++                                                                                    apply_patch(auto_approved=true) exited 0 in 72ms:
+++Success. Updated the following files:
+++M .ralph/runs/run-20260123-135210-55147-iter-1.log
+++file update:
+++diff --git a/.ralph/runs/run-20260123-135210-55147-iter-1.log b/.ralph/runs/run-20260123-135210-55147-iter-1.log
+++index ad4c4c1a37085a0cbd6f501aebc6fd931f8fa83c..fd591bb7283ace1b8f8af92e2899bbc866e576a9
+++--- a/.ralph/runs/run-20260123-135210-55147-iter-1.log
++++++ b/.ralph/runs/run-20260123-135210-55147-iter-1.log
+++@@ -7796,8 +7796,8 @@
+++ NEXT_PUBLIC_SITE_URL=https://usdt.chikocorp.com
+++ 
+++ # Clerk (auth)
+++-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+++-CLERK_SECRET_KEY=<redacted>
++++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++++CLERK_SECRET_KEY=<redacted>
+++ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
+++ NEXT_PUBLIC_CLERK_SIGN_UP_URL=/sign-up
+++ NEXT_PUBLIC_CLERK_AFTER_SIGN_IN_URL=/
+++@@ -41897,3 +41897,12 @@
+++ **Avoiding sensitive information leaks**
+++ 
+++ I need to ensure we don’t commit any `.env` contents in the future. It’s already done, but I’ll note that any secrets should be redacted in the progress log. The log file will stay untracked after I edit it with `apply_patch`, but I can commit it later. I also considered checking older logs for secrets, but that may not be necessary. I’ll check the `.ralph/.tmp/prompt` file for safety, but it seems fine, so we can go ahead and patch the run log.
++++file update
++++M /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-135210-55147-iter-1.log
++++@@ -7798,4 +7798,4 @@
++++ # Clerk (auth)
++++-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++++-CLERK_SECRET_KEY=<redacted>
+++++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+++++CLERK_SECRET_KEY=<redacted>
++++ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
+++diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
+++new file mode 100644
+++index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
+++--- /dev/null
++++++ b/src/__tests__/api-saved-reports.test.ts
+++@@ -0,0 +1,107 @@
++++import { beforeEach, describe, expect, it, vi } from "vitest";
++++
++++const auth = vi.fn();
++++vi.mock("@clerk/nextjs/server", () => ({ auth }));
++++
++++const getDb = vi.fn();
++++vi.mock("@/lib/db", () => ({ getDb }));
++++
++++const getUserSettings = vi.fn();
++++vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
++++
++++const createSavedReport = vi.fn();
++++vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
++++
++++const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
++++
++++async function callPost(body: unknown) {
++++  const { POST } = await import("@/app/api/saved-reports/route");
++++  const req = new Request("http://localhost/api/saved-reports", {
++++    method: "POST",
++++    headers: { "content-type": "application/json" },
++++    body: JSON.stringify(body),
++++  });
++++  const res = await POST(req);
++++  const json = await res.json().catch(() => null);
++++  return { res, json };
++++}
++++
++++beforeEach(() => {
++++  vi.resetModules();
++++  vi.clearAllMocks();
++++  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
++++  process.env.CLERK_SECRET_KEY = "sk_test_123";
++++  process.env.ADDRESS_HASH_KEY = "test_hash_key";
++++});
++++
++++describe("/api/saved-reports", () => {
++++  it("returns 401 when unauthenticated and does not touch the DB", async () => {
++++    auth.mockResolvedValue({ userId: null });
++++
++++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
++++    expect(res.status).toBe(401);
++++    expect(getDb).not.toHaveBeenCalled();
++++    expect(getUserSettings).not.toHaveBeenCalled();
++++    expect(createSavedReport).not.toHaveBeenCalled();
++++  });
++++
++++  it("returns 503 when persistence is disabled", async () => {
++++    auth.mockResolvedValue({ userId: "user_123" });
++++    getDb.mockReturnValue(null);
++++
++++    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
++++    expect(res.status).toBe(503);
++++    expect(json?.error).toBeTypeOf("string");
++++    expect(getUserSettings).not.toHaveBeenCalled();
++++    expect(createSavedReport).not.toHaveBeenCalled();
++++  });
++++
++++  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
++++    auth.mockResolvedValue({ userId: "user_123" });
++++    getDb.mockReturnValue({});
++++    getUserSettings.mockResolvedValue({ loggingEnabled: false });
++++
++++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
++++    expect(res.status).toBe(403);
++++    expect(createSavedReport).not.toHaveBeenCalled();
++++  });
++++
++++  it("validates payload and rejects mismatched report addresses", async () => {
++++    auth.mockResolvedValue({ userId: "user_123" });
++++    getDb.mockReturnValue({});
++++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
++++
++++    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
++++    const { res } = await callPost({ address: VALID_ADDRESS, report });
++++    expect(res.status).toBe(400);
++++    expect(createSavedReport).not.toHaveBeenCalled();
++++  });
++++
++++  it("creates a SavedReport and returns its id", async () => {
++++    auth.mockResolvedValue({ userId: "user_123" });
++++    getDb.mockReturnValue({});
++++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
++++    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
++++
++++    const report = {
++++      address: VALID_ADDRESS,
++++      risk: { score: 55.2, tier: "high", confidence: 91.7 },
++++      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
++++    };
++++
++++    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
++++    expect(res.status).toBe(200);
++++    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
++++    expect(createSavedReport).toHaveBeenCalledWith(
++++      {},
++++      "user_123",
++++      expect.objectContaining({
++++        address: VALID_ADDRESS,
++++        riskScore: 55,
++++        riskTier: "high",
++++        confidence: 92,
++++        window: { lookbackDays: 90 },
++++      }),
++++    );
++++  });
++++});
+++diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
+++new file mode 100644
+++index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
+++--- /dev/null
++++++ b/src/app/api/saved-reports/route.ts
+++@@ -0,0 +1,130 @@
++++import { NextResponse } from "next/server";
++++import { auth } from "@clerk/nextjs/server";
++++import { z } from "zod";
++++
++++import { getDb } from "@/lib/db";
++++import { createSavedReport } from "@/lib/db/saved-reports";
++++import { getUserSettings } from "@/lib/db/user-settings";
++++import { TronAddressSchema } from "@/lib/validators";
++++
++++export const runtime = "nodejs";
++++
++++const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
++++
++++const SaveReportBodySchema = z.object({
++++  address: TronAddressSchema,
++++  report: z.unknown(),
++++});
++++
++++const AnalyzeReportSchema = z
++++  .object({
++++    address: TronAddressSchema,
++++    risk: z.object({
++++      score: z.number(),
++++      tier: RiskTierSchema,
++++      confidence: z.number(),
++++    }),
++++    checks: z
++++      .object({
++++        exposure1hop: z.unknown().optional(),
++++        tracing2hop: z.unknown().optional(),
++++      })
++++      .passthrough()
++++      .optional(),
++++  })
++++  .passthrough();
++++
++++function clampInt(n: number, min: number, max: number) {
++++  return Math.max(min, Math.min(max, Math.round(n)));
++++}
++++
++++function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
++++  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
++++  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
++++    return exposure.window;
++++  }
++++
++++  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
++++  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
++++    return tracing.window;
++++  }
++++
++++  return { lookbackDays: 90 };
++++}
++++
++++async function getAuthenticatedUserId(): Promise<string | null> {
++++  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
++++  try {
++++    const { userId } = await auth();
++++    return userId ?? null;
++++  } catch {
++++    return null;
++++  }
++++}
++++
++++export async functi
++\ No newline at end of file
++diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
++new file mode 100644
++index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
++--- /dev/null
+++++ b/src/__tests__/api-saved-reports.test.ts
++@@ -0,0 +1,107 @@
+++import { beforeEach, describe, expect, it, vi } from "vitest";
+++
+++const auth = vi.fn();
+++vi.mock("@clerk/nextjs/server", () => ({ auth }));
+++
+++const getDb = vi.fn();
+++vi.mock("@/lib/db", () => ({ getDb }));
+++
+++const getUserSettings = vi.fn();
+++vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+++
+++const createSavedReport = vi.fn();
+++vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+++
+++const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+++
+++async function callPost(body: unknown) {
+++  const { POST } = await import("@/app/api/saved-reports/route");
+++  const req = new Request("http://localhost/api/saved-reports", {
+++    method: "POST",
+++    headers: { "content-type": "application/json" },
+++    body: JSON.stringify(body),
+++  });
+++  const res = await POST(req);
+++  const json = await res.json().catch(() => null);
+++  return { res, json };
+++}
+++
+++beforeEach(() => {
+++  vi.resetModules();
+++  vi.clearAllMocks();
+++  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+++  process.env.CLERK_SECRET_KEY = "sk_test_123";
+++  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+++});
+++
+++describe("/api/saved-reports", () => {
+++  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+++    auth.mockResolvedValue({ userId: null });
+++
+++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+++    expect(res.status).toBe(401);
+++    expect(getDb).not.toHaveBeenCalled();
+++    expect(getUserSettings).not.toHaveBeenCalled();
+++    expect(createSavedReport).not.toHaveBeenCalled();
+++  });
+++
+++  it("returns 503 when persistence is disabled", async () => {
+++    auth.mockResolvedValue({ userId: "user_123" });
+++    getDb.mockReturnValue(null);
+++
+++    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+++    expect(res.status).toBe(503);
+++    expect(json?.error).toBeTypeOf("string");
+++    expect(getUserSettings).not.toHaveBeenCalled();
+++    expect(createSavedReport).not.toHaveBeenCalled();
+++  });
+++
+++  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+++    auth.mockResolvedValue({ userId: "user_123" });
+++    getDb.mockReturnValue({});
+++    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+++
+++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+++    expect(res.status).toBe(403);
+++    expect(createSavedReport).not.toHaveBeenCalled();
+++  });
+++
+++  it("validates payload and rejects mismatched report addresses", async () => {
+++    auth.mockResolvedValue({ userId: "user_123" });
+++    getDb.mockReturnValue({});
+++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+++
+++    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+++    const { res } = await callPost({ address: VALID_ADDRESS, report });
+++    expect(res.status).toBe(400);
+++    expect(createSavedReport).not.toHaveBeenCalled();
+++  });
+++
+++  it("creates a SavedReport and returns its id", async () => {
+++    auth.mockResolvedValue({ userId: "user_123" });
+++    getDb.mockReturnValue({});
+++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+++    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+++
+++    const report = {
+++      address: VALID_ADDRESS,
+++      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+++      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+++    };
+++
+++    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+++    expect(res.status).toBe(200);
+++    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+++    expect(createSavedReport).toHaveBeenCalledWith(
+++      {},
+++      "user_123",
+++      expect.objectContaining({
+++        address: VALID_ADDRESS,
+++        riskScore: 55,
+++        riskTier: "high",
+++        confidence: 92,
+++        window: { lookbackDays: 90 },
+++      }),
+++    );
+++  });
+++});
++diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
++new file mode 100644
++index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
++--- /dev/null
+++++ b/src/app/api/saved-reports/route.ts
++@@ -0,0 +1,130 @@
+++import { NextResponse } from "next/server";
+++import { auth } from "@clerk/nextjs/server";
+++import { z } from "zod";
+++
+++import { getDb } from "@/lib/db";
+++import { createSavedReport } from "@/lib/db/saved-reports";
+++import { getUserSettings } from "@/lib/db/user-settings";
+++import { TronAddressSchema } from "@/lib/validators";
+++
+++export const runtime = "nodejs";
+++
+++const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+++
+++const SaveReportBodySchema = z.object({
+++  address: TronAddressSchema,
+++  report: z.unknown(),
+++});
+++
+++const AnalyzeReportSchema = z
+++  .object({
+++    address: TronAddressSchema,
+++    risk: z.object({
+++      score: z.number(),
+++      tier: RiskTierSchema,
+++      confidence: z.number(),
+++    }),
+++    checks: z
+++      .object({
+++        exposure1hop: z.unknown().optional(),
+++        tracing2hop: z.unknown().optional(),
+++      })
+++      .passthrough()
+++      .optional(),
+++  })
+++  .passthrough();
+++
+++function clampInt(n: number, min: number, max: number) {
+++  return Math.max(min, Math.min(max, Math.round(n)));
+++}
+++
+++function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+++  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+++  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+++    return exposure.window;
+++  }
+++
+++  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+++  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+++    return tracing.window;
+++  }
+++
+++  return { lookbackDays: 90 };
+++}
+++
+++async function getAuthenticatedUserId(): Promise<string | null> {
+++  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+++  try {
+++    const { userId } = await auth();
+++    return userId ?? null;
+++  } catch {
+++    return null;
+++  }
+++}
+++
+++export async function POST(request: Request) {
+++  const userId = await getAuthenticatedUserId();
+++  if (!userId) {
+++    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+++  }
+++
+++  if (!process.env.ADDRESS_HASH_KEY) {
+++    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+++  }
+++
+++  const db = getDb();
+++  if (!db) {
+++    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+++  }
+++
+++  const settings = await getUserSettings(db, userId);
+++  if (!settings?.loggingEnabled) {
+++    return NextResponse.json(
+++      { error: "Saving is disabled. Enable it in Settings first." },
+++      { status: 403, headers: { "Cache-Control": "no-store" } },
+++    );
+++  }
+++
+++  let json: unknown;
+++  try {
+++    json = await request.json();
+++  } catch {
+++    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+++  }
+++
+++  const parsed = SaveReportBodySchema.safeParse(json);
+++  if (!parsed.success) {
+++    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+++  }
+++
+++  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+++  if (!reportParsed.success) {
+++    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+++  }
+++
+++  if (reportParsed.data.address !== parsed.data.address) {
+++    return NextResponse.json(
+++      { error: "Report address mismatch." },
+++      { status: 400, headers: { "Cache-Control": "no-store" } },
+++    );
+++  }
+++
+++  const report = reportParsed.data;
+++  const created = await createSavedReport(db, userId, {
+++    address: parsed.data.address,
+++    riskScore: clampInt(report.risk.score, 0, 100),
+++    riskTier: report.risk.tier,
+++    confidence: clampInt(report.risk.confidence, 0, 100),
+++    window: deriveWindow(report),
+++    reportJson: parsed.data.report,
+++  });
+++
+++  if (!created) {
+++    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+++  }
+++
+++  return NextResponse.json(
+++    { id: created.id, createdAt: created.createdAt },
+++    { status: 200, headers: { "Cache-Control": "no-store" } },
+++  );
+++}
++diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
++index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
++--- a/src/components/blacklist-checker.tsx
+++++ b/src/components/blacklist-checker.tsx
++@@ -506,6 +506,108 @@
++   );
++ }
++ 
+++function SaveReportControl({ report }: { report: ApiResponse }) {
+++  const { isLoaded, isSignedIn } = useAuth();
+++  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+++  const [saveState, setSaveState] = React.useState<
+++    | { state: "idle" }
+++    | { state: "saving" }
+++    | { state: "saved"; id?: string }
+++  >({ state: "idle" });
+++
+++  React.useEffect(() => {
+++    setSaveState({ state: "idle" });
+++  }, [report.address, report.timestamps.checkedAtIso]);
+++
+++  React.useEffect(() => {
+++    if (!isLoaded || !isSignedIn) return;
+++    let cancelled = false;
+++
+++    async function loadSettings() {
+++      try {
+++        const res = await fetch("/api/user-settings", { credentials: "include" });
+++        const json = (await res.json().catch(() => null)) as unknown;
+++        if (!res.ok || !json || typeof json !== "object") return;
+++
+++        const obj = json as Record<string, unknown>;
+++        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+++        if (cancelled) return;
+++        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+++      } catch {
+++        // ignore
+++      }
+++    }
+++
+++    loadSettings();
+++    return () => {
+++      cancelled = true;
+++    };
+++  }, [isLoaded, isSignedIn]);
+++
+++  if (!report.access?.authenticated) return null;
+++  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+++
+++  async function saveReport() {
+++    if (saveState.state === "saving" || saveState.state === "saved") return;
+++
+++    setSaveState({ state: "saving" });
+++    try {
+++      const res = await fetch("/api/saved-reports", {
+++        method: "POST",
+++        headers: { "content-type": "application/json" },
+++        credentials: "include",
+++        body: JSON.stringify({ address: report.address, report }),
+++      });
+++
+++      const json = (await res.json().catch(() => null)) as unknown;
+++      if (!res.ok) {
+++        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+++        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+++        setSaveState({ state: "idle" });
+++        return;
+++      }
+++
+++      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+++      toast.success("Report saved.");
+++      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+++    } catch {
+++      toast.error("Network error.");
+++      setSaveState({ state: "idle" });
+++    }
+++  }
+++
+++  const saving = saveState.state === "saving";
+++  const saved = saveState.state === "saved";
+++
+++  return (
+++    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+++      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+++        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+++          <div className="min-w-0">
+++            <div className="text-sm font-medium text-foreground">Save this report</div>
+++            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+++          </div>
+++          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+++            {saving ? (
+++              <>
+++                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+++                Saving…
+++              </>
+++            ) : saved ? (
+++              <>
+++                <Check className="mr-2 h-4 w-4" />
+++                Saved
+++              </>
+++            ) : (
+++              "Save"
+++            )}
+++          </Button>
+++        </CardContent>
+++      </Card>
+++    </motion.div>
+++  );
+++}
+++
++ /* ────────────────────────────────────────────────────────────────────────────
++  * Main Component
++  * ──────────────────────────────────────────────────────────────────────────── */
++@@ -963,6 +1065,12 @@
++                 {/* Status Banner */}
++                 <StatusBanner data={load.data} />
++ 
+++                {clerkEnabled && (
+++                  <SignedIn>
+++                    <SaveReportControl report={load.data} />
+++                  </SignedIn>
+++                )}
+++
++                 {/* Summary Card */}
++                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
++                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
++diff --git a/middleware.ts b/src/middleware.ts
++index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..078996501b70d8cda7ce43e7ec365481c2b6d808
++--- a/middleware.ts
+++++ b/src/middleware.ts
++@@ -1,23 +1,24 @@
++ import { NextResponse } from "next/server";
++ import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
++ 
++-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
+++// Note: when using `src/app`, Next expects middleware under `src/` as well.
+++const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
++ 
++ const isPublicRoute = createRouteMatcher([
++   "/",
++   "/api/check",
++   "/api/analyze",
++   "/api/user-settings",
+++  "/api/saved-reports",
++   "/sign-in(.*)",
++   "/sign-up(.*)",
++ ]);
++ 
++-const clerk = clerkMiddleware((auth, req) => {
+++const clerk = clerkMiddleware(async (auth, req) => {
+++  const { userId, redirectToSignIn } = await auth();
++   if (isPublicRoute(req)) return;
++-  return auth().then(({ userId, redirectToSignIn }) => {
++-    if (!userId) return redirectToSignIn();
++-    return undefined;
++-  });
+++  if (!userId) return redirectToSignIn();
+++  return undefined;
++ });
++ 
++ export default clerkEnabled ? clerk : () => NextResponse.next();
++
++exec
++/bin/zsh -lc 'rg -n "sk_test_|pk_test_a25v|CLERK_SECRET_KEY=sk_test|NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=pk_test" .ralph/runs/run-20260123-135210-55147-iter-1.log || true' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 76ms:
++3309:  process.env.CLERK_SECRET_KEY = "sk_test_123";
++3438:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++3824:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++4213:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++4608:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++5008:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++5405:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++5813:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++6221:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++6610:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++7005:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++7413:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++7860:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++8256:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++8669:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++9077:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++9478:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++9867:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++10213:   process.env.CLERK_SECRET_KEY = "sk_test_123";
++10273:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++file update:
++diff --git a/.ralph/runs/run-20260123-135210-55147-iter-1.log b/.ralph/runs/run-20260123-135210-55147-iter-1.log
++index ad4c4c1a37085a0cbd6f501aebc6fd931f8fa83c..952216517f94d24bb59a56b3c137f57854ac883d
++--- a/.ralph/runs/run-20260123-135210-55147-iter-1.log
+++++ b/.ralph/runs/run-20260123-135210-55147-iter-1.log
++@@ -7796,8 +7796,8 @@
++ NEXT_PUBLIC_SITE_URL=https://usdt.chikocorp.com
++ 
++ # Clerk (auth)
++-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++-CLERK_SECRET_KEY=<redacted>
+++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+++CLERK_SECRET_KEY=<redacted>
++ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
++ NEXT_PUBLIC_CLERK_SIGN_UP_URL=/sign-up
++ NEXT_PUBLIC_CLERK_AFTER_SIGN_IN_URL=/
++@@ -41897,3 +41897,1134 @@
++ **Avoiding sensitive information leaks**
++ 
++ I need to ensure we don’t commit any `.env` contents in the future. It’s already done, but I’ll note that any secrets should be redacted in the progress log. The log file will stay untracked after I edit it with `apply_patch`, but I can commit it later. I also considered checking older logs for secrets, but that may not be necessary. I’ll check the `.ralph/.tmp/prompt` file for safety, but it seems fine, so we can go ahead and patch the run log.
+++file update
+++M /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-135210-55147-iter-1.log
+++@@ -7798,4 +7798,4 @@
+++ # Clerk (auth)
+++-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+++-CLERK_SECRET_KEY=<redacted>
++++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++++CLERK_SECRET_KEY=<redacted>
+++ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
+++                                                                                    apply_patch(auto_approved=true) exited 0 in 72ms:
+++Success. Updated the following files:
+++M .ralph/runs/run-20260123-135210-55147-iter-1.log
+++file update:
+++diff --git a/.ralph/runs/run-20260123-135210-55147-iter-1.log b/.ralph/runs/run-20260123-135210-55147-iter-1.log
+++index ad4c4c1a37085a0cbd6f501aebc6fd931f8fa83c..fd591bb7283ace1b8f8af92e2899bbc866e576a9
+++--- a/.ralph/runs/run-20260123-135210-55147-iter-1.log
++++++ b/.ralph/runs/run-20260123-135210-55147-iter-1.log
+++@@ -7796,8 +7796,8 @@
+++ NEXT_PUBLIC_SITE_URL=https://usdt.chikocorp.com
+++ 
+++ # Clerk (auth)
+++-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+++-CLERK_SECRET_KEY=<redacted>
++++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++++CLERK_SECRET_KEY=<redacted>
+++ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
+++ NEXT_PUBLIC_CLERK_SIGN_UP_URL=/sign-up
+++ NEXT_PUBLIC_CLERK_AFTER_SIGN_IN_URL=/
+++@@ -41897,3 +41897,12 @@
+++ **Avoiding sensitive information leaks**
+++ 
+++ I need to ensure we don’t commit any `.env` contents in the future. It’s already done, but I’ll note that any secrets should be redacted in the progress log. The log file will stay untracked after I edit it with `apply_patch`, but I can commit it later. I also considered checking older logs for secrets, but that may not be necessary. I’ll check the `.ralph/.tmp/prompt` file for safety, but it seems fine, so we can go ahead and patch the run log.
++++file update
++++M /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-135210-55147-iter-1.log
++++@@ -7798,4 +7798,4 @@
++++ # Clerk (auth)
++++-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++++-CLERK_SECRET_KEY=<redacted>
+++++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+++++CLERK_SECRET_KEY=<redacted>
++++ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
+++diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
+++new file mode 100644
+++index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
+++--- /dev/null
++++++ b/src/__tests__/api-saved-reports.test.ts
+++@@ -0,0 +1,107 @@
++++import { beforeEach, describe, expect, it, vi } from "vitest";
++++
++++const auth = vi.fn();
++++vi.mock("@clerk/nextjs/server", () => ({ auth }));
++++
++++const getDb = vi.fn();
++++vi.mock("@/lib/db", () => ({ getDb }));
++++
++++const getUserSettings = vi.fn();
++++vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
++++
++++const createSavedReport = vi.fn();
++++vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
++++
++++const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
++++
++++async function callPost(body: unknown) {
++++  const { POST } = await import("@/app/api/saved-reports/route");
++++  const req = new Request("http://localhost/api/saved-reports", {
++++    method: "POST",
++++    headers: { "content-type": "application/json" },
++++    body: JSON.stringify(body),
++++  });
++++  const res = await POST(req);
++++  const json = await res.json().catch(() => null);
++++  return { res, json };
++++}
++++
++++beforeEach(() => {
++++  vi.resetModules();
++++  vi.clearAllMocks();
++++  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
++++  process.env.CLERK_SECRET_KEY = "sk_test_123";
++++  process.env.ADDRESS_HASH_KEY = "test_hash_key";
++++});
++++
++++describe("/api/saved-reports", () => {
++++  it("returns 401 when unauthenticated and does not touch the DB", async () => {
++++    auth.mockResolvedValue({ userId: null });
++++
++++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
++++    expect(res.status).toBe(401);
++++    expect(getDb).not.toHaveBeenCalled();
++++    expect(getUserSettings).not.toHaveBeenCalled();
++++    expect(createSavedReport).not.toHaveBeenCalled();
++++  });
++++
++++  it("returns 503 when persistence is disabled", async () => {
++++    auth.mockResolvedValue({ userId: "user_123" });
++++    getDb.mockReturnValue(null);
++++
++++    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
++++    expect(res.status).toBe(503);
++++    expect(json?.error).toBeTypeOf("string");
++++    expect(getUserSettings).not.toHaveBeenCalled();
++++    expect(createSavedReport).not.toHaveBeenCalled();
++++  });
++++
++++  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
++++    auth.mockResolvedValue({ userId: "user_123" });
++++    getDb.mockReturnValue({});
++++    getUserSettings.mockResolvedValue({ loggingEnabled: false });
++++
++++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
++++    expect(res.status).toBe(403);
++++    expect(createSavedReport).not.toHaveBeenCalled();
++++  });
++++
++++  it("validates payload and rejects mismatched report addresses", async () => {
++++    auth.mockResolvedValue({ userId: "user_123" });
++++    getDb.mockReturnValue({});
++++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
++++
++++    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
++++    const { res } = await callPost({ address: VALID_ADDRESS, report });
++++    expect(res.status).toBe(400);
++++    expect(createSavedReport).not.toHaveBeenCalled();
++++  });
++++
++++  it("creates a SavedReport and returns its id", async () => {
++++    auth.mockResolvedValue({ userId: "user_123" });
++++    getDb.mockReturnValue({});
++++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
++++    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
++++
++++    const report = {
++++      address: VALID_ADDRESS,
++++      risk: { score: 55.2, tier: "high", confidence: 91.7 },
++++      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
++++    };
++++
++++    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
++++    expect(res.status).toBe(200);
++++    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
++++    expect(createSavedReport).toHaveBeenCalledWith(
++++      {},
++++      "user_123",
++++      expect.objectContaining({
++++        address: VALID_ADDRESS,
++++        riskScore: 55,
++++        riskTier: "high",
++++        confidence: 92,
++++        window: { lookbackDays: 90 },
++++      }),
++++    );
++++  });
++++});
+++diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
+++new file mode 100644
+++index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
+++--- /dev/null
++++++ b/src/app/api/saved-reports/route.ts
+++@@ -0,0 +1,130 @@
++++import { NextResponse } from "next/server";
++++import { auth } from "@clerk/nextjs/server";
++++import { z } from "zod";
++++
++++import { getDb } from "@/lib/db";
++++import { createSavedReport } from "@/lib/db/saved-reports";
++++import { getUserSettings } from "@/lib/db/user-settings";
++++import { TronAddressSchema } from "@/lib/validators";
++++
++++export const runtime = "nodejs";
++++
++++const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
++++
++++const SaveReportBodySchema = z.object({
++++  address: TronAddressSchema,
++++  report: z.unknown(),
++++});
++++
++++const AnalyzeReportSchema = z
++++  .object({
++++    address: TronAddressSchema,
++++    risk: z.object({
++++      score: z.number(),
++++      tier: RiskTierSchema,
++++      confidence: z.number(),
++++    }),
++++    checks: z
++++      .object({
++++        exposure1hop: z.unknown().optional(),
++++        tracing2hop: z.unknown().optional(),
++++      })
++++      .passthrough()
++++      .optional(),
++++  })
++++  .passthrough();
++++
++++function clampInt(n: number, min: number, max: number) {
++++  return Math.max(min, Math.min(max, Math.round(n)));
++++}
++++
++++function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
++++  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
++++  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
++++    return exposure.window;
++++  }
++++
++++  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
++++  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
++++    return tracing.window;
++++  }
++++
++++  return { lookbackDays: 90 };
++++}
++++
++++async function getAuthenticatedUserId(): Promise<string | null> {
++++  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
++++  try {
++++    const { userId } = await auth();
++++    return userId ?? null;
++++  } catch {
++++    return null;
++++  }
++++}
++++
++++export async function POST(request: Request) {
++++  const userId = await getAuthenticatedUserId();
++++  if (!userId) {
++++    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
++++  }
++++
++++  if (!process.env.ADDRESS_HASH_KEY) {
++++    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
++++  }
++++
++++  const db = getDb();
++++  if (!db) {
++++    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
++++  }
++++
++++  const settings = await getUserSettings(db, userId);
++++  if (!settings?.loggingEnabled) {
++++    return NextResponse.json(
++++      { error: "Saving is disabled. Enable it in Settings first." },
++++      { status: 403, headers: { "Cache-Control": "no-store" } },
++++    );
++++  }
++++
++++  let json: unknown;
++++  try {
++++    json = await request.json();
++++  } catch {
++++    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
++++  }
++++
++++  const parsed = SaveReportBodySchema.safeParse(json);
++++  if (!parsed.success) {
++++    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
++++  }
++++
++++  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
++++  if (!reportParsed.success) {
++++    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
++++  }
++++
++++  if (reportParsed.data.address !== parsed.data.address) {
++++    return NextResponse.json(
++++      { error: "Report address mismatch." },
++++      { status: 400, headers: { "Cache-Control": "no-store" } },
++++    );
++++  }
++++
++++  const report = reportParsed.data;
++++  const created = await createSavedReport(db, userId, {
++++    address: parsed.data.address,
++++    riskScore: clampInt(report.risk.score, 0, 100),
++++    riskTier: report.risk.tier,
++++    confidence: clampInt(report.risk.confidence, 0, 100),
++++    window: deriveWindow(report),
++++    reportJson: parsed.data.report,
++++  });
++++
++++  if (!created) {
++++    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
++++  }
++++
++++  return NextResponse.json(
++++    { id: created.id, createdAt: created.createdAt },
++++    { status: 200, headers: { "Cache-Control": "no-store" } },
++++  );
++++}
+++diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
+++index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
+++--- a/src/components/blacklist-checker.tsx
++++++ b/src/components/blacklist-checker.tsx
+++@@ -506,6 +506,108 @@
+++   );
+++ }
+++ 
++++function SaveReportControl({ report }: { report: ApiResponse }) {
++++  const { isLoaded, isSignedIn } = useAuth();
++++  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
++++  const [saveState, setSaveState] = React.useState<
++++    | { state: "idle" }
++++    | { state: "saving" }
++++    | { state: "saved"; id?: string }
++++  >({ state: "idle" });
++++
++++  React.useEffect(() => {
++++    setSaveState({ state: "idle" });
++++  }, [report.address, report.timestamps.checkedAtIso]);
++++
++++  React.useEffect(() => {
++++    if (!isLoaded || !isSignedIn) return;
++++    let cancelled = false;
++++
++++    async function loadSettings() {
++++      try {
++++        const res = await fetch("/api/user-settings", { credentials: "include" });
++++        const json = (await res.json().catch(() => null)) as unknown;
++++        if (!res.ok || !json || typeof json !== "object") return;
++++
++++        const obj = json as Record<string, unknown>;
++++        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
++++        if (cancelled) return;
++++        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
++++      } catch {
++++        // ignore
++++      }
++++    }
++++
++++    loadSettings();
++++    return () => {
++++      cancelled = true;
++++    };
++++  }, [isLoaded, isSignedIn]);
++++
++++  if (!report.access?.authenticated) return null;
++++  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
++++
++++  async function saveReport() {
++++    if (saveState.state === "saving" || saveState.state === "saved") return;
++++
++++    setSaveState({ state: "saving" });
++++    try {
++++      const res = await fetch("/api/saved-reports", {
++++        method: "POST",
++++        headers: { "content-type": "application/json" },
++++        credentials: "include",
++++        body: JSON.stringify({ address: report.address, report }),
++++      });
++++
++++      const json = (await res.json().catch(() => null)) as unknown;
++++      if (!res.ok) {
++++        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
++++        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
++++        setSaveState({ state: "idle" });
++++        return;
++++      }
++++
++++      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
++++      toast.success("Report saved.");
++++      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
++++    } catch {
++++      toast.error("Network error.");
++++      setSaveState({ state: "idle" });
++++    }
++++  }
++++
++++  const saving = saveState.state === "saving";
++++  const saved = saveState.state === "saved";
++++
++++  return (
++++    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
++++      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
++++        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
++++          <div className="min-w-0">
++++            <div className="text-sm font-medium text-foreground">Save this report</div>
++++            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
++++          </div>
++++          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
++++            {saving ? (
++++              <>
++++                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
++++                Saving…
++++              </>
++++            ) : saved ? (
++++              <>
++++                <Check className="mr-2 h-4 w-4" />
++++                Saved
++++              </>
++++            ) : (
++++              "Save"
++++            )}
++++          </Button>
++++        </CardContent>
++++      </Card>
++++    </motion.div>
++++  );
++++}
++++
+++ /* ────────────────────────────────────────────────────────────────────────────
+++  * Main Component
+++  * ──────────────────────────────────────────────────────────────────────────── */
+++@@ -963,6 +1065,12 @@
+++                 {/* Status Banner */}
+++                 <StatusBanner data={load.data} />
+++ 
++++                {clerkEnabled && (
++++                  <SignedIn>
++++                    <SaveReportControl report={load.data} />
++++                  </SignedIn>
++++                )}
++++
+++                 {/* Summary Card */}
+++                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+++                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+++diff --git a/middleware.ts b/src/middleware.ts
+++index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..078996501b70d8cda7ce43e7ec365481c2b6d808
+++--- a/middleware.ts
++++++ b/src/middleware.ts
+++@@ -1,23 +1,24 @@
+++ import { NextResponse } from "next/server";
+++ import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
+++ 
+++-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
++++// Note: when using `src/app`, Next expects middleware under `src/` as well.
++++const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
+++ 
+++ const isPublicRoute = createRouteMatcher([
+++   "/",
+++   "/api/check",
+++   "/api/analyze",
+++   "/api/user-settings",
++++  "/api/saved-reports",
+++   "/sign-in(.*)",
+++   "/sign-up(.*)",
+++ ]);
+++ 
+++-const clerk = clerkMiddleware((auth, req) => {
++++const clerk = clerkMiddleware(async (auth, req) => {
++++  const { userId, redirectToSignIn } = await auth();
+++   if (isPublicRoute(req)) return;
+++-  return auth().then(({ userId, redirectToSignIn }) => {
+++-    if (!userId) return redirectToSignIn();
+++-    return undefined;
+++-  });
++++  if (!userId) return redirectToSignIn();
++++  return undefined;
+++ });
+++ 
+++ export default clerkEnabled ? clerk : () => NextResponse.next();
+++
+++file update:
+++diff --git a/.ralph/runs/run-20260123-135210-55147-iter-1.log b/.ralph/runs/run-20260123-135210-55147-iter-1.log
+++index ad4c4c1a37085a0cbd6f501aebc6fd931f8fa83c..8ff13182c69ae44725abb1e2976f05d93f4e63a2
+++--- a/.ralph/runs/run-20260123-135210-55147-iter-1.log
++++++ b/.ralph/runs/run-20260123-135210-55147-iter-1.log
+++@@ -7796,8 +7796,8 @@
+++ NEXT_PUBLIC_SITE_URL=https://usdt.chikocorp.com
+++ 
+++ # Clerk (auth)
+++-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+++-CLERK_SECRET_KEY=<redacted>
++++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++++CLERK_SECRET_KEY=<redacted>
+++ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
+++ NEXT_PUBLIC_CLERK_SIGN_UP_URL=/sign-up
+++ NEXT_PUBLIC_CLERK_AFTER_SIGN_IN_URL=/
+++@@ -41897,3 +41897,228 @@
+++ **Avoiding sensitive information leaks**
+++ 
+++ I need to ensure we don’t commit any `.env` contents in the future. It’s already done, but I’ll note that any secrets should be redacted in the progress log. The log file will stay untracked after I edit it with `apply_patch`, but I can commit it later. I also considered checking older logs for secrets, but that may not be necessary. I’ll check the `.ralph/.tmp/prompt` file for safety, but it seems fine, so we can go ahead and patch the run log.
++++file update
++++M /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-135210-55147-iter-1.log
++++@@ -7798,4 +7798,4 @@
++++ # Clerk (auth)
++++-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++++-CLERK_SECRET_KEY=<redacted>
+++++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+++++CLERK_SECRET_KEY=<redacted>
++++ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
++++                                                                                    apply_patch(auto_approved=true) exited 0 in 72ms:
++++Success. Updated the following files:
++++M .ralph/runs/run-20260123-135210-55147-iter-1.log
++++file update:
++++diff --git a/.ralph/runs/run-20260123-135210-55147-iter-1.log b/.ralph/runs/run-20260123-135210-55147-iter-1.log
++++index ad4c4c1a37085a0cbd6f501aebc6fd931f8fa83c..fd591bb7283ace1b8f8af92e2899bbc866e576a9
++++--- a/.ralph/runs/run-20260123-135210-55147-iter-1.log
+++++++ b/.ralph/runs/run-20260123-135210-55147-iter-1.log
++++@@ -7796,8 +7796,8 @@
++++ NEXT_PUBLIC_SITE_URL=https://usdt.chikocorp.com
++++ 
++++ # Clerk (auth)
++++-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++++-CLERK_SECRET_KEY=<redacted>
+++++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+++++CLERK_SECRET_KEY=<redacted>
++++ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
++++ NEXT_PUBLIC_CLERK_SIGN_UP_URL=/sign-up
++++ NEXT_PUBLIC_CLERK_AFTER_SIGN_IN_URL=/
++++@@ -41897,3 +41897,12 @@
++++ **Avoiding sensitive information leaks**
++++ 
++++ I need to ensure we don’t commit any `.env` contents in the future. It’s already done, but I’ll note that any secrets should be redacted in the progress log. The log file will stay untracked after I edit it with `apply_patch`, but I can commit it later. I also considered checking older logs for secrets, but that may not be necessary. I’ll check the `.ralph/.tmp/prompt` file for safety, but it seems fine, so we can go ahead and patch the run log.
+++++file update
+++++M /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-135210-55147-iter-1.log
+++++@@ -7798,4 +7798,4 @@
+++++ # Clerk (auth)
+++++-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+++++-CLERK_SECRET_KEY=<redacted>
++++++NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
++++++CLERK_SECRET_KEY=<redacted>
+++++ NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
++++diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
++++new file mode 100644
++++index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
++++--- /dev/null
+++++++ b/src/__tests__/api-saved-reports.test.ts
++++@@ -0,0 +1,107 @@
+++++import { beforeEach, describe, expect, it, vi } from "vitest";
+++++
+++++const auth = vi.fn();
+++++vi.mock("@clerk/nextjs/server", () => ({ auth }));
+++++
+++++const getDb = vi.fn();
+++++vi.mock("@/lib/db", () => ({ getDb }));
+++++
+++++const getUserSettings = vi.fn();
+++++vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+++++
+++++const createSavedReport = vi.fn();
+++++vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+++++
+++++const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+++++
+++++async function callPost(body: unknown) {
+++++  const { POST } = await import("@/app/api/saved-reports/route");
+++++  const req = new Request("http://localhost/api/saved-reports", {
+++++    method: "POST",
+++++    headers: { "content-type": "application/json" },
+++++    body: JSON.stringify(body),
+++++  });
+++++  const res = await POST(req);
+++++  const json = await res.json().catch(() => null);
+++++  return { res, json };
+++++}
+++++
+++++beforeEach(() => {
+++++  vi.resetModules();
+++++  vi.clearAllMocks();
+++++  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+++++  process.env.CLERK_SECRET_KEY = "sk_test_123";
+++++  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+++++});
+++++
+++++describe("/api/saved-reports", () => {
+++++  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+++++    auth.mockResolvedValue({ userId: null });
+++++
+++++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+++++    expect(res.status).toBe(401);
+++++    expect(getDb).not.toHaveBeenCalled();
+++++    expect(getUserSettings).not.toHaveBeenCalled();
+++++    expect(createSavedReport).not.toHaveBeenCalled();
+++++  });
+++++
+++++  it("returns 503 when persistence is disabled", async () => {
+++++    auth.mockResolvedValue({ userId: "user_123" });
+++++    getDb.mockReturnValue(null);
+++++
+++++    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+++++    expect(res.status).toBe(503);
+++++    expect(json?.error).toBeTypeOf("string");
+++++    expect(getUserSettings).not.toHaveBeenCalled();
+++++    expect(createSavedReport).not.toHaveBeenCalled();
+++++  });
+++++
+++++  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+++++    auth.mockResolvedValue({ userId: "user_123" });
+++++    getDb.mockReturnValue({});
+++++    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+++++
+++++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+++++    expect(res.status).toBe(403);
+++++    expect(createSavedReport).not.toHaveBeenCalled();
+++++  });
+++++
+++++  it("validates payload and rejects mismatched report addresses", async () => {
+++++    auth.mockResolvedValue({ userId: "user_123" });
+++++    getDb.mockReturnValue({});
+++++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+++++
+++++    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+++++    const { res } = await callPost({ address: VALID_ADDRESS, report });
+++++    expect(res.status).toBe(400);
+++++    expect(createSavedReport).not.toHaveBeenCalled();
+++++  });
+++++
+++++  it("creates a SavedReport and returns its id", async () => {
+++++    auth.mockResolvedValue({ userId: "user_123" });
+++++    getDb.mockReturnValue({});
+++++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+++++    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+++++
+++++    const report = {
+++++      address: VALID_ADDRESS,
+++++      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+++++      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+++++    };
+++++
+++++    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+++++    expect(res.status).toBe(200);
+++++    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+++++    expect(createSavedReport).toHaveBeenCalledWith(
+++++      {},
+++++      "user_123",
+++++      expect.objectContaining({
+++++        address: VALID_ADDRESS,
+++++        riskScore: 55,
+++++        riskTier: "high",
+++++        confidence: 92,
+++++        window: { lookbackDays: 90 },
+++++      }),
+++++    );
+++++  });
+++++});
++++diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
++++new file mode 100644
++++index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
++++--- /dev/null
+++++++ b/src/app/api/saved-reports/route.ts
++++@@ -0,0 +1,130 @@
+++++import { NextResponse } from "next/server";
+++++import { auth } from "@clerk/nextjs/server";
+++++import { z } from "zod";
+++++
+++++import { getDb } from "@/lib/db";
+++++import { createSavedReport } from "@/lib/db/saved-reports";
+++++import { getUserSettings } from "@/lib/db/user-settings";
+++++import { TronAddressSchema } from "@/lib/validators";
+++++
+++++export const runtime = "nodejs";
+++++
+++++const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+++++
+++++const SaveReportBodySchema = z.object({
+++++  address: TronAddressSchema,
+++++  report: z.unknown(),
+++++});
+++++
+++++const AnalyzeReportSchema = z
+++++  .object({
+++++    address: TronAddressSchema,
+++++    risk: z.object({
+++++      score: z.number(),
+++++      tier: RiskTierSchema,
+++++      confidence: z.number(),
+++++    }),
+++++    checks: z
+++++      .object({
+++++        exposure1hop: z.unknown().optional(),
+++++        tracing2hop: z.unknown().optional(),
+++++      })
+++++      .passthrough()
+++++      .optional(),
+++++  })
+++++  .passthrough();
+++++
+++++function clampInt(n: number, min: number, max: number) {
+++++  return Math.max(min, Math.min(max, Math.round(n)));
+++++}
+++++
+++++function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+++++  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+++++  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+++++    return exposure.window;
+++++  }
+++++
+++++  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+++++  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+++++    return tracing.window;
+++++  }
+++++
+++++  return { lookbackDays: 90 };
+++++}
+++++
+++++async function getAuthenticatedUserId(): Promise<string | null> {
+++++  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+++++  try {
+++++    const { userId } = await auth();
+++++    return userId ?? null;
+++++  } catch {
+++++    return null;
+++++  }
+++++}
+++++
+++++export async functi
+++\ No newline at end of file
+++diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
+++new file mode 100644
+++index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
+++--- /dev/null
++++++ b/src/__tests__/api-saved-reports.test.ts
+++@@ -0,0 +1,107 @@
++++import { beforeEach, describe, expect, it, vi } from "vitest";
++++
++++const auth = vi.fn();
++++vi.mock("@clerk/nextjs/server", () => ({ auth }));
++++
++++const getDb = vi.fn();
++++vi.mock("@/lib/db", () => ({ getDb }));
++++
++++const getUserSettings = vi.fn();
++++vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
++++
++++const createSavedReport = vi.fn();
++++vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
++++
++++const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
++++
++++async function callPost(body: unknown) {
++++  const { POST } = await import("@/app/api/saved-reports/route");
++++  const req = new Request("http://localhost/api/saved-reports", {
++++    method: "POST",
++++    headers: { "content-type": "application/json" },
++++    body: JSON.stringify(body),
++++  });
++++  const res = await POST(req);
++++  const json = await res.json().catch(() => null);
++++  return { res, json };
++++}
++++
++++beforeEach(() => {
++++  vi.resetModules();
++++  vi.clearAllMocks();
++++  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
++++  process.env.CLERK_SECRET_KEY = "sk_test_123";
++++  process.env.ADDRESS_HASH_KEY = "test_hash_key";
++++});
++++
++++describe("/api/saved-reports", () => {
++++  it("returns 401 when unauthenticated and does not touch the DB", async () => {
++++    auth.mockResolvedValue({ userId: null });
++++
++++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
++++    expect(res.status).toBe(401);
++++    expect(getDb).not.toHaveBeenCalled();
++++    expect(getUserSettings).not.toHaveBeenCalled();
++++    expect(createSavedReport).not.toHaveBeenCalled();
++++  });
++++
++++  it("returns 503 when persistence is disabled", async () => {
++++    auth.mockResolvedValue({ userId: "user_123" });
++++    getDb.mockReturnValue(null);
++++
++++    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
++++    expect(res.status).toBe(503);
++++    expect(json?.error).toBeTypeOf("string");
++++    expect(getUserSettings).not.toHaveBeenCalled();
++++    expect(createSavedReport).not.toHaveBeenCalled();
++++  });
++++
++++  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
++++    auth.mockResolvedValue({ userId: "user_123" });
++++    getDb.mockReturnValue({});
++++    getUserSettings.mockResolvedValue({ loggingEnabled: false });
++++
++++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
++++    expect(res.status).toBe(403);
++++    expect(createSavedReport).not.toHaveBeenCalled();
++++  });
++++
++++  it("validates payload and rejects mismatched report addresses", async () => {
++++    auth.mockResolvedValue({ userId: "user_123" });
++++    getDb.mockReturnValue({});
++++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
++++
++++    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
++++    const { res } = await callPost({ address: VALID_ADDRESS, report });
++++    expect(res.status).toBe(400);
++++    expect(createSavedReport).not.toHaveBeenCalled();
++++  });
++++
++++  it("creates a SavedReport and returns its id", async () => {
++++    auth.mockResolvedValue({ userId: "user_123" });
++++    getDb.mockReturnValue({});
++++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
++++    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
++++
++++    const report = {
++++      address: VALID_ADDRESS,
++++      risk: { score: 55.2, tier: "high", confidence: 91.7 },
++++      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
++++    };
++++
++++    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
++++    expect(res.status).toBe(200);
++++    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
++++    expect(createSavedReport).toHaveBeenCalledWith(
++++      {},
++++      "user_123",
++++      expect.objectContaining({
++++        address: VALID_ADDRESS,
++++        riskScore: 55,
++++        riskTier: "high",
++++        confidence: 92,
++++        window: { lookbackDays: 90 },
++++      }),
++++    );
++++  });
++++});
+++diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
+++new file mode 100644
+++index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
+++--- /dev/null
++++++ b/src/app/api/saved-reports/route.ts
+++@@ -0,0 +1,130 @@
++++import { NextResponse } from "next/server";
++++import { auth } from "@clerk/nextjs/server";
++++import { z } from "zod";
++++
++++import { getDb } from "@/lib/db";
++++import { createSavedReport } from "@/lib/db/saved-reports";
++++import { getUserSettings } from "@/lib/db/user-settings";
++++import { TronAddressSchema } from "@/lib/validators";
++++
++++export const runtime = "nodejs";
++++
++++const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
++++
++++const SaveReportBodySchema = z.object({
++++  address: TronAddressSchema,
++++  report: z.unknown(),
++++});
++++
++++const AnalyzeReportSchema = z
++++  .object({
++++    address: TronAddressSchema,
++++    risk: z.object({
++++      score: z.number(),
++++      tier: RiskTierSchema,
++++      confidence: z.number(),
++++    }),
++++    checks: z
++++      .object({
++++        exposure1hop: z.unknown().optional(),
++++        tracing2hop: z.unknown().optional(),
++++      })
++++      .passthrough()
++++      .optional(),
++++  })
++++  .passthrough();
++++
++++function clampInt(n: number, min: number, max: number) {
++++  return Math.max(min, Math.min(max, Math.round(n)));
++++}
++++
++++function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
++++  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
++++  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
++++    return exposure.window;
++++  }
++++
++++  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
++++  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
++++    return tracing.window;
++++  }
++++
++++  return { lookbackDays: 90 };
++++}
++++
++++async function getAuthenticatedUserId(): Promise<string | null> {
++++  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
++++  try {
++++    const { userId } = await auth();
++++    return userId ?? null;
++++  } catch {
++++    return null;
++++  }
++++}
++++
++++export async function POST(request: Request) {
++++  const userId = await getAuthenticatedUserId();
++++  if (!userId) {
++++    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
++++  }
++++
++++  if (!process.env.ADDRESS_HASH_KEY) {
++++    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
++++  }
++++
++++  const db = getDb();
++++  if (!db) {
++++    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
++++  }
++++
++++  const settings = await getUserSettings(db, userId);
++++  if (!settings?.loggingEnabled) {
++++    return NextResponse.json(
++++      { error: "Saving is disabled. Enable it in Settings first." },
++++      { status: 403, headers: { "Cache-Control": "no-store" } },
++++    );
++++  }
++++
++++  let json: unknown;
++++  try {
++++    json = await request.json();
++++  } catch {
++++    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
++++  }
++++
++++  const parsed = SaveReportBodySchema.safeParse(json);
++++  if (!parsed.success) {
++++    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
++++  }
++++
++++  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
++++  if (!reportParsed.success) {
++++    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
++++  }
++++
++++  if (reportParsed.data.address !== parsed.data.address) {
++++    return NextResponse.json(
++++      { error: "Report address mismatch." },
++++      { status: 400, headers: { "Cache-Control": "no-store" } },
++++    );
++++  }
++++
++++  const report = reportParsed.data;
++++  const created = await createSavedReport(db, userId, {
++++    address: parsed.data.address,
++++    riskScore: clampInt(report.risk.score, 0, 100),
++++    riskTier: report.risk.tier,
++++    confidence: clampInt(report.risk.confidence, 0, 100),
++++    window: deriveWindow(report),
++++    reportJson: parsed.data.report,
++++  });
++++
++++  if (!created) {
++++    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
++++  }
++++
++++  return NextResponse.json(
++++    { id: created.id, createdAt: created.createdAt },
++++    { status: 200, headers: { "Cache-Control": "no-store" } },
++++  );
++++}
+++diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
+++index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
+++--- a/src/components/blacklist-checker.tsx
++++++ b/src/components/blacklist-checker.tsx
+++@@ -506,6 +506,108 @@
+++   );
+++ }
+++ 
++++function SaveReportControl({ report }: { report: ApiResponse }) {
++++  const { isLoaded, isSignedIn } = useAuth();
++++  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
++++  const [saveState, setSaveState] = React.useState<
++++    | { state: "idle" }
++++    | { state: "saving" }
++++    | { state: "saved"; id?: string }
++++  >({ state: "idle" });
++++
++++  React.useEffect(() => {
++++    setSaveState({ state: "idle" });
++++  }, [report.address, report.timestamps.checkedAtIso]);
++++
++++  React.useEffect(() => {
++++    if (!isLoaded || !isSignedIn) return;
++++    let cancelled = false;
++++
++++    async function loadSettings() {
++++      try {
++++        const res = await fetch("/api/user-settings", { credentials: "include" });
++++        const json = (await res.json().catch(() => null)) as unknown;
++++        if (!res.ok || !json || typeof json !== "object") return;
++++
++++        const obj = json as Record<string, unknown>;
++++        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
++++        if (cancelled) return;
++++        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
++++      } catch {
++++        // ignore
++++      }
++++    }
++++
++++    loadSettings();
++++    return () => {
++++      cancelled = true;
++++    };
++++  }, [isLoaded, isSignedIn]);
++++
++++  if (!report.access?.authenticated) return null;
++++  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
++++
++++  async function saveReport() {
++++    if (saveState.state === "saving" || saveState.state === "saved") return;
++++
++++    setSaveState({ state: "saving" });
++++    try {
++++      const res = await fetch("/api/saved-reports", {
++++        method: "POST",
++++        headers: { "content-type": "application/json" },
++++        credentials: "include",
++++        body: JSON.stringify({ address: report.address, report }),
++++      });
++++
++++      const json = (await res.json().catch(() => null)) as unknown;
++++      if (!res.ok) {
++++        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
++++        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
++++        setSaveState({ state: "idle" });
++++        return;
++++      }
++++
++++      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
++++      toast.success("Report saved.");
++++      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
++++    } catch {
++++      toast.error("Network error.");
++++      setSaveState({ state: "idle" });
++++    }
++++  }
++++
++++  const saving = saveState.state === "saving";
++++  const saved = saveState.state === "saved";
++++
++++  return (
++++    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
++++      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
++++        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
++++          <div className="min-w-0">
++++            <div className="text-sm font-medium text-foreground">Save this report</div>
++++            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
++++          </div>
++++          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
++++            {saving ? (
++++              <>
++++                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
++++                Saving…
++++              </>
++++            ) : saved ? (
++++              <>
++++                <Check className="mr-2 h-4 w-4" />
++++                Saved
++++              </>
++++            ) : (
++++              "Save"
++++            )}
++++          </Button>
++++        </CardContent>
++++      </Card>
++++    </motion.div>
++++  );
++++}
++++
+++ /* ────────────────────────────────────────────────────────────────────────────
+++  * Main Component
+++  * ──────────────────────────────────────────────────────────────────────────── */
+++@@ -963,6 +1065,12 @@
+++                 {/* Status Banner */}
+++                 <StatusBanner data={load.data} />
+++ 
++++                {clerkEnabled && (
++++                  <SignedIn>
++++                    <SaveReportControl report={load.data} />
++++                  </SignedIn>
++++                )}
++++
+++                 {/* Summary Card */}
+++                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+++                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+++diff --git a/middleware.ts b/src/middleware.ts
+++index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..078996501b70d8cda7ce43e7ec365481c2b6d808
+++--- a/middleware.ts
++++++ b/src/middleware.ts
+++@@ -1,23 +1,24 @@
+++ import { NextResponse } from "next/server";
+++ import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
+++ 
+++-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
++++// Note: when using `src/app`, Next expects middleware under `src/` as well.
++++const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
+++ 
+++ const isPublicRoute = createRouteMatcher([
+++   "/",
+++   "/api/check",
+++   "/api/analyze",
+++   "/api/user-settings",
++++  "/api/saved-reports",
+++   "/sign-in(.*)",
+++   "/sign-up(.*)",
+++ ]);
+++ 
+++-const clerk = clerkMiddleware((auth, req) => {
++++const clerk = clerkMiddleware(async (auth, req) => {
++++  const { userId, redirectToSignIn } = await auth();
+++   if (isPublicRoute(req)) return;
+++-  return auth().then(({ userId, redirectToSignIn }) => {
+++-    if (!userId) return redirectToSignIn();
+++-    return undefined;
+++-  });
++++  if (!userId) return redirectToSignIn();
++++  return undefined;
+++ });
+++ 
+++ export default clerkEnabled ? clerk : () => NextResponse.next();
+++
+++exec
+++/bin/zsh -lc 'rg -n "sk_test_|pk_test_a25v|CLERK_SECRET_KEY=sk_test|NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=pk_test" .ralph/runs/run-20260123-135210-55147-iter-1.log || true' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 76ms:
+++3309:  process.env.CLERK_SECRET_KEY = "sk_test_123";
+++3438:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+++3824:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+++4213:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+++4608:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+++5008:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+++5405:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+++5813:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+++6221:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+++6610:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+++7005:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+++7413:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+++7860:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+++8256:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+++8669:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+++9077:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+++9478:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+++9867:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+++10213:   process.env.CLERK_SECRET_KEY = "sk_test_123";
+++10273:+  process.env.CLERK_SECRET_KEY = "sk_test_123";
++diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
++new file mode 100644
++index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
++--- /dev/null
+++++ b/src/__tests__/api-saved-reports.test.ts
++@@ -0,0 +1,107 @@
+++import { beforeEach, describe, expect, it, vi } from "vitest";
+++
+++const auth = vi.fn();
+++vi.mock("@clerk/nextjs/server", () => ({ auth }));
+++
+++const getDb = vi.fn();
+++vi.mock("@/lib/db", () => ({ getDb }));
+++
+++const getUserSettings = vi.fn();
+++vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+++
+++const createSavedReport = vi.fn();
+++vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+++
+++const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+++
+++async function callPost(body: unknown) {
+++  const { POST } = await import("@/app/api/saved-reports/route");
+++  const req = new Request("http://localhost/api/saved-reports", {
+++    method: "POST",
+++    headers: { "content-type": "application/json" },
+++    body: JSON.stringify(body),
+++  });
+++  const res = await POST(req);
+++  const json = await res.json().catch(() => null);
+++  return { res, json };
+++}
+++
+++beforeEach(() => {
+++  vi.resetModules();
+++  vi.clearAllMocks();
+++  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+++  process.env.CLERK_SECRET_KEY = "sk_test_123";
+++  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+++});
+++
+++describe("/api/saved-reports", () => {
+++  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+++    auth.mockResolvedValue({ userId: null });
+++
+++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+++    expect(res.status).toBe(401);
+++    expect(getDb).not.toHaveBeenCalled();
+++    expect(getUserSettings).not.toHaveBeenCalled();
+++    expect(createSavedReport).not.toHaveBeenCalled();
+++  });
+++
+++  it("returns 503 when persistence is disabled", async () => {
+++    auth.mockResolvedValue({ userId: "user_123" });
+++    getDb.mockReturnValue(null);
+++
+++    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+++    expect(res.status).toBe(503);
+++    expect(json?.error).toBeTypeOf("string");
+++    expect(getUserSettings).not.toHaveBeenCalled();
+++    expect(createSavedReport).not.toHaveBeenCalled();
+++  });
+++
+++  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+++    auth.mockResolvedValue({ userId: "user_123" });
+++    getDb.mockReturnValue({});
+++    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+++
+++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+++    expect(res.status).toBe(403);
+++    expect(createSavedReport).not.toHaveBeenCalled();
+++  });
+++
+++  it("validates payload and rejects mismatched report addresses", async () => {
+++    auth.mockResolvedValue({ userId: "user_123" });
+++    getDb.mockReturnValue({});
+++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+++
+++    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+++    const { res } = await callPost({ address: VALID_ADDRESS, report });
+++    expect(res.status).toBe(400);
+++    expect(createSavedReport).not.toHaveBeenCalled();
+++  });
+++
+++  it("creates a SavedReport and returns its id", async () => {
+++    auth.mockResolvedValue({ userId: "user_123" });
+++    getDb.mockReturnValue({});
+++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+++    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+++
+++    const report = {
+++      address: VALID_ADDRESS,
+++      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+++      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+++    };
+++
+++    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+++    expect(res.status).toBe(200);
+++    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+++    expect(createSavedReport).toHaveBeenCalledWith(
+++      {},
+++      "user_123",
+++      expect.objectContaining({
+++        address: VALID_ADDRESS,
+++        riskScore: 55,
+++        riskTier: "high",
+++        confidence: 92,
+++        window: { lookbackDays: 90 },
+++      }),
+++    );
+++  });
+++});
++diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
++new file mode 100644
++index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
++--- /dev/null
+++++ b/src/app/api/saved-reports/route.ts
++@@ -0,0 +1,130 @@
+++import { NextResponse } from "next/server";
+++import { auth } from "@clerk/nextjs/server";
+++import { z } from "zod";
+++
+++import { getDb } from "@/lib/db";
+++import { createSavedReport } from "@/lib/db/saved-reports";
+++import { getUserSettings } from "@/lib/db/user-settings";
+++import { TronAddressSchema } from "@/lib/validators";
+++
+++export const runtime = "nodejs";
+++
+++const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+++
+++const SaveReportBodySchema = z.object({
+++  address: TronAddressSchema,
+++  report: z.unknown(),
+++});
+++
+++const AnalyzeReportSchema = z
+++  .object({
+++    address: TronAddressSchema,
+++    risk: z.object({
+++      score: z.number(),
+++      tier: RiskTierSchema,
+++      confidence: z.number(),
+++    }),
+++    checks: z
+++      .object({
+++        exposure1hop: z.unknown().optional(),
+++        tracing2hop: z.unknown().optional(),
+++      })
+++      .passthrough()
+++      .optional(),
+++  })
+++  .passthrough();
+++
+++function clampInt(n: number, min: number, max: number) {
+++  return Math.max(min, Math.min(max, Math.round(n)));
+++}
+++
+++function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+++  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+++  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+++    return exposure.window;
+++  }
+++
+++  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+++  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+++    return tracing.window;
+++  }
+++
+++  return { lookbackDays: 90 };
+++}
+++
+++async function getAuthenticatedUserId(): Promise<string | null> {
+++  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+++  try {
+++    const { userId } = await auth();
+++    return userId ?? null;
+++  } catch {
+++    return null;
+++  }
+++}
+++
+++export async function POST(request: Request) {
+++  const userId = await getAuthenticatedUserId();
+++  if (!userId) {
+++    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+++  }
+++
+++  if (!process.env.ADDRESS_HASH_KEY) {
+++    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+++  }
+++
+++  const db = getDb();
+++  if (!db) {
+++    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+++  }
+++
+++  const settings = await getUserSettings(db, userId);
+++  if (!settings?.loggingEnabled) {
+++    return NextResponse.json(
+++      { error: "Saving is disabled. Enable it in Settings first." },
+++      { status: 403, headers: { "Cache-Control": "no-store" } },
+++    );
+++  }
+++
+++  let json: unknown;
+++  try {
+++    json = await request.json();
+++  } catch {
+++    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+++  }
+++
+++  const parsed = SaveReportBodySchema.safeParse(json);
+++  if (!parsed.success) {
+++    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+++  }
+++
+++  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+++  if (!reportParsed.success) {
+++    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+++  }
+++
+++  if (reportParsed.data.address !== parsed.data.address) {
+++    return NextResponse.json(
+++      { error: "Report address mismatch." },
+++      { status: 400, headers: { "Cache-Control": "no-store" } },
+++    );
+++  }
+++
+++  const report = reportParsed.data;
+++  const created = await createSavedReport(db, userId, {
+++    address: parsed.data.address,
+++    riskScore: clampInt(report.risk.score, 0, 100),
+++    riskTier: report.risk.tier,
+++    confidence: clampInt(report.risk.confidence, 0, 100),
+++    window: deriveWindow(report),
+++    reportJson: parsed.data.report,
+++  });
+++
+++  if (!created) {
+++    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+++  }
+++
+++  return NextResponse.json(
+++    { id: created.id, createdAt: created.createdAt },
+++    { status: 200, headers: { "Cache-Control": "no-store" } },
+++  );
+++}
++diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
++index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
++--- a/src/components/blacklist-checker.tsx
+++++ b/src/components/blacklist-checker.tsx
++@@ -506,6 +506,108 @@
++   );
++ }
++ 
+++function SaveReportControl({ report }: { report: ApiResponse }) {
+++  const { isLoaded, isSignedIn } = useAuth();
+++  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+++  const [saveState, setSaveState] = React.useState<
+++    | { state: "idle" }
+++    | { state: "saving" }
+++    | { state: "saved"; id?: string }
+++  >({ state: "idle" });
+++
+++  React.useEffect(() => {
+++    setSaveState({ state: "idle" });
+++  }, [report.address, report.timestamps.checkedAtIso]);
+++
+++  React.useEffect(() => {
+++    if (!isLoaded || !isSignedIn) return;
+++    let cancelled = false;
+++
+++    async function loadSettings() {
+++      try {
+++        const res = await fetch("/api/user-settings", { credentials: "include" });
+++        const json = (await res.json().catch(() => null)) as unknown;
+++        if (!res.ok || !json || typeof json !== "object") return;
+++
+++        const obj = json as Record<string, unknown>;
+++        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+++        if (cancelled) return;
+++        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+++      } catch {
+++        // ignore
+++      }
+++    }
+++
+++    loadSettings();
+++    return () => {
+++      cancelled = true;
+++    };
+++  }, [isLoaded, isSignedIn]);
+++
+++  if (!report.access?.authenticated) return null;
+++  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+++
+++  async function saveReport() {
+++    if (saveState.state === "saving" || saveState.state === "saved") return;
+++
+++    setSaveState({ state: "saving" });
+++    try {
+++      const res = await fetch("/api/saved-reports", {
+++        method: "POST",
+++        headers: { "content-type": "application/json" },
+++        credentials: "include",
+++        body: JSON.stringify({ address: report.address, report }),
+++      });
+++
+++      const json = (await res.json().catch(() => null)) as unknown;
+++      if (!res.ok) {
+++        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+++        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+++        setSaveState({ state: "idle" });
+++        return;
+++      }
+++
+++      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+++      toast.success("Report saved.");
+++      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+++    } catch {
+++      toast.error("Network error.");
+++      setSaveState({ state: "idle" });
+++    }
+++  }
+++
+++  const saving = saveState.state === "saving";
+++  const saved = saveState.state === "saved";
+++
+++  return (
+++    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+++      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+++        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+++          <div className="min-w-0">
+++            <div className="text-sm font-medium text-foreground">Save this report</div>
+++            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+++          </div>
+++          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+++            {saving ? (
+++              <>
+++                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+++                Saving…
+++              </>
+++            ) : saved ? (
+++              <>
+++                <Check className="mr-2 h-4 w-4" />
+++                Saved
+++              </>
+++            ) : (
+++              "Save"
+++            )}
+++          </Button>
+++        </CardContent>
+++      </Card>
+++    </motion.div>
+++  );
+++}
+++
++ /* ────────────────────────────────────────────────────────────────────────────
++  * Main Component
++  * ──────────────────────────────────────────────────────────────────────────── */
++@@ -963,6 +1065,12 @@
++                 {/* Status Banner */}
++                 <StatusBanner data={load.data} />
++ 
+++                {clerkEnabled && (
+++                  <SignedIn>
+++                    <SaveReportControl report={load.data} />
+++                  </SignedIn>
+++                )}
+++
++                 {/* Summary Card */}
++                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
++                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
++diff --git a/middleware.ts b/src/middleware.ts
++index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..078996501b70d8cda7ce43e7ec365481c2b6d808
++--- a/middleware.ts
+++++ b/src/middleware.ts
++@@ -1,23 +1,24 @@
++ import { NextResponse } from "next/server";
++ import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
++ 
++-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
+++// Note: when using `src/app`, Next expects middleware under `src/` as well.
+++const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
++ 
++ const isPublicRoute = createRouteMatcher([
++   "/",
++   "/api/check",
++   "/api/analyze",
++   "/api/user-settings",
+++  "/api/saved-reports",
++   "/sign-in(.*)",
++   "/sign-up(.*)",
++ ]);
++ 
++-const clerk = clerkMiddleware((auth, req) => {
+++const clerk = clerkMiddleware(async (auth, req) => {
+++  const { userId, redirectToSignIn } = await auth();
++   if (isPublicRoute(req)) return;
++-  return auth().then(({ userId, redirectToSignIn }) => {
++-    if (!userId) return redirectToSignIn();
++-    return undefined;
++-  });
+++  if (!userId) return redirectToSignIn();
+++  return undefined;
++ });
++ 
++ export default clerkEnabled ? clerk : () => NextResponse.next();
++
++exec
++/bin/zsh -lc 'rg -n "<redacted>|<redacted>" .ralph/runs/run-20260123-135210-55147-iter-1.log || true' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 75ms:
++binary file matches (found "\0" byte around offset 1724417)
+diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
+new file mode 100644
+index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
+--- /dev/null
++++ b/src/__tests__/api-saved-reports.test.ts
+@@ -0,0 +1,107 @@
++import { beforeEach, describe, expect, it, vi } from "vitest";
++
++const auth = vi.fn();
++vi.mock("@clerk/nextjs/server", () => ({ auth }));
++
++const getDb = vi.fn();
++vi.mock("@/lib/db", () => ({ getDb }));
++
++const getUserSettings = vi.fn();
++vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
++
++const createSavedReport = vi.fn();
++vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
++
++const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
++
++async function callPost(body: unknown) {
++  const { POST } = await import("@/app/api/saved-reports/route");
++  const req = new Request("http://localhost/api/saved-reports", {
++    method: "POST",
++    headers: { "content-type": "application/json" },
++    body: JSON.stringify(body),
++  });
++  const res = await POST(req);
++  const json = await res.json().catch(() => null);
++  return { res, json };
++}
++
++beforeEach(() => {
++  vi.resetModules();
++  vi.clearAllMocks();
++  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
++  process.env.CLERK_SECRET_KEY = "sk_test_123";
++  process.env.ADDRESS_HASH_KEY = "test_hash_key";
++});
++
++describe("/api/saved-reports", () => {
++  it("returns 401 when unauthenticated and does not touch the DB", async () => {
++    auth.mockResolvedValue({ userId: null });
++
++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
++    expect(res.status).toBe(401);
++    expect(getDb).not.toHaveBeenCalled();
++    expect(getUserSettings).not.toHaveBeenCalled();
++    expect(createSavedReport).not.toHaveBeenCalled();
++  });
++
++  it("returns 503 when persistence is disabled", async () => {
++    auth.mockResolvedValue({ userId: "user_123" });
++    getDb.mockReturnValue(null);
++
++    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
++    expect(res.status).toBe(503);
++    expect(json?.error).toBeTypeOf("string");
++    expect(getUserSettings).not.toHaveBeenCalled();
++    expect(createSavedReport).not.toHaveBeenCalled();
++  });
++
++  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
++    auth.mockResolvedValue({ userId: "user_123" });
++    getDb.mockReturnValue({});
++    getUserSettings.mockResolvedValue({ loggingEnabled: false });
++
++    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
++    expect(res.status).toBe(403);
++    expect(createSavedReport).not.toHaveBeenCalled();
++  });
++
++  it("validates payload and rejects mismatched report addresses", async () => {
++    auth.mockResolvedValue({ userId: "user_123" });
++    getDb.mockReturnValue({});
++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
++
++    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
++    const { res } = await callPost({ address: VALID_ADDRESS, report });
++    expect(res.status).toBe(400);
++    expect(createSavedReport).not.toHaveBeenCalled();
++  });
++
++  it("creates a SavedReport and returns its id", async () => {
++    auth.mockResolvedValue({ userId: "user_123" });
++    getDb.mockReturnValue({});
++    getUserSettings.mockResolvedValue({ loggingEnabled: true });
++    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
++
++    const report = {
++      address: VALID_ADDRESS,
++      risk: { score: 55.2, tier: "high", confidence: 91.7 },
++      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
++    };
++
++    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
++    expect(res.status).toBe(200);
++    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
++    expect(createSavedReport).toHaveBeenCalledWith(
++      {},
++      "user_123",
++      expect.objectContaining({
++        address: VALID_ADDRESS,
++        riskScore: 55,
++        riskTier: "high",
++        confidence: 92,
++        window: { lookbackDays: 90 },
++      }),
++    );
++  });
++});
+diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
+new file mode 100644
+index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
+--- /dev/null
++++ b/src/app/api/saved-reports/route.ts
+@@ -0,0 +1,130 @@
++import { NextResponse } from "next/server";
++import { auth } from "@clerk/nextjs/server";
++import { z } from "zod";
++
++import { getDb } from "@/lib/db";
++import { createSavedReport } from "@/lib/db/saved-reports";
++import { getUserSettings } from "@/lib/db/user-settings";
++import { TronAddressSchema } from "@/lib/validators";
++
++export const runtime = "nodejs";
++
++const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
++
++const SaveReportBodySchema = z.object({
++  address: TronAddressSchema,
++  report: z.unknown(),
++});
++
++const AnalyzeReportSchema = z
++  .object({
++    address: TronAddressSchema,
++    risk: z.object({
++      score: z.number(),
++      tier: RiskTierSchema,
++      confidence: z.number(),
++    }),
++    checks: z
++      .object({
++        exposure1hop: z.unknown().optional(),
++        tracing2hop: z.unknown().optional(),
++      })
++      .passthrough()
++      .optional(),
++  })
++  .passthrough();
++
++function clampInt(n: number, min: number, max: number) {
++  return Math.max(min, Math.min(max, Math.round(n)));
++}
++
++function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
++  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
++  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
++    return exposure.window;
++  }
++
++  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
++  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
++    return tracing.window;
++  }
++
++  return { lookbackDays: 90 };
++}
++
++async function getAuthenticatedUserId(): Promise<string | null> {
++  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
++  try {
++    const { userId } = await auth();
++    return userId ?? null;
++  } catch {
++    return null;
++  }
++}
++
++export async function POST(request: Request) {
++  const userId = await getAuthenticatedUserId();
++  if (!userId) {
++    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
++  }
++
++  if (!process.env.ADDRESS_HASH_KEY) {
++    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
++  }
++
++  const db = getDb();
++  if (!db) {
++    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
++  }
++
++  const settings = await getUserSettings(db, userId);
++  if (!settings?.loggingEnabled) {
++    return NextResponse.json(
++      { error: "Saving is disabled. Enable it in Settings first." },
++      { status: 403, headers: { "Cache-Control": "no-store" } },
++    );
++  }
++
++  let json: unknown;
++  try {
++    json = await request.json();
++  } catch {
++    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
++  }
++
++  const parsed = SaveReportBodySchema.safeParse(json);
++  if (!parsed.success) {
++    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
++  }
++
++  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
++  if (!reportParsed.success) {
++    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
++  }
++
++  if (reportParsed.data.address !== parsed.data.address) {
++    return NextResponse.json(
++      { error: "Report address mismatch." },
++      { status: 400, headers: { "Cache-Control": "no-store" } },
++    );
++  }
++
++  const report = reportParsed.data;
++  const created = await createSavedReport(db, userId, {
++    address: parsed.data.address,
++    riskScore: clampInt(report.risk.score, 0, 100),
++    riskTier: report.risk.tier,
++    confidence: clampInt(report.risk.confidence, 0, 100),
++    window: deriveWindow(report),
++    reportJson: parsed.data.report,
++  });
++
++  if (!created) {
++    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
++  }
++
++  return NextResponse.json(
++    { id: created.id, createdAt: created.createdAt },
++    { status: 200, headers: { "Cache-Control": "no-store" } },
++  );
++}
+diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
+index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
+--- a/src/components/blacklist-checker.tsx
++++ b/src/components/blacklist-checker.tsx
+@@ -506,6 +506,108 @@
+   );
+ }
+ 
++function SaveReportControl({ report }: { report: ApiResponse }) {
++  const { isLoaded, isSignedIn } = useAuth();
++  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
++  const [saveState, setSaveState] = React.useState<
++    | { state: "idle" }
++    | { state: "saving" }
++    | { state: "saved"; id?: string }
++  >({ state: "idle" });
++
++  React.useEffect(() => {
++    setSaveState({ state: "idle" });
++  }, [report.address, report.timestamps.checkedAtIso]);
++
++  React.useEffect(() => {
++    if (!isLoaded || !isSignedIn) return;
++    let cancelled = false;
++
++    async function loadSettings() {
++      try {
++        const res = await fetch("/api/user-settings", { credentials: "include" });
++        const json = (await res.json().catch(() => null)) as unknown;
++        if (!res.ok || !json || typeof json !== "object") return;
++
++        const obj = json as Record<string, unknown>;
++        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
++        if (cancelled) return;
++        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
++      } catch {
++        // ignore
++      }
++    }
++
++    loadSettings();
++    return () => {
++      cancelled = true;
++    };
++  }, [isLoaded, isSignedIn]);
++
++  if (!report.access?.authenticated) return null;
++  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
++
++  async function saveReport() {
++    if (saveState.state === "saving" || saveState.state === "saved") return;
++
++    setSaveState({ state: "saving" });
++    try {
++      const res = await fetch("/api/saved-reports", {
++        method: "POST",
++        headers: { "content-type": "application/json" },
++        credentials: "include",
++        body: JSON.stringify({ address: report.address, report }),
++      });
++
++      const json = (await res.json().catch(() => null)) as unknown;
++      if (!res.ok) {
++        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
++        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
++        setSaveState({ state: "idle" });
++        return;
++      }
++
++      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
++      toast.success("Report saved.");
++      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
++    } catch {
++      toast.error("Network error.");
++      setSaveState({ state: "idle" });
++    }
++  }
++
++  const saving = saveState.state === "saving";
++  const saved = saveState.state === "saved";
++
++  return (
++    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
++      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
++        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
++          <div className="min-w-0">
++            <div className="text-sm font-medium text-foreground">Save this report</div>
++            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
++          </div>
++          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
++            {saving ? (
++              <>
++                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
++                Saving…
++              </>
++            ) : saved ? (
++              <>
++                <Check className="mr-2 h-4 w-4" />
++                Saved
++              </>
++            ) : (
++              "Save"
++            )}
++          </Button>
++        </CardContent>
++      </Card>
++    </motion.div>
++  );
++}
++
+ /* ────────────────────────────────────────────────────────────────────────────
+  * Main Component
+  * ──────────────────────────────────────────────────────────────────────────── */
+@@ -963,6 +1065,12 @@
+                 {/* Status Banner */}
+                 <StatusBanner data={load.data} />
+ 
++                {clerkEnabled && (
++                  <SignedIn>
++                    <SaveReportControl report={load.data} />
++                  </SignedIn>
++                )}
++
+                 {/* Summary Card */}
+                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+diff --git a/middleware.ts b/src/middleware.ts
+index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..078996501b70d8cda7ce43e7ec365481c2b6d808
+--- a/middleware.ts
++++ b/src/middleware.ts
+@@ -1,23 +1,24 @@
+ import { NextResponse } from "next/server";
+ import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
+ 
+-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
++// Note: when using `src/app`, Next expects middleware under `src/` as well.
++const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
+ 
+ const isPublicRoute = createRouteMatcher([
+   "/",
+   "/api/check",
+   "/api/analyze",
+   "/api/user-settings",
++  "/api/saved-reports",
+   "/sign-in(.*)",
+   "/sign-up(.*)",
+ ]);
+ 
+-const clerk = clerkMiddleware((auth, req) => {
++const clerk = clerkMiddleware(async (auth, req) => {
++  const { userId, redirectToSignIn } = await auth();
+   if (isPublicRoute(req)) return;
+-  return auth().then(({ userId, redirectToSignIn }) => {
+-    if (!userId) return redirectToSignIn();
+-    return undefined;
+-  });
++  if (!userId) return redirectToSignIn();
++  return undefined;
+ });
+ 
+ export default clerkEnabled ? clerk : () => NextResponse.next();
+
+
+thinking
+**Adjusting file matches**
+
+I noticed that `rg` is reporting binary file matches because of a null byte, which throws things off. To get around this, I can use the command `rg -a` to treat the files as text. That should help solve the issue! I'll go ahead and try it out to see if it works as I expect. Hopefully, this will clean up the results and make it easier to work with. Let's give it a shot!
+exec
+/bin/zsh -lc 'rg -a -n "<redacted>|<redacted>" .ralph/runs/run-20260123-135210-55147-iter-1.log || true' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 64ms:
+41469:NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+41470:CLERK_SECRET_KEY=<redacted>
+41904:-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+41905:-CLERK_SECRET_KEY=<redacted>
+41921:-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+41922:-CLERK_SECRET_KEY=<redacted>
+41936:+-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+41937:+-CLERK_SECRET_KEY=<redacted>
+42361:-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+42362:-CLERK_SECRET_KEY=<redacted>
+42376:+-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+42377:+-CLERK_SECRET_KEY=<redacted>
+42393:+-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+42394:+-CLERK_SECRET_KEY=<redacted>
+42408:++-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+42409:++-CLERK_SECRET_KEY=<redacted>
+43040:-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+43041:-CLERK_SECRET_KEY=<redacted>
+43055:+-NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=<redacted>
+43056:+-CLERK_SECRET_KEY=<redacted>
diff --git a/src/__tests__/api-saved-reports.test.ts b/src/__tests__/api-saved-reports.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cae57866412d6cd8c036bf563f7460974866341b
--- /dev/null
+++ b/src/__tests__/api-saved-reports.test.ts
@@ -0,0 +1,107 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings }));
+
+const createSavedReport = vi.fn();
+vi.mock("@/lib/db/saved-reports", () => ({ createSavedReport }));
+
+const VALID_ADDRESS = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";
+
+async function callPost(body: unknown) {
+  const { POST } = await import("@/app/api/saved-reports/route");
+  const req = new Request("http://localhost/api/saved-reports", {
+    method: "POST",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await POST(req);
+  const json = await res.json().catch(() => null);
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+  process.env.ADDRESS_HASH_KEY = "test_hash_key";
+});
+
+describe("/api/saved-reports", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 503 when persistence is disabled", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue(null);
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(503);
+    expect(json?.error).toBeTypeOf("string");
+    expect(getUserSettings).not.toHaveBeenCalled();
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("returns 403 when loggingEnabled is false and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: false });
+
+    const { res } = await callPost({ address: VALID_ADDRESS, report: {} });
+    expect(res.status).toBe(403);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("validates payload and rejects mismatched report addresses", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const report = { address: "TA3941uFAvmVibSkQ6fMJXxmaSNovX86mz", risk: { score: 10, tier: "low", confidence: 80 } };
+    const { res } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(400);
+    expect(createSavedReport).not.toHaveBeenCalled();
+  });
+
+  it("creates a SavedReport and returns its id", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue({ loggingEnabled: true });
+    createSavedReport.mockResolvedValue({ id: "00000000-0000-0000-0000-000000000000", createdAt: new Date("2026-01-23T00:00:00.000Z") });
+
+    const report = {
+      address: VALID_ADDRESS,
+      risk: { score: 55.2, tier: "high", confidence: 91.7 },
+      checks: { exposure1hop: { ok: true, window: { lookbackDays: 90 } } },
+    };
+
+    const { res, json } = await callPost({ address: VALID_ADDRESS, report });
+    expect(res.status).toBe(200);
+    expect(json?.id).toBe("00000000-0000-0000-0000-000000000000");
+    expect(createSavedReport).toHaveBeenCalledWith(
+      {},
+      "user_123",
+      expect.objectContaining({
+        address: VALID_ADDRESS,
+        riskScore: 55,
+        riskTier: "high",
+        confidence: 92,
+        window: { lookbackDays: 90 },
+      }),
+    );
+  });
+});
diff --git a/src/app/api/saved-reports/route.ts b/src/app/api/saved-reports/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a8aa6b2ae7f656d8fe0dda549468c2e2b55458e0
--- /dev/null
+++ b/src/app/api/saved-reports/route.ts
@@ -0,0 +1,130 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { createSavedReport } from "@/lib/db/saved-reports";
+import { getUserSettings } from "@/lib/db/user-settings";
+import { TronAddressSchema } from "@/lib/validators";
+
+export const runtime = "nodejs";
+
+const RiskTierSchema = z.enum(["low", "guarded", "elevated", "high", "severe"]);
+
+const SaveReportBodySchema = z.object({
+  address: TronAddressSchema,
+  report: z.unknown(),
+});
+
+const AnalyzeReportSchema = z
+  .object({
+    address: TronAddressSchema,
+    risk: z.object({
+      score: z.number(),
+      tier: RiskTierSchema,
+      confidence: z.number(),
+    }),
+    checks: z
+      .object({
+        exposure1hop: z.unknown().optional(),
+        tracing2hop: z.unknown().optional(),
+      })
+      .passthrough()
+      .optional(),
+  })
+  .passthrough();
+
+function clampInt(n: number, min: number, max: number) {
+  return Math.max(min, Math.min(max, Math.round(n)));
+}
+
+function deriveWindow(report: z.infer<typeof AnalyzeReportSchema>): unknown {
+  const exposure = report.checks?.exposure1hop as Record<string, unknown> | undefined;
+  if (exposure && exposure.ok === true && exposure.window && typeof exposure.window === "object") {
+    return exposure.window;
+  }
+
+  const tracing = report.checks?.tracing2hop as Record<string, unknown> | undefined;
+  if (tracing && tracing.ok === true && tracing.window && typeof tracing.window === "object") {
+    return tracing.window;
+  }
+
+  return { lookbackDays: 90 };
+}
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function POST(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (!process.env.ADDRESS_HASH_KEY) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json({ error: "Persistence is disabled." }, { status: 503, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const settings = await getUserSettings(db, userId);
+  if (!settings?.loggingEnabled) {
+    return NextResponse.json(
+      { error: "Saving is disabled. Enable it in Settings first." },
+      { status: 403, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = SaveReportBodySchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const reportParsed = AnalyzeReportSchema.safeParse(parsed.data.report);
+  if (!reportParsed.success) {
+    return NextResponse.json({ error: "Invalid report payload." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  if (reportParsed.data.address !== parsed.data.address) {
+    return NextResponse.json(
+      { error: "Report address mismatch." },
+      { status: 400, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const report = reportParsed.data;
+  const created = await createSavedReport(db, userId, {
+    address: parsed.data.address,
+    riskScore: clampInt(report.risk.score, 0, 100),
+    riskTier: report.risk.tier,
+    confidence: clampInt(report.risk.confidence, 0, 100),
+    window: deriveWindow(report),
+    reportJson: parsed.data.report,
+  });
+
+  if (!created) {
+    return NextResponse.json({ error: "Failed to save report." }, { status: 500, headers: { "Cache-Control": "no-store" } });
+  }
+
+  return NextResponse.json(
+    { id: created.id, createdAt: created.createdAt },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 1078ff62ff32d51d4799da34992e476598270f51..cc700379606402fb48f301221064b6d5bb5ee347
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -506,6 +506,108 @@
   );
 }
 
+function SaveReportControl({ report }: { report: ApiResponse }) {
+  const { isLoaded, isSignedIn } = useAuth();
+  const [settings, setSettings] = React.useState<{ loggingEnabled: boolean; persistenceAvailable: boolean } | null>(null);
+  const [saveState, setSaveState] = React.useState<
+    | { state: "idle" }
+    | { state: "saving" }
+    | { state: "saved"; id?: string }
+  >({ state: "idle" });
+
+  React.useEffect(() => {
+    setSaveState({ state: "idle" });
+  }, [report.address, report.timestamps.checkedAtIso]);
+
+  React.useEffect(() => {
+    if (!isLoaded || !isSignedIn) return;
+    let cancelled = false;
+
+    async function loadSettings() {
+      try {
+        const res = await fetch("/api/user-settings", { credentials: "include" });
+        const json = (await res.json().catch(() => null)) as unknown;
+        if (!res.ok || !json || typeof json !== "object") return;
+
+        const obj = json as Record<string, unknown>;
+        if (typeof obj.loggingEnabled !== "boolean" || typeof obj.persistenceAvailable !== "boolean") return;
+        if (cancelled) return;
+        setSettings({ loggingEnabled: obj.loggingEnabled, persistenceAvailable: obj.persistenceAvailable });
+      } catch {
+        // ignore
+      }
+    }
+
+    loadSettings();
+    return () => {
+      cancelled = true;
+    };
+  }, [isLoaded, isSignedIn]);
+
+  if (!report.access?.authenticated) return null;
+  if (!settings?.persistenceAvailable || !settings.loggingEnabled) return null;
+
+  async function saveReport() {
+    if (saveState.state === "saving" || saveState.state === "saved") return;
+
+    setSaveState({ state: "saving" });
+    try {
+      const res = await fetch("/api/saved-reports", {
+        method: "POST",
+        headers: { "content-type": "application/json" },
+        credentials: "include",
+        body: JSON.stringify({ address: report.address, report }),
+      });
+
+      const json = (await res.json().catch(() => null)) as unknown;
+      if (!res.ok) {
+        const err = json && typeof json === "object" ? (json as Record<string, unknown>).error : null;
+        toast.error(typeof err === "string" ? err : `Save failed (${res.status}).`);
+        setSaveState({ state: "idle" });
+        return;
+      }
+
+      const id = json && typeof json === "object" ? (json as Record<string, unknown>).id : null;
+      toast.success("Report saved.");
+      setSaveState({ state: "saved", id: typeof id === "string" ? id : undefined });
+    } catch {
+      toast.error("Network error.");
+      setSaveState({ state: "idle" });
+    }
+  }
+
+  const saving = saveState.state === "saving";
+  const saved = saveState.state === "saved";
+
+  return (
+    <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
+      <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+        <CardContent className="flex flex-col gap-3 p-5 sm:flex-row sm:items-center sm:justify-between">
+          <div className="min-w-0">
+            <div className="text-sm font-medium text-foreground">Save this report</div>
+            <div className="mt-1 text-sm text-muted-foreground">Stores this analysis under your account history.</div>
+          </div>
+          <Button type="button" size="sm" onClick={saveReport} disabled={saving || saved}>
+            {saving ? (
+              <>
+                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                Saving…
+              </>
+            ) : saved ? (
+              <>
+                <Check className="mr-2 h-4 w-4" />
+                Saved
+              </>
+            ) : (
+              "Save"
+            )}
+          </Button>
+        </CardContent>
+      </Card>
+    </motion.div>
+  );
+}
+
 /* ────────────────────────────────────────────────────────────────────────────
  * Main Component
  * ──────────────────────────────────────────────────────────────────────────── */
@@ -963,6 +1065,12 @@
                 {/* Status Banner */}
                 <StatusBanner data={load.data} />
 
+                {clerkEnabled && (
+                  <SignedIn>
+                    <SaveReportControl report={load.data} />
+                  </SignedIn>
+                )}
+
                 {/* Summary Card */}
                 <motion.div {...fadeInUp} transition={{ duration: 0.25 }}>
                   <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
diff --git a/middleware.ts b/src/middleware.ts
index 6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c..078996501b70d8cda7ce43e7ec365481c2b6d808
--- a/middleware.ts
+++ b/src/middleware.ts
@@ -1,23 +1,24 @@
 import { NextResponse } from "next/server";
 import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
 
-const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);
+// Note: when using `src/app`, Next expects middleware under `src/` as well.
+const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
 
 const isPublicRoute = createRouteMatcher([
   "/",
   "/api/check",
   "/api/analyze",
   "/api/user-settings",
+  "/api/saved-reports",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
 
-const clerk = clerkMiddleware((auth, req) => {
+const clerk = clerkMiddleware(async (auth, req) => {
+  const { userId, redirectToSignIn } = await auth();
   if (isPublicRoute(req)) return;
-  return auth().then(({ userId, redirectToSignIn }) => {
-    if (!userId) return redirectToSignIn();
-    return undefined;
-  });
+  if (!userId) return redirectToSignIn();
+  return undefined;
 });
 
 export default clerkEnabled ? clerk : () => NextResponse.next();

exec
/bin/zsh -lc "set -euo pipefail
FILE=.ralph/runs/run-20260123-135210-55147-iter-1.log
perl -pi -e 's/<redacted>/<redacted>/g; s/<redacted>/<redacted>/g' \""'$FILE"
rg -a -n "<redacted>|<redacted>" "$FILE" || true
' in /Users/chiko/side_projects/usdt_blacklisted_web