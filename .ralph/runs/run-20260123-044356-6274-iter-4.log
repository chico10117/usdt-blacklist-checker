OpenAI Codex v0.89.0 (research preview)
--------
workdir: /Users/chiko/side_projects/usdt_blacklisted_web
model: gpt-5.2
provider: openai
approval: never
sandbox: danger-full-access
reasoning effort: high
reasoning summaries: auto
session id: 019be955-1650-72c3-a388-47c647bcac55
--------
user
# Build

You are an autonomous coding agent. Your task is to complete the work for exactly one story and record the outcome.

## Paths
- PRD: /Users/chiko/side_projects/usdt_blacklisted_web/.agents/tasks/prd-post-mvp.json
- AGENTS (optional): /Users/chiko/side_projects/usdt_blacklisted_web/AGENTS.md
- Progress Log: /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/progress.md
- Guardrails: /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/guardrails.md
- Guardrails Reference: /Users/chiko/side_projects/usdt_blacklisted_web/.agents/ralph/references/GUARDRAILS.md
- Context Reference: /Users/chiko/side_projects/usdt_blacklisted_web/.agents/ralph/references/CONTEXT_ENGINEERING.md
- Errors Log: /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/errors.log
- Activity Log: /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/activity.log
- Activity Logger: /Users/chiko/side_projects/usdt_blacklisted_web/ralph log
- No-commit: false
- Repo Root: /Users/chiko/side_projects/usdt_blacklisted_web
- Run ID: 20260123-044356-6274
- Iteration: 4
- Run Log: /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-044356-6274-iter-4.log
- Run Summary: /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-044356-6274-iter-4.md

## Global Quality Gates (apply to every story)
- pnpm lint
- pnpm test
- pnpm build

## Selected Story (Do not change scope)
ID: US-004
Title: [P2] Add API: user settings (loggingEnabled) with safe defaults

Story details:
### US-004: [P2] Add API: user settings (loggingEnabled) with safe defaults
Status: in_progress
Depends on: US-003

Description:
As an authenticated user, I want to enable/disable report saving via Settings so that I can control whether my screening history is persisted.

Acceptance Criteria:
- [ ] Add API route(s) to read and update `loggingEnabled` for the current Clerk user (default false if no row exists).
- [ ] Ensure unauthenticated requests are rejected (401/redirect per existing patterns).
- [ ] Ensure API logs do not include raw addresses and avoid logging full request bodies.
- [ ] Example: Toggling `loggingEnabled` from false to true persists and is reflected on refresh.
- [ ] Negative case: Unauthenticated request to update settings returns 401 and does not create DB rows.


If the story details are empty or missing, STOP and report that the PRD story format could not be parsed.

## Rules (Non-Negotiable)
- Implement **only** the work required to complete the selected story.
- Complete all tasks associated with this story (and only this story).
- Do NOT ask the user questions.
- Do NOT change unrelated code.
- Do NOT assume something is unimplemented — confirm by reading code.
- Implement completely; no placeholders or stubs.
- If No-commit is true, do NOT commit or push changes.
- Do NOT edit the PRD JSON (status is handled by the loop).
- All changes made during the run must be committed (including updates to progress/logs).
 - Before committing, perform a final **security**, **performance**, and **regression** review of your changes.

## Your Task (Do this in order)
1. Read /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/guardrails.md before any code changes.
2. Read /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/errors.log for repeated failures to avoid.
3. Read /Users/chiko/side_projects/usdt_blacklisted_web/.agents/tasks/prd-post-mvp.json for global context (do not edit).
4. Fully audit and read all necessary files to understand the task end-to-end before implementing. Do not assume missing functionality.
5. If /Users/chiko/side_projects/usdt_blacklisted_web/AGENTS.md exists, follow its build/test instructions.
6. Implement only the tasks that belong to US-004.
7. Run verification commands listed in the story, the global quality gates, and in /Users/chiko/side_projects/usdt_blacklisted_web/AGENTS.md (if required).
8. If the project has a build or dev workflow, run what applies:
   - Build step (e.g., `npm run build`) if defined.
   - Dev server (e.g., `npm run dev`, `wrangler dev`) if it is the normal validation path.
   - Confirm no runtime/build errors in the console.
9. Perform a brief audit before committing:
   - **Security:** check for obvious vulnerabilities or unsafe handling introduced by your changes.
   - **Performance:** check for avoidable regressions (extra queries, heavy loops, unnecessary re-renders).
   - **Regression:** verify existing behavior that could be impacted still works.
10. If No-commit is false, commit changes using the `$commit` skill.
    - Stage everything: `git add -A`
    - Confirm a clean working tree after commit: `git status --porcelain` should be empty.
    - After committing, capture the commit hash and subject using:
      `git show -s --format="%h %s" HEAD`.
11. Append a progress entry to /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/progress.md with run/commit/test details (format below).
    If No-commit is true, skip committing and note it in the progress entry.

## Progress Entry Format (Append Only)
```
## [Date/Time] - US-004: [P2] Add API: user settings (loggingEnabled) with safe defaults
Thread: [codex exec session id if available, otherwise leave blank]
Run: 20260123-044356-6274 (iteration 4)
Run log: /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-044356-6274-iter-4.log
Run summary: /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-044356-6274-iter-4.md
- Guardrails reviewed: yes
- No-commit run: false
- Commit: <hash> <subject> (or `none` + reason)
- Post-commit status: `clean` or list remaining files
- Verification:
  - Command: <exact command> -> PASS/FAIL
  - Command: <exact command> -> PASS/FAIL
- Files changed:
  - <file path>
  - <file path>
- What was implemented
- **Learnings for future iterations:**
  - Patterns discovered
  - Gotchas encountered
  - Useful context
---
```

## Completion Signal
Only output the completion signal when the **selected story** is fully complete and verified.
When the selected story is complete, output:
<promise>COMPLETE</promise>

Otherwise, end normally without the signal.

## Additional Guardrails
- When authoring documentation, capture the why (tests + implementation intent).
- If you learn how to run/build/test the project, update /Users/chiko/side_projects/usdt_blacklisted_web/AGENTS.md briefly (operational only).
- Keep AGENTS operational only; progress notes belong in /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/progress.md.
- If you hit repeated errors, log them in /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/errors.log and add a Sign to /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/guardrails.md using /Users/chiko/side_projects/usdt_blacklisted_web/.agents/ralph/references/GUARDRAILS.md as the template.

## Activity Logging (Required)
Log major actions to /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/activity.log using the helper:
```
/Users/chiko/side_projects/usdt_blacklisted_web/ralph log "message"
```
Log at least:
- Start of work on the story
- After major code changes
- After tests/verification
- After updating progress log

## Browser Testing (Required for Frontend Stories)
If the selected story changes UI, you MUST verify it in the browser:
1. Load the `dev-browser` skill.
2. Navigate to the relevant page.
3. Verify the UI changes work as expected.
4. Take a screenshot if helpful for the progress log.

A frontend story is NOT complete until browser verification passes.

mcp startup: no servers
Plan update
  → Review guardrails and prior errors
  • Audit existing auth, DB, API patterns
  • Implement settings GET/PUT routes
  • Add unit/route tests
  • Run lint, test, build
  • Security/perf/regression review, commit, logs
exec
/bin/zsh -lc 'ls -la' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 92ms:
total 2928
drwxr-xr-x@ 37 chiko  staff     1184 Jan 23 05:13 .
drwxr-xr-x@ 11 chiko  staff      352 Jan 21 18:51 ..
drwxr-xr-x@  4 chiko  staff      128 Jan 23 04:36 .agents
drwxr-xr-x@  3 chiko  staff       96 Jan 21 23:12 .clerk
-rw-r--r--@  1 chiko  staff     8196 Jan 21 19:22 .DS_Store
-rw-r--r--@  1 chiko  staff      461 Jan 22 13:07 .env
-rw-r--r--@  1 chiko  staff      544 Jan 23 04:47 .env.example
drwxr-xr-x@ 12 chiko  staff      384 Jan 23 05:30 .git
-rw-r--r--@  1 chiko  staff      567 Jan 23 05:08 .gitignore
drwxr-xr-x@ 25 chiko  staff      800 Jan 23 05:19 .next
drwxr-xr-x@  8 chiko  staff      256 Jan 23 04:25 .ralph
-rw-r--r--@  1 chiko  staff     2483 Jan 23 04:02 AGENTS.md
-rw-r--r--@  1 chiko  staff     1453 Jan 21 18:26 check-usdt-blacklist.js
-rw-r--r--@  1 chiko  staff     3562 Jan 22 12:40 CLAUDE.md
drwxr-xr-x@ 13 chiko  staff      416 Jan 22 01:07 coverage
drwxr-xr-x@  4 chiko  staff      128 Jan 23 05:03 docs
-rw-r--r--@  1 chiko  staff      264 Jan 23 05:00 drizzle.config.ts
-rw-r--r--@  1 chiko  staff      484 Jan 22 12:25 eslint.config.mjs
-rw-r--r--@  1 chiko  staff     1394 Jan 22 12:32 GPT.md
exec
/bin/zsh -lc "sed -n '1,200p' .ralph/guardrails.md" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 52ms:
# Guardrails (Signs)

> Lessons learned from failures. Read before acting.

## Core Signs

### Sign: Read Before Writing
- **Trigger**: Before modifying any file
- **Instruction**: Read the file first
- **Added after**: Core principle

### Sign: Test Before Commit
- **Trigger**: Before committing changes
- **Instruction**: Run required tests and verify outputs
- **Added after**: Core principle

---

## Learned Signs

exec
/bin/zsh -lc "sed -n '1,200p' .ralph/errors.log" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 54ms:
# Error Log

> Failures and repeated issues. Use this to add guardrails.

[2026-01-23 04:55:57] ITERATION 1 left uncommitted changes; review run summary at /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-044356-6274-iter-1.md
[2026-01-23 05:11:56] ITERATION 2 left uncommitted changes; review run summary at /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-044356-6274-iter-2.md
[2026-01-23 05:30:23] ITERATION 3 left uncommitted changes; review run summary at /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-044356-6274-iter-3.md
exec
/bin/zsh -lc "sed -n '1,200p' .agents/tasks/prd-post-mvp.json" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 54ms:
{
  "version": 1,
  "project": "TRON USDT Screening \u2014 Complete Remaining PRD Tasks (P2\u2013P4)",
  "overview": "This PRD translates the remaining unchecked items in PRD.md (P2 opt-in report saving, P3 authenticated dashboard UX upgrades, and P4 credits/packaging) into small, implementable stories for the existing Next.js + Clerk codebase. Privacy-first defaults remain: no address logging unless an authenticated user explicitly opts in.",
  "goals": [
    "Add persistent, privacy-first opt-in report saving (history + deletion) for authenticated users.",
    "Add a post-login dashboard shell with dedicated screens (Overview, History, Watchlist, Settings).",
    "Add wallet visuals (balance/flows) and charts with evidence links and time-window controls.",
    "Document and scaffold future credits/billing/workspace/export capabilities without breaking current free flows."
  ],
  "nonGoals": [
    "Multi-chain support (TRON-only).",
    "Batch screening (single address only).",
    "Automated accept/reject recommendations (findings only).",
    "Requiring users to provide private keys/seed phrases.",
    "Logging or analytics that include raw addresses by default."
  ],
  "successMetrics": [
    "Authenticated users can enable saving, save a report, view it in History, and delete it (single and all) with default-off privacy behavior.",
    "Dashboard routes are accessible post-login and unauthenticated access is blocked/redirected.",
exec
/bin/zsh -lc "test -f AGENTS.md && sed -n '1,200p' AGENTS.md || echo 'AGENTS.md not found'" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 71ms:
# Repository Guidelines

## Project Structure & Module Organization

- `src/app/`: Next.js App Router pages and API routes (e.g. `src/app/api/check/route.ts`, `src/app/api/analyze/route.ts`).
- `src/lib/`: Core screening logic (TRON/TronScan clients, sanctions screening, AML heuristics/scoring, validators). Unit tests are co-located as `*.test.ts`.
- `src/components/`: Reusable UI components (Tailwind CSS + shadcn/ui-style components).
- `src/data/`: Cached datasets (e.g. `src/data/ofac-tron-addresses.json`).
- `scripts/`: Maintenance scripts (e.g. OFAC dataset fetcher).
- `public/`: Static assets.

## Build, Test, and Development Commands

- `pnpm dev`: Run the local dev server at `http://localhost:3000`.
- `pnpm build` / `pnpm start`: Production build and run.
- `pnpm lint`: Run ESLint (Next.js core-web-vitals + TypeScript rules).
- `pnpm test`: Run Vitest once (Node environment).
- `pnpm test:watch`: Run tests in watch mode.
- `pnpm test:coverage`: Generate coverage output in `coverage/`.
- `pnpm ofac:update`: Refresh `src/data/ofac-tron-addresses.json` (requires network access).
exec
/bin/zsh -lc '/Users/chiko/side_projects/usdt_blacklisted_web/ralph log "Start US-004: implement settings API (loggingEnabled)"' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 64ms:


thinking
**Updating acceptance criteria**

I need the rest of the US-004 story acceptance criteria, which might belong in the PRD, but I think we have it in the prompt already. Okay, I've marked step 1 as completed, and we've reviewed guardrails and errors. I need to make sure we start logging this information. Now, I can mark this step as done and move on to the next one: auditing existing patterns. Let’s get started with updating the plan!
Plan update
  ✓ Review guardrails and prior errors
  → Audit existing auth, DB, API patterns
  • Implement settings GET/PUT routes
  • Add unit/route tests
  • Run lint, test, build
  • Security/perf/regression review, commit, logs

thinking
**Auditing relevant files**

I'm diving into auditing the relevant files, like the database schema, the database client, and the existing API routes. I want to analyze the authentication patterns with Clerk too. Oh, I need to locate the user settings table from US-003. For that, I’ll use “rg” to search for user_settings and related items. This step is crucial for ensuring everything aligns properly! Let's see what I find.
exec
/bin/zsh -lc 'rg -n "user_settings|UserSettings|loggingEnabled" src drizzle || true' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 79ms:
src/lib/db/schema.ts:3:export const userSettings = pgTable("user_settings", {
src/lib/db/schema.ts:5:  loggingEnabled: boolean("logging_enabled").notNull().default(false),
src/components/blacklist-checker.tsx:202:const LOGGING_PREF_KEY = "usdt_blacklisted_web:loggingEnabled";
src/components/blacklist-checker.tsx:540:  const [loggingEnabled, setLoggingEnabled] = React.useState(false);
src/components/blacklist-checker.tsx:899:                    checked={loggingEnabled}
src/lib/db/migrations/0000_worthless_guardian.sql:16:CREATE TABLE "user_settings" (
src/lib/db/migrations/0000_worthless_guardian.sql:32:ALTER TABLE "saved_reports" ADD CONSTRAINT "saved_reports_user_id_user_settings_user_id_fk" FOREIGN KEY ("user_id") REFERENCES "public"."user_settings"("user_id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
src/lib/db/migrations/0001_overrated_plazm.sql:1:ALTER TABLE "watchlist_items" ADD CONSTRAINT "watchlist_items_user_id_user_settings_user_id_fk" FOREIGN KEY ("user_id") REFERENCES "public"."user_settings"("user_id") ON DELETE cascade ON UPDATE no action;
src/lib/db/migrations/meta/0000_snapshot.json:125:        "saved_reports_user_id_user_settings_user_id_fk": {
src/lib/db/migrations/meta/0000_snapshot.json:126:          "name": "saved_reports_user_id_user_settings_user_id_fk",
src/lib/db/migrations/meta/0000_snapshot.json:128:          "tableTo": "user_settings",
src/lib/db/migrations/meta/0000_snapshot.json:145:    "public.user_settings": {
src/lib/db/migrations/meta/0000_snapshot.json:146:      "name": "user_settings",
src/lib/db/migrations/meta/0001_snapshot.json:125:        "saved_reports_user_id_user_settings_user_id_fk": {
src/lib/db/migrations/meta/0001_snapshot.json:126:          "name": "saved_reports_user_id_user_settings_user_id_fk",
src/lib/db/migrations/meta/0001_snapshot.json:128:          "tableTo": "user_settings",
src/lib/db/migrations/meta/0001_snapshot.json:145:    "public.user_settings": {
src/lib/db/migrations/meta/0001_snapshot.json:146:      "name": "user_settings",
src/lib/db/migrations/meta/0001_snapshot.json:279:        "watchlist_items_user_id_user_settings_user_id_fk": {
src/lib/db/migrations/meta/0001_snapshot.json:280:          "name": "watchlist_items_user_id_user_settings_user_id_fk",
exec
/bin/zsh -lc "rg -n \"@clerk/nextjs|auth\\(|currentUser|clerkClient\" src/app src/lib middleware.ts" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 31ms:
middleware.ts:2:import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
middleware.ts:16:  return auth().then(({ userId, redirectToSignIn }) => {
src/app/sign-in/[[...sign-in]]/page.tsx:1:import { SignIn } from "@clerk/nextjs";
src/app/api/analyze/route.ts:2:import { auth } from "@clerk/nextjs/server";
src/app/api/analyze/route.ts:240:      const { userId } = await auth();
src/app/layout.tsx:7:import { ClerkProvider } from "@clerk/nextjs";
src/app/sign-up/[[...sign-up]]/page.tsx:1:import { SignUp } from "@clerk/nextjs";
exec
/bin/zsh -lc "ls -la src/app/api && find src/app/api -maxdepth 3 -type f -name 'route.ts' -print" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 37ms:
total 0
drwxr-xr-x@ 4 chiko  staff  128 Jan 21 23:11 .
drwxr-xr-x@ 9 chiko  staff  288 Jan 22 16:59 ..
drwxr-xr-x@ 3 chiko  staff   96 Jan 21 23:11 analyze
drwxr-xr-x@ 3 chiko  staff   96 Jan 21 18:18 check
src/app/api/analyze/route.ts
src/app/api/check/route.ts
exec
/bin/zsh -lc "rg -n \"drizzle|db\\b|DATABASE_URL\" src/lib src/app" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 55ms:
src/lib/db/address-hash.test.ts:3:import { computeAddressHash, normalizeAddress } from "@/lib/db/address-hash";
src/lib/db/index.ts:4:import { drizzle } from "drizzle-orm/postgres-js";
src/lib/db/index.ts:6:import * as schema from "@/lib/db/schema";
src/lib/db/index.ts:15:  return drizzle(sql, { schema });
src/lib/db/index.ts:23:  const databaseUrl = process.env.DATABASE_URL;
src/lib/db/index.ts:31:  const db = getDb();
src/lib/db/index.ts:32:  if (!db) throw new Error("Persistence is disabled (DATABASE_URL not set).");
src/lib/db/index.ts:33:  return db;
src/lib/db/scoped-queries.test.ts:4:import { drizzle } from "drizzle-orm/postgres-js";
src/lib/db/scoped-queries.test.ts:6:import { buildGetSavedReportByIdQuery, buildListSavedReportsForAddressQuery } from "@/lib/db/saved-reports";
src/lib/db/scoped-queries.test.ts:7:import { buildGetWatchlistItemByIdQuery, buildListWatchlistItemsForAddressQuery } from "@/lib/db/watchlist";
src/lib/db/scoped-queries.test.ts:8:import * as schema from "@/lib/db/schema";
src/lib/db/scoped-queries.test.ts:13:  const sqlClient = postgres("postgres://user:pass@127.0.0.1:5432/db", {
src/lib/db/scoped-queries.test.ts:18:  const db = drizzle(sqlClient, { schema });
src/lib/db/scoped-queries.test.ts:34:    const { sql } = buildGetSavedReportByIdQuery(db, "user_a", "00000000-0000-0000-0000-000000000000").toSQL();
src/lib/db/scoped-queries.test.ts:40:    const { sql } = buildListSavedReportsForAddressQuery(db, "user_a", "T123").toSQL();
src/lib/db/scoped-queries.test.ts:46:    const { sql } = buildGetWatchlistItemByIdQuery(db, "user_a", "00000000-0000-0000-0000-000000000000").toSQL();
src/lib/db/scoped-queries.test.ts:52:    const { sql } = buildListWatchlistItemsForAddressQuery(db, "user_a", "T123").toSQL();
src/lib/db/watchlist.ts:3:import { and, desc, eq } from "drizzle-orm";
src/lib/db/watchlist.ts:5:import type { DbClient } from "@/lib/db";
exec
/bin/zsh -lc "sed -n '1,200p' src/app/api/check/route.ts" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 52ms:
import { NextResponse } from "next/server";
import { CheckRequestSchema } from "@/lib/validators";
import { readUsdtBlacklistStatusOnChain } from "@/lib/tron";
import { checkTronScanUsdtBlacklist } from "@/lib/tronscan";

export const runtime = "nodejs";

type Evidence = {
  contractAddress: string;
  txHash?: string;
  timestampIso?: string;
  method?: string;
  raw?: string;
  fullHost?: string;
};

type CheckResult =
  | { ok: true; blacklisted: boolean; evidence?: Evidence }
  | { ok: false; blacklisted: false; error: string };

exec
/bin/zsh -lc "sed -n '1,240p' src/app/api/analyze/route.ts" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 56ms:
import { NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import { CheckRequestSchema } from "@/lib/validators";
import { readUsdtBlacklistStatusOnChain } from "@/lib/tron";
import { checkTronScanUsdtBlacklist } from "@/lib/tronscan";
import { checkOfacSanctions } from "@/lib/sanctions";
import { computeConfidencePercent, computeRiskScore, computeUsdtVolumeStats } from "@/lib/aml";
import { fetchTronScanAccountTag, fetchUsdtTrc20Transfers } from "@/lib/tronscan";
import { computeTopInboundCounterparties } from "@/lib/exposure";
import { computeFlowHeuristics } from "@/lib/heuristics";
import { getOrSetCache, sha256Key } from "@/lib/cache";
import { classifyEntityFromTagsAndTransfers } from "@/lib/entity";

export const runtime = "nodejs";

type Evidence = {
  contractAddress: string;
  txHash?: string;
  timestampIso?: string;
  method?: string;
exec
/bin/zsh -lc "sed -n '240,520p' src/app/api/analyze/route.ts" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 94ms:
      const { userId } = await auth();
      authenticated = Boolean(userId);
    } catch {
      authenticated = false;
    }
  }

  const analysisCacheKey = sha256Key(["api_analyze", address, authenticated ? "auth" : "anon"]);
  const response = await getOrSetCache<AnalyzeResponse>(analysisCacheKey, 20_000, async () => {
    const checkedAtIso = new Date().toISOString();

    const [tronscanSettled, onchainSettled] = await Promise.allSettled([
      checkTronScanUsdtBlacklist(address),
      readUsdtBlacklistStatusOnChain(address, { timeoutMs: 8_000 }),
    ]);

    const tronscan: CheckResult =
      tronscanSettled.status === "fulfilled"
        ? tronscanSettled.value
        : { ok: false, blacklisted: false, error: "TronScan check failed." };


thinking
**Reviewing API settings implementation**

I’m looking into the existing API, which currently uses authentication but only if certain environment variables are set. For the settings API, authentication should always be required, returning a 401 error if not authenticated. I think I need to implement the /api/settings endpoint. There’s a component that uses localStorage, specifically for the blacklist-checker. I need to check if the UI already utilizes localStorage for a settings toggle. The acceptance criteria mention the toggle’s state should persist after a refresh, so I might need to modify it to work through the API instead.
thinking
**Checking user settings API**

The task at hand is to add an API for user settings, but to meet the example requirements, I need a Settings UI that actually uses this API. There might already be another story focused on creating the settings page UI. The Product Requirements Document (PRD) mentions a settings page, so it’s possible it already exists. I think I’ll need to inspect the src/app/settings page to confirm its implementation and see how it works with the API.
exec
/bin/zsh -lc "find src/app -maxdepth 2 -type f -name 'page.tsx' -print" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 50ms:
src/app/page.tsx
exec
/bin/zsh -lc "test -f src/app/settings/page.tsx && sed -n '1,200p' src/app/settings/page.tsx || echo 'no settings page'" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 30ms:
no settings page
exec
/bin/zsh -lc "sed -n '160,260p' src/components/blacklist-checker.tsx" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 32ms:
 * Animation variants (respect reduced motion)
 * ──────────────────────────────────────────────────────────────────────────── */

const fadeInUp = {
  initial: { opacity: 0, y: 12 },
  animate: { opacity: 1, y: 0 },
  exit: { opacity: 0, y: -8 },
};

const staggerContainer = {
  animate: { transition: { staggerChildren: 0.08 } },
};

/* ────────────────────────────────────────────────────────────────────────────
 * Helper functions
 * ──────────────────────────────────────────────────────────────────────────── */

function tronscanTxUrl(txHash: string) {
  return `https://tronscan.org/#/transaction/${txHash}`;
}
exec
/bin/zsh -lc "sed -n '520,720p' src/components/blacklist-checker.tsx" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 45ms:
          <p className="mt-0.5 text-sm text-red-800/80 dark:text-red-200/70">
            No legitimate service can &quot;unblacklist&quot; an address for a fee. Never share your seed phrase.
          </p>
        </div>
      </div>
    </motion.div>
  );
}

/* ────────────────────────────────────────────────────────────────────────────
 * Main Component
 * ──────────────────────────────────────────────────────────────────────────── */

export function BlacklistChecker() {
  const m = getMessages("en");
  const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);

  const [address, setAddress] = React.useState("");
  const [validation, setValidation] = React.useState<ReturnType<typeof validateTronAddress> | null>(null);
  const [load, setLoad] = React.useState<LoadState>({ state: "idle" });
exec
/bin/zsh -lc 'rg -n "loggingEnabled" src/components/blacklist-checker.tsx' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 77ms:
202:const LOGGING_PREF_KEY = "usdt_blacklisted_web:loggingEnabled";
540:  const [loggingEnabled, setLoggingEnabled] = React.useState(false);
899:                    checked={loggingEnabled}
exec
/bin/zsh -lc "sed -n '840,940p' src/components/blacklist-checker.tsx" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 55ms:
                    </p>
                  )}
                </div>
              </div>

              <Separator className="bg-border/60" />

              {/* Contract Reference */}
              <div className="flex flex-col gap-2 text-sm sm:flex-row sm:items-center sm:justify-between">
                <div className="flex items-center gap-2">
                  <span className="font-medium text-foreground">USDT Contract:</span>
                  <a
                    href={tronscanContractUrl(USDT_TRC20_CONTRACT)}
                    target="_blank"
                    rel="noreferrer"
                    className="inline-flex items-center gap-1 font-mono text-xs text-muted-foreground underline decoration-muted-foreground/30 underline-offset-4 transition-colors hover:text-foreground hover:decoration-primary"
                  >
                    {truncateAddress(USDT_TRC20_CONTRACT, 6, 4)}
                    <ExternalLink className="h-3 w-3" />
                  </a>


thinking
**Updating UI for API integration**

The UI currently says "local only," but since the story now includes server settings, I think we should update it to use the API when signed in. The story mentions adding the API but doesn't explicitly cover UI, yet the acceptance example talks about toggling and refresh. We can make minimal UI adjustments to call the API, linking it with the existing account section. We’ll just need to ensure it's set for tasks related to US-004 and conduct browser testing if UI changes are made.
thinking
**Evaluating UI and API changes**

I’m considering if adjusting the UI to use the API is necessary. I could opt to implement the API without changing the UI, which means acceptance tests wouldn’t validate the UI but could still be satisfied through API route tests. However, the acceptance mentions that toggling persists, implying the UI is needed. The story references Settings, suggesting UI changes are likely required. I think I’ll proceed with implementing the API and updating the Account section even if it isn't strictly necessary.
exec
/bin/zsh -lc "sed -n '1,200p' src/lib/db/user-settings.ts" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 47ms:
import "server-only";

import { eq } from "drizzle-orm";

import type { DbClient } from "@/lib/db";
import { schema } from "@/lib/db";

export function buildGetUserSettingsQuery(db: DbClient, userId: string) {
  return db.select().from(schema.userSettings).where(eq(schema.userSettings.userId, userId)).limit(1);
}

export async function getUserSettings(db: DbClient, userId: string) {
  const rows = await buildGetUserSettingsQuery(db, userId).execute();
  return rows[0] ?? null;
}

export async function upsertUserSettings(db: DbClient, userId: string, loggingEnabled: boolean) {
  const rows = await db
    .insert(schema.userSettings)
    .values({ userId, loggingEnabled })
exec
/bin/zsh -lc 'find src/app/api -maxdepth 3 -type d -print' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 63ms:
src/app/api
src/app/api/analyze
src/app/api/check
exec
/bin/zsh -lc "sed -n '1,200p' middleware.ts" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 85ms:
import { NextResponse } from "next/server";
import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";

const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY && process.env.CLERK_SECRET_KEY);

const isPublicRoute = createRouteMatcher([
  "/",
  "/api/check",
  "/api/analyze",
  "/sign-in(.*)",
  "/sign-up(.*)",
]);

const clerk = clerkMiddleware((auth, req) => {
  if (isPublicRoute(req)) return;
  return auth().then(({ userId, redirectToSignIn }) => {
    if (!userId) return redirectToSignIn();
    return undefined;
  });
});





thinking
**Examining API middleware**

I'm looking at how middleware handles API routes, particularly for public and non-public paths like /api/settings. It seems like unauthenticated requests should ideally lead to a 401 response, but I also have to consider if they should redirect to sign-in instead. The existing norms say to redirect, but it could complicate things if we need a 401 status. I wonder how clerkMiddleware might impact this flow? It could change how we deal with authentication checks for specific routes.
thinking
**Resolving API route conflicts**

I'm trying to figure out how to handle 401 responses versus redirects in my API routes. It seems there’s a conflict because existing patterns suggest a redirect, but negative cases expect a 401 status instead. 

I might need to adjust the middleware to treat /api/settings differently, perhaps as public, but then it conflicts with the need for unauthenticated requests to be rejected properly. 

So, a possible solution could be to respond with a 401 JSON instead of redirecting, which feels like a solid compromise.
thinking
**Deciding on API handling**

I’m grappling with whether to let middleware handle redirects or go for a 401 status instead. While marking /api/settings as public could work, modifying the middleware directly seems more efficient. If I set it up to return a 401 status for any API route, that should keep things consistent, especially for future private APIs.

This change might affect existing behavior in endpoints but seems like a necessary adjustment to ensure correct status codes without needing to constantly revisit public route settings. It feels like a good compromise!
thinking
**Refining API middleware**

I'm thinking about how to adjust the middleware without changing unrelated code. It’s important to handle unauthorized requests properly, especially since the story specifies a 401 response for unauthenticated updates. I figure bypassing middleware or tweaking it might be the way to go.

We also need safe defaults, like returning `loggingEnabled: false` if no row exists. I need to ensure that unauthorized updates don’t create database rows and that API logs don’t include sensitive information. I’ll implement GET and PATCH routes for /api/settings with the expected response shape.
thinking
**Defining API response structure**

I need to decide on the API response structure. Maybe it should include something simple like {ok: true}, but I don't think adding {userId?} is necessary. Keeping it minimal is key. 

For the GET request, I must ensure it returns false if no row exists and doesn’t create a row. If DATABASE_URL is missing, the upsert function should also error out. I think using requireDb for that could work, so I’ll check the implementation in src/lib/db/index.ts. That feels like a good direction!
exec
/bin/zsh -lc "sed -n '1,120p' src/lib/db/index.ts" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 62ms:
import "server-only";

import postgres from "postgres";
import { drizzle } from "drizzle-orm/postgres-js";

import * as schema from "@/lib/db/schema";

export type DbClient = ReturnType<typeof createDbClient>;

function createDbClient(databaseUrl: string) {
  const sql = postgres(databaseUrl, {
    max: process.env.NODE_ENV === "production" ? 10 : 1,
  });

  return drizzle(sql, { schema });
}

const globalForDb = globalThis as unknown as {
  dbClient?: DbClient;
};

thinking
Hmm, I'm looking at the `getUserSettings` function, which can return either a row or null. Our API interprets null as false, so I think minimal changes might involve adding an API route and writing tests while mocking `getUserSettings`, `upsertUserSettings`, and `getDb`. Updating the UI could be an option, but that might trigger a browser test, though time might allow for it. I need to check the DB schema for the `userSettings` table fields, like createdAt and updatedAt.
exec
/bin/zsh -lc "sed -n '1,120p' src/lib/db/schema.ts" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 58ms:
import { boolean, index, integer, jsonb, pgTable, text, timestamp, uuid } from "drizzle-orm/pg-core";

export const userSettings = pgTable("user_settings", {
  userId: text("user_id").primaryKey(),
  loggingEnabled: boolean("logging_enabled").notNull().default(false),
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(),
});

export const savedReports = pgTable(
  "saved_reports",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    userId: text("user_id")
      .notNull()
      .references(() => userSettings.userId, { onDelete: "cascade" }),
    address: text("address").notNull(),
    addressHash: text("address_hash").notNull(),
    riskScore: integer("risk_score").notNull(),
    riskTier: text("risk_tier").notNull(),
exec
/bin/zsh -lc "sed -n '1,200p' src/lib/validators.ts" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 66ms:
import bs58 from "bs58";
import { sha256 } from "@noble/hashes/sha2.js";
import { z } from "zod";

export type TronAddressValidation =
  | { ok: true; normalized: string }
  | { ok: false; normalized: string; error: string };

export function normalizeTronAddress(input: string): string {
  return input.trim();
}

function bytesEqual(a: Uint8Array, b: Uint8Array): boolean {
  if (a.length !== b.length) return false;
  for (let i = 0; i < a.length; i += 1) if (a[i] !== b[i]) return false;
  return true;
}

export function validateTronAddress(input: string): TronAddressValidation {
  const normalized = normalizeTronAddress(input);


thinking
**Considering local preferences and testing**

I'm thinking about how local preferences might be used for sign-out, even though it's not applied elsewhere right now. It's possible that they could be useful for saving analysis routes in the future.

For now, I want to keep localStorage as a fallback when the database or API is unavailable. When signed in, I’d use server settings as the main source. I also need to ensure that no raw addresses are logged. Lastly, I’ll add route tests to the appropriate directory.
thinking
**Planning route tests**

I’m planning to add `src/app/api/user-settings/route.test.ts` specifically for testing request responses. I need to check if the vitest configuration includes all test files with the pattern `src/**/*.test.ts`, which might cover the app directory as well. It’s essential to ensure everything is correctly set up for effective testing, so I'll need to look into the vitest configuration further to verify that it includes what I need.
exec
/bin/zsh -lc "sed -n '1,200p' vitest.config.ts" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 69ms:
import path from "node:path";
import { defineConfig } from "vitest/config";

export default defineConfig({
  test: {
    environment: "node",
    include: ["src/**/*.test.ts"],
    coverage: {
      provider: "v8",
      reporter: ["text", "html"],
      reportsDirectory: "./coverage",
    },
  },
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
      "server-only": path.resolve(__dirname, "./src/lib/vitest-server-only.ts"),
    },
  },
});

thinking
**Considering mocking in tests**

I’m thinking about whether I need to mock NextResponse, which is from next/server. In testing, I guess I can use the actual one since it has a json method. It seems we can call route handlers and check the Response from the web API. I’ll need to mock the `auth` function with vi.mock from the "@clerk/nextjs/server" module, and I should search to see if there are any other tests related to this.
exec
/bin/zsh -lc "rg -n \"vi\\.mock\\(\\\"@clerk/nextjs/server\\\"\" -S src || true" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 74ms:
src/__tests__/api-analyze.test.ts:4:vi.mock("@clerk/nextjs/server", () => ({ auth }));
exec
/bin/zsh -lc "sed -n '1,200p' src/__tests__/api-analyze.test.ts" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 39ms:
import { beforeEach, describe, expect, it, vi } from "vitest";

const auth = vi.fn();
vi.mock("@clerk/nextjs/server", () => ({ auth }));

const checkTronScanUsdtBlacklist = vi.fn();
const fetchUsdtTrc20Transfers = vi.fn();
const fetchTronScanAccountTag = vi.fn();
vi.mock("@/lib/tronscan", () => ({
  checkTronScanUsdtBlacklist,
  fetchUsdtTrc20Transfers,
  fetchTronScanAccountTag,
}));

const readUsdtBlacklistStatusOnChain = vi.fn();
vi.mock("@/lib/tron", () => ({
  readUsdtBlacklistStatusOnChain,
}));

const checkOfacSanctions = vi.fn();
exec
/bin/zsh -lc "rg -n \"vi\\.mock\\(\\\"@/lib/db\" -S src || true" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 87ms:


thinking
**Checking component details**

I need to confirm if the main component can call `useAuth`. I think it’s a client component, but I should verify that by checking the top of the file for "use client" and imported modules. By doing this, I'll ensure everything is set up correctly before moving forward. It's better to double-check to avoid any issues later on! Let’s look into this to make sure we're on the right track.
exec
/bin/zsh -lc "sed -n '1,80p' src/components/blacklist-checker.tsx" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 66ms:
"use client";

import * as React from "react";
import Image from "next/image";
import { AnimatePresence, motion } from "framer-motion";
import { SignedIn, SignedOut, SignInButton, UserButton, useAuth } from "@clerk/nextjs";
import {
  AlertTriangle,
  CheckCircle2,
  ChevronRight,
  Copy,
  Check,
  ExternalLink,
  Info,
  Loader2,
  ShieldAlert,
  ShieldCheck,
  EyeOff,
} from "lucide-react";
import { toast } from "sonner";

thinking
**Updating steps and logs**

I need to remember to update the `.ralph/activity.log` after making major code changes, like running a command to log significant events. Now, I'm progressing with the implementation. Let’s update my plan: I've already finished step 2, which was the audit. Now, I’m moving on to implement the routes and will mark step 2 as complete while noting that step 3 is currently in progress.
Plan update
  ✓ Review guardrails and prior errors
  ✓ Audit existing auth, DB, API patterns
  → Implement settings GET/PUT routes
  • Add unit/route tests
  • Run lint, test, build
  • Security/perf/regression review, commit, logs
file update
A /Users/chiko/side_projects/usdt_blacklisted_web/src/app/api/user-settings/route.ts
import { NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import { z } from "zod";

import { getDb } from "@/lib/db";
import { getUserSettings, upsertUserSettings } from "@/lib/db/user-settings";

export const runtime = "nodejs";

const UpdateUserSettingsSchema = z.object({
  loggingEnabled: z.boolean(),
});

async function getAuthenticatedUserId(): Promise<string | null> {
  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
  try {
    const { userId } = await auth();
    return userId ?? null;
  } catch {
    return null;
  }
}

export async function GET() {
  const userId = await getAuthenticatedUserId();
  if (!userId) {
    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
  }

  const db = getDb();
  if (!db) {
    return NextResponse.json(
      { loggingEnabled: false, persistenceAvailable: false },
      { status: 200, headers: { "Cache-Control": "no-store" } },
    );
  }

  const settings = await getUserSettings(db, userId);
  return NextResponse.json(
    { loggingEnabled: settings?.loggingEnabled ?? false, persistenceAvailable: true },
    { status: 200, headers: { "Cache-Control": "no-store" } },
  );
}

export async function PATCH(request: Request) {
  const userId = await getAuthenticatedUserId();
  if (!userId) {
    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
  }

  const db = getDb();
  if (!db) {
    return NextResponse.json(
      { error: "Persistence is disabled." },
      { status: 503, headers: { "Cache-Control": "no-store" } },
    );
  }

  let json: unknown;
  try {
    json = await request.json();
  } catch {
    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
  }

  const parsed = UpdateUserSettingsSchema.safeParse(json);
  if (!parsed.success) {
    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
  }

  const updated = await upsertUserSettings(db, userId, parsed.data.loggingEnabled);
  return NextResponse.json(
    { loggingEnabled: updated?.loggingEnabled ?? parsed.data.loggingEnabled, persistenceAvailable: true },
    { status: 200, headers: { "Cache-Control": "no-store" } },
  );
}

M /Users/chiko/side_projects/usdt_blacklisted_web/middleware.ts
@@ -9,2 +9,3 @@
   "/api/analyze",
+  "/api/user-settings",
   "/sign-in(.*)",
apply_patch(auto_approved=true) exited 0 in 34ms:
Success. Updated the following files:
A src/app/api/user-settings/route.ts
M middleware.ts
file update:
diff --git a/middleware.ts b/middleware.ts
index 9009ef94a93548a37928fbb79db4d17573dde8b0..6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c
--- a/middleware.ts
+++ b/middleware.ts
@@ -7,6 +7,7 @@
   "/",
   "/api/check",
   "/api/analyze",
+  "/api/user-settings",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/app/api/user-settings/route.ts b/src/app/api/user-settings/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..370e41418b9539b44e9aaad5fc5f9405b260485b
--- /dev/null
+++ b/src/app/api/user-settings/route.ts
@@ -0,0 +1,77 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { getUserSettings, upsertUserSettings } from "@/lib/db/user-settings";
+
+export const runtime = "nodejs";
+
+const UpdateUserSettingsSchema = z.object({
+  loggingEnabled: z.boolean(),
+});
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function GET() {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { loggingEnabled: false, persistenceAvailable: false },
+      { status: 200, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const settings = await getUserSettings(db, userId);
+  return NextResponse.json(
+    { loggingEnabled: settings?.loggingEnabled ?? false, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
+export async function PATCH(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { error: "Persistence is disabled." },
+      { status: 503, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = UpdateUserSettingsSchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const updated = await upsertUserSettings(db, userId, parsed.data.loggingEnabled);
+  return NextResponse.json(
+    { loggingEnabled: updated?.loggingEnabled ?? parsed.data.loggingEnabled, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+

file update:
diff --git a/middleware.ts b/middleware.ts
index 9009ef94a93548a37928fbb79db4d17573dde8b0..6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c
--- a/middleware.ts
+++ b/middleware.ts
@@ -7,6 +7,7 @@
   "/",
   "/api/check",
   "/api/analyze",
+  "/api/user-settings",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/app/api/user-settings/route.ts b/src/app/api/user-settings/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..370e41418b9539b44e9aaad5fc5f9405b260485b
--- /dev/null
+++ b/src/app/api/user-settings/route.ts
@@ -0,0 +1,77 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { getUserSettings, upsertUserSettings } from "@/lib/db/user-settings";
+
+export const runtime = "nodejs";
+
+const UpdateUserSettingsSchema = z.object({
+  loggingEnabled: z.boolean(),
+});
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function GET() {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { loggingEnabled: false, persistenceAvailable: false },
+      { status: 200, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const settings = await getUserSettings(db, userId);
+  return NextResponse.json(
+    { loggingEnabled: settings?.loggingEnabled ?? false, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
+export async function PATCH(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { error: "Persistence is disabled." },
+      { status: 503, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = UpdateUserSettingsSchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const updated = await upsertUserSettings(db, userId, parsed.data.loggingEnabled);
+  return NextResponse.json(
+    { loggingEnabled: updated?.loggingEnabled ?? parsed.data.loggingEnabled, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+

exec
/bin/zsh -lc '/Users/chiko/side_projects/usdt_blacklisted_web/ralph log "Added /api/user-settings route (GET/PATCH) and made it public in middleware to allow 401 responses"' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 95ms:

file update:
diff --git a/middleware.ts b/middleware.ts
index 9009ef94a93548a37928fbb79db4d17573dde8b0..6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c
--- a/middleware.ts
+++ b/middleware.ts
@@ -7,6 +7,7 @@
   "/",
   "/api/check",
   "/api/analyze",
+  "/api/user-settings",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/app/api/user-settings/route.ts b/src/app/api/user-settings/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..370e41418b9539b44e9aaad5fc5f9405b260485b
--- /dev/null
+++ b/src/app/api/user-settings/route.ts
@@ -0,0 +1,77 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { getUserSettings, upsertUserSettings } from "@/lib/db/user-settings";
+
+export const runtime = "nodejs";
+
+const UpdateUserSettingsSchema = z.object({
+  loggingEnabled: z.boolean(),
+});
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function GET() {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { loggingEnabled: false, persistenceAvailable: false },
+      { status: 200, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const settings = await getUserSettings(db, userId);
+  return NextResponse.json(
+    { loggingEnabled: settings?.loggingEnabled ?? false, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
+export async function PATCH(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { error: "Persistence is disabled." },
+      { status: 503, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = UpdateUserSettingsSchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const updated = await upsertUserSettings(db, userId, parsed.data.loggingEnabled);
+  return NextResponse.json(
+    { loggingEnabled: updated?.loggingEnabled ?? parsed.data.loggingEnabled, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+

file update
M /Users/chiko/side_projects/usdt_blacklisted_web/src/components/blacklist-checker.tsx
@@ -535,2 +535,3 @@
   const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
+  const { isLoaded: authLoaded, isSignedIn } = useAuth();
 
@@ -540,2 +541,3 @@
   const [loggingEnabled, setLoggingEnabled] = React.useState(false);
+  const fetchedServerLoggingPref = React.useRef(false);
 
@@ -553,2 +555,31 @@
 
+  React.useEffect(() => {
+    if (!clerkEnabled) return;
+    if (!authLoaded) return;
+    if (!isSignedIn) {
+      fetchedServerLoggingPref.current = false;
+      return;
+    }
+    if (fetchedServerLoggingPref.current) return;
+    fetchedServerLoggingPref.current = true;
+
+    const controller = new AbortController();
+    void (async () => {
+      try {
+        const res = await fetch("/api/user-settings", { method: "GET", credentials: "include", signal: controller.signal });
+        if (!res.ok) return;
+        const json = (await res.json()) as unknown;
+        if (!json || typeof json !== "object") return;
+        const v = (json as Record<string, unknown>).loggingEnabled;
+        if (typeof v !== "boolean") return;
+        setLoggingEnabled(v);
+        writeLocalLoggingPref(v);
+      } catch {
+        // ignore
+      }
+    })();
+
+    return () => controller.abort();
+  }, [clerkEnabled, authLoaded, isSignedIn]);
+
   const normalizedAddress = validation?.normalized ?? address.trim();
@@ -883,3 +914,3 @@
             >
-              <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+                  <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
                 <CardHeader className="pb-3">
@@ -887,3 +918,3 @@
                   <CardDescription>
-                    Configure privacy defaults. Saving reports is not enabled yet (DB/credits work is next).
+                    Configure privacy defaults. Report saving is opt-in and controlled by this setting.
                   </CardDescription>
@@ -894,3 +925,3 @@
                     <div className="mt-1 text-sm text-muted-foreground">
-                      This currently stores only a local preference. No server-side address logging is performed yet.
+                      This setting is saved to your account. Screening history persistence remains opt-in.
                     </div>
@@ -902,3 +933,31 @@
                       writeLocalLoggingPref(v);
-                      toast.message(v ? "Logging preference enabled (local only)" : "Logging preference disabled");
+
+                      void (async () => {
+                        try {
+                          const res = await fetch("/api/user-settings", {
+                            method: "PATCH",
+                            headers: { "content-type": "application/json" },
+                            credentials: "include",
+                            body: JSON.stringify({ loggingEnabled: v }),
+                          });
+
+                          if (!res.ok) throw new Error(`Request failed (${res.status}).`);
+                          const json = (await res.json()) as unknown;
+                          const value =
+                            json && typeof json === "object" ? (json as Record<string, unknown>).loggingEnabled : undefined;
+                          if (typeof value === "boolean") {
+                            setLoggingEnabled(value);
+                            writeLocalLoggingPref(value);
+                          }
+
+                          toast.message(v ? "Saving preference enabled" : "Saving preference disabled");
+                        } catch {
+                          setLoggingEnabled((prev) => {
+                            const revert = !v;
+                            writeLocalLoggingPref(revert);
+                            return revert;
+                          });
+                          toast.message("Could not update preference. Please try again.");
+                        }
+                      })();
                     }}
apply_patch(auto_approved=true) exited 0 in 46ms:
Success. Updated the following files:
M src/components/blacklist-checker.tsx
file update:
diff --git a/middleware.ts b/middleware.ts
index 9009ef94a93548a37928fbb79db4d17573dde8b0..6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c
--- a/middleware.ts
+++ b/middleware.ts
@@ -7,6 +7,7 @@
   "/",
   "/api/check",
   "/api/analyze",
+  "/api/user-settings",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/app/api/user-settings/route.ts b/src/app/api/user-settings/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..370e41418b9539b44e9aaad5fc5f9405b260485b
--- /dev/null
+++ b/src/app/api/user-settings/route.ts
@@ -0,0 +1,77 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { getUserSettings, upsertUserSettings } from "@/lib/db/user-settings";
+
+export const runtime = "nodejs";
+
+const UpdateUserSettingsSchema = z.object({
+  loggingEnabled: z.boolean(),
+});
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function GET() {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { loggingEnabled: false, persistenceAvailable: false },
+      { status: 200, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const settings = await getUserSettings(db, userId);
+  return NextResponse.json(
+    { loggingEnabled: settings?.loggingEnabled ?? false, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
+export async function PATCH(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { error: "Persistence is disabled." },
+      { status: 503, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = UpdateUserSettingsSchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const updated = await upsertUserSettings(db, userId, parsed.data.loggingEnabled);
+  return NextResponse.json(
+    { loggingEnabled: updated?.loggingEnabled ?? parsed.data.loggingEnabled, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 9db92fbfddf12094c87fc753d64f71213afd6e34..cc55ea86919cb717b261115eba22baacd1db415c
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -533,11 +533,13 @@
 export function BlacklistChecker() {
   const m = getMessages("en");
   const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
+  const { isLoaded: authLoaded, isSignedIn } = useAuth();
 
   const [address, setAddress] = React.useState("");
   const [validation, setValidation] = React.useState<ReturnType<typeof validateTronAddress> | null>(null);
   const [load, setLoad] = React.useState<LoadState>({ state: "idle" });
   const [loggingEnabled, setLoggingEnabled] = React.useState(false);
+  const fetchedServerLoggingPref = React.useRef(false);
 
   React.useEffect(() => {
     const handle = window.setTimeout(() => {
@@ -551,6 +553,35 @@
     setLoggingEnabled(readLocalLoggingPref());
   }, []);
 
+  React.useEffect(() => {
+    if (!clerkEnabled) return;
+    if (!authLoaded) return;
+    if (!isSignedIn) {
+      fetchedServerLoggingPref.current = false;
+      return;
+    }
+    if (fetchedServerLoggingPref.current) return;
+    fetchedServerLoggingPref.current = true;
+
+    const controller = new AbortController();
+    void (async () => {
+      try {
+        const res = await fetch("/api/user-settings", { method: "GET", credentials: "include", signal: controller.signal });
+        if (!res.ok) return;
+        const json = (await res.json()) as unknown;
+        if (!json || typeof json !== "object") return;
+        const v = (json as Record<string, unknown>).loggingEnabled;
+        if (typeof v !== "boolean") return;
+        setLoggingEnabled(v);
+        writeLocalLoggingPref(v);
+      } catch {
+        // ignore
+      }
+    })();
+
+    return () => controller.abort();
+  }, [clerkEnabled, authLoaded, isSignedIn]);
+
   const normalizedAddress = validation?.normalized ?? address.trim();
   const isValid = validation?.ok ?? false;
 
@@ -881,18 +912,18 @@
               transition={{ duration: 0.4, delay: 0.18 }}
               className="mx-auto mt-4 max-w-2xl"
             >
-              <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+                  <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
                 <CardHeader className="pb-3">
                   <CardTitle className="text-base">Account</CardTitle>
                   <CardDescription>
-                    Configure privacy defaults. Saving reports is not enabled yet (DB/credits work is next).
+                    Configure privacy defaults. Report saving is opt-in and controlled by this setting.
                   </CardDescription>
                 </CardHeader>
                 <CardContent className="flex items-start justify-between gap-4">
                   <div className="min-w-0">
                     <div className="text-sm font-medium text-foreground">Opt-in: save screening history</div>
                     <div className="mt-1 text-sm text-muted-foreground">
-                      This currently stores only a local preference. No server-side address logging is performed yet.
+                      This setting is saved to your account. Screening history persistence remains opt-in.
                     </div>
                   </div>
                   <Switch
@@ -900,7 +931,35 @@
                     onCheckedChange={(v) => {
                       setLoggingEnabled(v);
                       writeLocalLoggingPref(v);
-                      toast.message(v ? "Logging preference enabled (local only)" : "Logging preference disabled");
+
+                      void (async () => {
+                        try {
+                          const res = await fetch("/api/user-settings", {
+                            method: "PATCH",
+                            headers: { "content-type": "application/json" },
+                            credentials: "include",
+                            body: JSON.stringify({ loggingEnabled: v }),
+                          });
+
+                          if (!res.ok) throw new Error(`Request failed (${res.status}).`);
+                          const json = (await res.json()) as unknown;
+                          const value =
+                            json && typeof json === "object" ? (json as Record<string, unknown>).loggingEnabled : undefined;
+                          if (typeof value === "boolean") {
+                            setLoggingEnabled(value);
+                            writeLocalLoggingPref(value);
+                          }
+
+                          toast.message(v ? "Saving preference enabled" : "Saving preference disabled");
+                        } catch {
+                          setLoggingEnabled((prev) => {
+                            const revert = !v;
+                            writeLocalLoggingPref(revert);
+                            return revert;
+                          });
+                          toast.message("Could not update preference. Please try again.");
+                        }
+                      })();
                     }}
                     aria-label="Enable saving screening history"
                   />

file update:
diff --git a/middleware.ts b/middleware.ts
index 9009ef94a93548a37928fbb79db4d17573dde8b0..6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c
--- a/middleware.ts
+++ b/middleware.ts
@@ -7,6 +7,7 @@
   "/",
   "/api/check",
   "/api/analyze",
+  "/api/user-settings",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/app/api/user-settings/route.ts b/src/app/api/user-settings/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..370e41418b9539b44e9aaad5fc5f9405b260485b
--- /dev/null
+++ b/src/app/api/user-settings/route.ts
@@ -0,0 +1,77 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { getUserSettings, upsertUserSettings } from "@/lib/db/user-settings";
+
+export const runtime = "nodejs";
+
+const UpdateUserSettingsSchema = z.object({
+  loggingEnabled: z.boolean(),
+});
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function GET() {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { loggingEnabled: false, persistenceAvailable: false },
+      { status: 200, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const settings = await getUserSettings(db, userId);
+  return NextResponse.json(
+    { loggingEnabled: settings?.loggingEnabled ?? false, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
+export async function PATCH(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { error: "Persistence is disabled." },
+      { status: 503, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = UpdateUserSettingsSchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const updated = await upsertUserSettings(db, userId, parsed.data.loggingEnabled);
+  return NextResponse.json(
+    { loggingEnabled: updated?.loggingEnabled ?? parsed.data.loggingEnabled, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 9db92fbfddf12094c87fc753d64f71213afd6e34..cc55ea86919cb717b261115eba22baacd1db415c
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -533,11 +533,13 @@
 export function BlacklistChecker() {
   const m = getMessages("en");
   const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
+  const { isLoaded: authLoaded, isSignedIn } = useAuth();
 
   const [address, setAddress] = React.useState("");
   const [validation, setValidation] = React.useState<ReturnType<typeof validateTronAddress> | null>(null);
   const [load, setLoad] = React.useState<LoadState>({ state: "idle" });
   const [loggingEnabled, setLoggingEnabled] = React.useState(false);
+  const fetchedServerLoggingPref = React.useRef(false);
 
   React.useEffect(() => {
     const handle = window.setTimeout(() => {
@@ -551,6 +553,35 @@
     setLoggingEnabled(readLocalLoggingPref());
   }, []);
 
+  React.useEffect(() => {
+    if (!clerkEnabled) return;
+    if (!authLoaded) return;
+    if (!isSignedIn) {
+      fetchedServerLoggingPref.current = false;
+      return;
+    }
+    if (fetchedServerLoggingPref.current) return;
+    fetchedServerLoggingPref.current = true;
+
+    const controller = new AbortController();
+    void (async () => {
+      try {
+        const res = await fetch("/api/user-settings", { method: "GET", credentials: "include", signal: controller.signal });
+        if (!res.ok) return;
+        const json = (await res.json()) as unknown;
+        if (!json || typeof json !== "object") return;
+        const v = (json as Record<string, unknown>).loggingEnabled;
+        if (typeof v !== "boolean") return;
+        setLoggingEnabled(v);
+        writeLocalLoggingPref(v);
+      } catch {
+        // ignore
+      }
+    })();
+
+    return () => controller.abort();
+  }, [clerkEnabled, authLoaded, isSignedIn]);
+
   const normalizedAddress = validation?.normalized ?? address.trim();
   const isValid = validation?.ok ?? false;
 
@@ -881,18 +912,18 @@
               transition={{ duration: 0.4, delay: 0.18 }}
               className="mx-auto mt-4 max-w-2xl"
             >
-              <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+                  <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
                 <CardHeader className="pb-3">
                   <CardTitle className="text-base">Account</CardTitle>
                   <CardDescription>
-                    Configure privacy defaults. Saving reports is not enabled yet (DB/credits work is next).
+                    Configure privacy defaults. Report saving is opt-in and controlled by this setting.
                   </CardDescription>
                 </CardHeader>
                 <CardContent className="flex items-start justify-between gap-4">
                   <div className="min-w-0">
                     <div className="text-sm font-medium text-foreground">Opt-in: save screening history</div>
                     <div className="mt-1 text-sm text-muted-foreground">
-                      This currently stores only a local preference. No server-side address logging is performed yet.
+                      This setting is saved to your account. Screening history persistence remains opt-in.
                     </div>
                   </div>
                   <Switch
@@ -900,7 +931,35 @@
                     onCheckedChange={(v) => {
                       setLoggingEnabled(v);
                       writeLocalLoggingPref(v);
-                      toast.message(v ? "Logging preference enabled (local only)" : "Logging preference disabled");
+
+                      void (async () => {
+                        try {
+                          const res = await fetch("/api/user-settings", {
+                            method: "PATCH",
+                            headers: { "content-type": "application/json" },
+                            credentials: "include",
+                            body: JSON.stringify({ loggingEnabled: v }),
+                          });
+
+                          if (!res.ok) throw new Error(`Request failed (${res.status}).`);
+                          const json = (await res.json()) as unknown;
+                          const value =
+                            json && typeof json === "object" ? (json as Record<string, unknown>).loggingEnabled : undefined;
+                          if (typeof value === "boolean") {
+                            setLoggingEnabled(value);
+                            writeLocalLoggingPref(value);
+                          }
+
+                          toast.message(v ? "Saving preference enabled" : "Saving preference disabled");
+                        } catch {
+                          setLoggingEnabled((prev) => {
+                            const revert = !v;
+                            writeLocalLoggingPref(revert);
+                            return revert;
+                          });
+                          toast.message("Could not update preference. Please try again.");
+                        }
+                      })();
                     }}
                     aria-label="Enable saving screening history"
                   />

exec
/bin/zsh -lc '/Users/chiko/side_projects/usdt_blacklisted_web/ralph log "Wired signed-in loggingEnabled toggle to /api/user-settings (fetch on sign-in, PATCH on change)"' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 83ms:

file update:
diff --git a/middleware.ts b/middleware.ts
index 9009ef94a93548a37928fbb79db4d17573dde8b0..6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c
--- a/middleware.ts
+++ b/middleware.ts
@@ -7,6 +7,7 @@
   "/",
   "/api/check",
   "/api/analyze",
+  "/api/user-settings",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/app/api/user-settings/route.ts b/src/app/api/user-settings/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..370e41418b9539b44e9aaad5fc5f9405b260485b
--- /dev/null
+++ b/src/app/api/user-settings/route.ts
@@ -0,0 +1,77 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { getUserSettings, upsertUserSettings } from "@/lib/db/user-settings";
+
+export const runtime = "nodejs";
+
+const UpdateUserSettingsSchema = z.object({
+  loggingEnabled: z.boolean(),
+});
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function GET() {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { loggingEnabled: false, persistenceAvailable: false },
+      { status: 200, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const settings = await getUserSettings(db, userId);
+  return NextResponse.json(
+    { loggingEnabled: settings?.loggingEnabled ?? false, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
+export async function PATCH(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { error: "Persistence is disabled." },
+      { status: 503, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = UpdateUserSettingsSchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const updated = await upsertUserSettings(db, userId, parsed.data.loggingEnabled);
+  return NextResponse.json(
+    { loggingEnabled: updated?.loggingEnabled ?? parsed.data.loggingEnabled, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 9db92fbfddf12094c87fc753d64f71213afd6e34..cc55ea86919cb717b261115eba22baacd1db415c
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -533,11 +533,13 @@
 export function BlacklistChecker() {
   const m = getMessages("en");
   const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
+  const { isLoaded: authLoaded, isSignedIn } = useAuth();
 
   const [address, setAddress] = React.useState("");
   const [validation, setValidation] = React.useState<ReturnType<typeof validateTronAddress> | null>(null);
   const [load, setLoad] = React.useState<LoadState>({ state: "idle" });
   const [loggingEnabled, setLoggingEnabled] = React.useState(false);
+  const fetchedServerLoggingPref = React.useRef(false);
 
   React.useEffect(() => {
     const handle = window.setTimeout(() => {
@@ -551,6 +553,35 @@
     setLoggingEnabled(readLocalLoggingPref());
   }, []);
 
+  React.useEffect(() => {
+    if (!clerkEnabled) return;
+    if (!authLoaded) return;
+    if (!isSignedIn) {
+      fetchedServerLoggingPref.current = false;
+      return;
+    }
+    if (fetchedServerLoggingPref.current) return;
+    fetchedServerLoggingPref.current = true;
+
+    const controller = new AbortController();
+    void (async () => {
+      try {
+        const res = await fetch("/api/user-settings", { method: "GET", credentials: "include", signal: controller.signal });
+        if (!res.ok) return;
+        const json = (await res.json()) as unknown;
+        if (!json || typeof json !== "object") return;
+        const v = (json as Record<string, unknown>).loggingEnabled;
+        if (typeof v !== "boolean") return;
+        setLoggingEnabled(v);
+        writeLocalLoggingPref(v);
+      } catch {
+        // ignore
+      }
+    })();
+
+    return () => controller.abort();
+  }, [clerkEnabled, authLoaded, isSignedIn]);
+
   const normalizedAddress = validation?.normalized ?? address.trim();
   const isValid = validation?.ok ?? false;
 
@@ -881,18 +912,18 @@
               transition={{ duration: 0.4, delay: 0.18 }}
               className="mx-auto mt-4 max-w-2xl"
             >
-              <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+                  <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
                 <CardHeader className="pb-3">
                   <CardTitle className="text-base">Account</CardTitle>
                   <CardDescription>
-                    Configure privacy defaults. Saving reports is not enabled yet (DB/credits work is next).
+                    Configure privacy defaults. Report saving is opt-in and controlled by this setting.
                   </CardDescription>
                 </CardHeader>
                 <CardContent className="flex items-start justify-between gap-4">
                   <div className="min-w-0">
                     <div className="text-sm font-medium text-foreground">Opt-in: save screening history</div>
                     <div className="mt-1 text-sm text-muted-foreground">
-                      This currently stores only a local preference. No server-side address logging is performed yet.
+                      This setting is saved to your account. Screening history persistence remains opt-in.
                     </div>
                   </div>
                   <Switch
@@ -900,7 +931,35 @@
                     onCheckedChange={(v) => {
                       setLoggingEnabled(v);
                       writeLocalLoggingPref(v);
-                      toast.message(v ? "Logging preference enabled (local only)" : "Logging preference disabled");
+
+                      void (async () => {
+                        try {
+                          const res = await fetch("/api/user-settings", {
+                            method: "PATCH",
+                            headers: { "content-type": "application/json" },
+                            credentials: "include",
+                            body: JSON.stringify({ loggingEnabled: v }),
+                          });
+
+                          if (!res.ok) throw new Error(`Request failed (${res.status}).`);
+                          const json = (await res.json()) as unknown;
+                          const value =
+                            json && typeof json === "object" ? (json as Record<string, unknown>).loggingEnabled : undefined;
+                          if (typeof value === "boolean") {
+                            setLoggingEnabled(value);
+                            writeLocalLoggingPref(value);
+                          }
+
+                          toast.message(v ? "Saving preference enabled" : "Saving preference disabled");
+                        } catch {
+                          setLoggingEnabled((prev) => {
+                            const revert = !v;
+                            writeLocalLoggingPref(revert);
+                            return revert;
+                          });
+                          toast.message("Could not update preference. Please try again.");
+                        }
+                      })();
                     }}
                     aria-label="Enable saving screening history"
                   />



thinking
**Evaluating logging logic**

I’ve introduced `toast.message` calls and need to ensure that the existing usage is fine. I’m reversing the logic with `setLoggingEnabled`. It seems to work, but I might want to revert to the previous value before toggling since that could be important. In the success case, I’ll use `v` to trigger a toast, but the server might return the same value. I need to ensure the API call still triggers correctly, even if persistence is disabled. Lastly, I see that multiple requests from quick toggles may happen, which is acceptable.
thinking
**Finalizing step completion**

I’ll start by adding tests now. But first, I need to confirm that I’ve marked step 3 as completed, which involved implementing the settings routes. Since that’s done, I can move on to the testing phase. It’s important to ensure that everything functions as expected, so I’ll focus on creating thorough tests. This way, I can catch any potential issues before finalizing everything. Alright, onward to testing!
Plan update
  ✓ Review guardrails and prior errors
  ✓ Audit existing auth, DB, API patterns
  ✓ Implement settings GET/PUT routes
  → Add unit/route tests
  • Run lint, test, build
  • Security/perf/regression review, commit, logs
file update:
diff --git a/middleware.ts b/middleware.ts
index 9009ef94a93548a37928fbb79db4d17573dde8b0..6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c
--- a/middleware.ts
+++ b/middleware.ts
@@ -7,6 +7,7 @@
   "/",
   "/api/check",
   "/api/analyze",
+  "/api/user-settings",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/app/api/user-settings/route.ts b/src/app/api/user-settings/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..370e41418b9539b44e9aaad5fc5f9405b260485b
--- /dev/null
+++ b/src/app/api/user-settings/route.ts
@@ -0,0 +1,77 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { getUserSettings, upsertUserSettings } from "@/lib/db/user-settings";
+
+export const runtime = "nodejs";
+
+const UpdateUserSettingsSchema = z.object({
+  loggingEnabled: z.boolean(),
+});
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function GET() {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { loggingEnabled: false, persistenceAvailable: false },
+      { status: 200, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const settings = await getUserSettings(db, userId);
+  return NextResponse.json(
+    { loggingEnabled: settings?.loggingEnabled ?? false, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
+export async function PATCH(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { error: "Persistence is disabled." },
+      { status: 503, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = UpdateUserSettingsSchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const updated = await upsertUserSettings(db, userId, parsed.data.loggingEnabled);
+  return NextResponse.json(
+    { loggingEnabled: updated?.loggingEnabled ?? parsed.data.loggingEnabled, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 9db92fbfddf12094c87fc753d64f71213afd6e34..cc55ea86919cb717b261115eba22baacd1db415c
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -533,11 +533,13 @@
 export function BlacklistChecker() {
   const m = getMessages("en");
   const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
+  const { isLoaded: authLoaded, isSignedIn } = useAuth();
 
   const [address, setAddress] = React.useState("");
   const [validation, setValidation] = React.useState<ReturnType<typeof validateTronAddress> | null>(null);
   const [load, setLoad] = React.useState<LoadState>({ state: "idle" });
   const [loggingEnabled, setLoggingEnabled] = React.useState(false);
+  const fetchedServerLoggingPref = React.useRef(false);
 
   React.useEffect(() => {
     const handle = window.setTimeout(() => {
@@ -551,6 +553,35 @@
     setLoggingEnabled(readLocalLoggingPref());
   }, []);
 
+  React.useEffect(() => {
+    if (!clerkEnabled) return;
+    if (!authLoaded) return;
+    if (!isSignedIn) {
+      fetchedServerLoggingPref.current = false;
+      return;
+    }
+    if (fetchedServerLoggingPref.current) return;
+    fetchedServerLoggingPref.current = true;
+
+    const controller = new AbortController();
+    void (async () => {
+      try {
+        const res = await fetch("/api/user-settings", { method: "GET", credentials: "include", signal: controller.signal });
+        if (!res.ok) return;
+        const json = (await res.json()) as unknown;
+        if (!json || typeof json !== "object") return;
+        const v = (json as Record<string, unknown>).loggingEnabled;
+        if (typeof v !== "boolean") return;
+        setLoggingEnabled(v);
+        writeLocalLoggingPref(v);
+      } catch {
+        // ignore
+      }
+    })();
+
+    return () => controller.abort();
+  }, [clerkEnabled, authLoaded, isSignedIn]);
+
   const normalizedAddress = validation?.normalized ?? address.trim();
   const isValid = validation?.ok ?? false;
 
@@ -881,18 +912,18 @@
               transition={{ duration: 0.4, delay: 0.18 }}
               className="mx-auto mt-4 max-w-2xl"
             >
-              <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+                  <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
                 <CardHeader className="pb-3">
                   <CardTitle className="text-base">Account</CardTitle>
                   <CardDescription>
-                    Configure privacy defaults. Saving reports is not enabled yet (DB/credits work is next).
+                    Configure privacy defaults. Report saving is opt-in and controlled by this setting.
                   </CardDescription>
                 </CardHeader>
                 <CardContent className="flex items-start justify-between gap-4">
                   <div className="min-w-0">
                     <div className="text-sm font-medium text-foreground">Opt-in: save screening history</div>
                     <div className="mt-1 text-sm text-muted-foreground">
-                      This currently stores only a local preference. No server-side address logging is performed yet.
+                      This setting is saved to your account. Screening history persistence remains opt-in.
                     </div>
                   </div>
                   <Switch
@@ -900,7 +931,35 @@
                     onCheckedChange={(v) => {
                       setLoggingEnabled(v);
                       writeLocalLoggingPref(v);
-                      toast.message(v ? "Logging preference enabled (local only)" : "Logging preference disabled");
+
+                      void (async () => {
+                        try {
+                          const res = await fetch("/api/user-settings", {
+                            method: "PATCH",
+                            headers: { "content-type": "application/json" },
+                            credentials: "include",
+                            body: JSON.stringify({ loggingEnabled: v }),
+                          });
+
+                          if (!res.ok) throw new Error(`Request failed (${res.status}).`);
+                          const json = (await res.json()) as unknown;
+                          const value =
+                            json && typeof json === "object" ? (json as Record<string, unknown>).loggingEnabled : undefined;
+                          if (typeof value === "boolean") {
+                            setLoggingEnabled(value);
+                            writeLocalLoggingPref(value);
+                          }
+
+                          toast.message(v ? "Saving preference enabled" : "Saving preference disabled");
+                        } catch {
+                          setLoggingEnabled((prev) => {
+                            const revert = !v;
+                            writeLocalLoggingPref(revert);
+                            return revert;
+                          });
+                          toast.message("Could not update preference. Please try again.");
+                        }
+                      })();
                     }}
                     aria-label="Enable saving screening history"
                   />

file update
A /Users/chiko/side_projects/usdt_blacklisted_web/src/__tests__/api-user-settings.test.ts
import { beforeEach, describe, expect, it, vi } from "vitest";

const auth = vi.fn();
vi.mock("@clerk/nextjs/server", () => ({ auth }));

const getDb = vi.fn();
vi.mock("@/lib/db", () => ({ getDb }));

const getUserSettings = vi.fn();
const upsertUserSettings = vi.fn();
vi.mock("@/lib/db/user-settings", () => ({ getUserSettings, upsertUserSettings }));

async function callGet() {
  const { GET } = await import("@/app/api/user-settings/route");
  const res = await GET();
  const json = await res.json();
  return { res, json };
}

async function callPatch(body: unknown) {
  const { PATCH } = await import("@/app/api/user-settings/route");
  const req = new Request("http://localhost/api/user-settings", {
    method: "PATCH",
    headers: { "content-type": "application/json" },
    body: JSON.stringify(body),
  });
  const res = await PATCH(req);
  const json = await res.json();
  return { res, json };
}

beforeEach(() => {
  vi.resetModules();
  vi.clearAllMocks();
  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
  process.env.CLERK_SECRET_KEY = "sk_test_123";
});

describe("/api/user-settings", () => {
  it("returns 401 when unauthenticated and does not touch the DB", async () => {
    auth.mockResolvedValue({ userId: null });

    const { res } = await callGet();
    expect(res.status).toBe(401);
    expect(getDb).not.toHaveBeenCalled();
    expect(getUserSettings).not.toHaveBeenCalled();
  });

  it("returns loggingEnabled=false when no row exists (default)", async () => {
    auth.mockResolvedValue({ userId: "user_123" });
    getDb.mockReturnValue({});
    getUserSettings.mockResolvedValue(null);

    const { res, json } = await callGet();
    expect(res.status).toBe(200);
    expect(json.loggingEnabled).toBe(false);
    expect(json.persistenceAvailable).toBe(true);
    expect(upsertUserSettings).not.toHaveBeenCalled();
  });

  it("rejects unauthenticated updates with 401 and does not create rows", async () => {
    auth.mockResolvedValue({ userId: null });

    const { res } = await callPatch({ loggingEnabled: true });
    expect(res.status).toBe(401);
    expect(getDb).not.toHaveBeenCalled();
    expect(upsertUserSettings).not.toHaveBeenCalled();
  });

  it("persists loggingEnabled via PATCH and returns the updated setting", async () => {
    auth.mockResolvedValue({ userId: "user_123" });
    getDb.mockReturnValue({});
    upsertUserSettings.mockResolvedValue({ loggingEnabled: true });

    const { res, json } = await callPatch({ loggingEnabled: true });
    expect(res.status).toBe(200);
    expect(json.loggingEnabled).toBe(true);
    expect(json.persistenceAvailable).toBe(true);
    expect(upsertUserSettings).toHaveBeenCalledWith({}, "user_123", true);
  });
});

apply_patch(auto_approved=true) exited 0 in 101ms:
Success. Updated the following files:
A src/__tests__/api-user-settings.test.ts
file update:
diff --git a/middleware.ts b/middleware.ts
index 9009ef94a93548a37928fbb79db4d17573dde8b0..6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c
--- a/middleware.ts
+++ b/middleware.ts
@@ -7,6 +7,7 @@
   "/",
   "/api/check",
   "/api/analyze",
+  "/api/user-settings",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-user-settings.test.ts b/src/__tests__/api-user-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..206dc68b6524190c6007f00b602147edc7b72713
--- /dev/null
+++ b/src/__tests__/api-user-settings.test.ts
@@ -0,0 +1,82 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+const upsertUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings, upsertUserSettings }));
+
+async function callGet() {
+  const { GET } = await import("@/app/api/user-settings/route");
+  const res = await GET();
+  const json = await res.json();
+  return { res, json };
+}
+
+async function callPatch(body: unknown) {
+  const { PATCH } = await import("@/app/api/user-settings/route");
+  const req = new Request("http://localhost/api/user-settings", {
+    method: "PATCH",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await PATCH(req);
+  const json = await res.json();
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+});
+
+describe("/api/user-settings", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callGet();
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("returns loggingEnabled=false when no row exists (default)", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue(null);
+
+    const { res, json } = await callGet();
+    expect(res.status).toBe(200);
+    expect(json.loggingEnabled).toBe(false);
+    expect(json.persistenceAvailable).toBe(true);
+    expect(upsertUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("rejects unauthenticated updates with 401 and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPatch({ loggingEnabled: true });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(upsertUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("persists loggingEnabled via PATCH and returns the updated setting", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    upsertUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const { res, json } = await callPatch({ loggingEnabled: true });
+    expect(res.status).toBe(200);
+    expect(json.loggingEnabled).toBe(true);
+    expect(json.persistenceAvailable).toBe(true);
+    expect(upsertUserSettings).toHaveBeenCalledWith({}, "user_123", true);
+  });
+});
+
diff --git a/src/app/api/user-settings/route.ts b/src/app/api/user-settings/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..370e41418b9539b44e9aaad5fc5f9405b260485b
--- /dev/null
+++ b/src/app/api/user-settings/route.ts
@@ -0,0 +1,77 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { getUserSettings, upsertUserSettings } from "@/lib/db/user-settings";
+
+export const runtime = "nodejs";
+
+const UpdateUserSettingsSchema = z.object({
+  loggingEnabled: z.boolean(),
+});
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function GET() {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { loggingEnabled: false, persistenceAvailable: false },
+      { status: 200, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const settings = await getUserSettings(db, userId);
+  return NextResponse.json(
+    { loggingEnabled: settings?.loggingEnabled ?? false, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
+export async function PATCH(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { error: "Persistence is disabled." },
+      { status: 503, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = UpdateUserSettingsSchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const updated = await upsertUserSettings(db, userId, parsed.data.loggingEnabled);
+  return NextResponse.json(
+    { loggingEnabled: updated?.loggingEnabled ?? parsed.data.loggingEnabled, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 9db92fbfddf12094c87fc753d64f71213afd6e34..cc55ea86919cb717b261115eba22baacd1db415c
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -533,11 +533,13 @@
 export function BlacklistChecker() {
   const m = getMessages("en");
   const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
+  const { isLoaded: authLoaded, isSignedIn } = useAuth();
 
   const [address, setAddress] = React.useState("");
   const [validation, setValidation] = React.useState<ReturnType<typeof validateTronAddress> | null>(null);
   const [load, setLoad] = React.useState<LoadState>({ state: "idle" });
   const [loggingEnabled, setLoggingEnabled] = React.useState(false);
+  const fetchedServerLoggingPref = React.useRef(false);
 
   React.useEffect(() => {
     const handle = window.setTimeout(() => {
@@ -551,6 +553,35 @@
     setLoggingEnabled(readLocalLoggingPref());
   }, []);
 
+  React.useEffect(() => {
+    if (!clerkEnabled) return;
+    if (!authLoaded) return;
+    if (!isSignedIn) {
+      fetchedServerLoggingPref.current = false;
+      return;
+    }
+    if (fetchedServerLoggingPref.current) return;
+    fetchedServerLoggingPref.current = true;
+
+    const controller = new AbortController();
+    void (async () => {
+      try {
+        const res = await fetch("/api/user-settings", { method: "GET", credentials: "include", signal: controller.signal });
+        if (!res.ok) return;
+        const json = (await res.json()) as unknown;
+        if (!json || typeof json !== "object") return;
+        const v = (json as Record<string, unknown>).loggingEnabled;
+        if (typeof v !== "boolean") return;
+        setLoggingEnabled(v);
+        writeLocalLoggingPref(v);
+      } catch {
+        // ignore
+      }
+    })();
+
+    return () => controller.abort();
+  }, [clerkEnabled, authLoaded, isSignedIn]);
+
   const normalizedAddress = validation?.normalized ?? address.trim();
   const isValid = validation?.ok ?? false;
 
@@ -881,18 +912,18 @@
               transition={{ duration: 0.4, delay: 0.18 }}
               className="mx-auto mt-4 max-w-2xl"
             >
-              <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+                  <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
                 <CardHeader className="pb-3">
                   <CardTitle className="text-base">Account</CardTitle>
                   <CardDescription>
-                    Configure privacy defaults. Saving reports is not enabled yet (DB/credits work is next).
+                    Configure privacy defaults. Report saving is opt-in and controlled by this setting.
                   </CardDescription>
                 </CardHeader>
                 <CardContent className="flex items-start justify-between gap-4">
                   <div className="min-w-0">
                     <div className="text-sm font-medium text-foreground">Opt-in: save screening history</div>
                     <div className="mt-1 text-sm text-muted-foreground">
-                      This currently stores only a local preference. No server-side address logging is performed yet.
+                      This setting is saved to your account. Screening history persistence remains opt-in.
                     </div>
                   </div>
                   <Switch
@@ -900,7 +931,35 @@
                     onCheckedChange={(v) => {
                       setLoggingEnabled(v);
                       writeLocalLoggingPref(v);
-                      toast.message(v ? "Logging preference enabled (local only)" : "Logging preference disabled");
+
+                      void (async () => {
+                        try {
+                          const res = await fetch("/api/user-settings", {
+                            method: "PATCH",
+                            headers: { "content-type": "application/json" },
+                            credentials: "include",
+                            body: JSON.stringify({ loggingEnabled: v }),
+                          });
+
+                          if (!res.ok) throw new Error(`Request failed (${res.status}).`);
+                          const json = (await res.json()) as unknown;
+                          const value =
+                            json && typeof json === "object" ? (json as Record<string, unknown>).loggingEnabled : undefined;
+                          if (typeof value === "boolean") {
+                            setLoggingEnabled(value);
+                            writeLocalLoggingPref(value);
+                          }
+
+                          toast.message(v ? "Saving preference enabled" : "Saving preference disabled");
+                        } catch {
+                          setLoggingEnabled((prev) => {
+                            const revert = !v;
+                            writeLocalLoggingPref(revert);
+                            return revert;
+                          });
+                          toast.message("Could not update preference. Please try again.");
+                        }
+                      })();
                     }}
                     aria-label="Enable saving screening history"
                   />

file update:
diff --git a/middleware.ts b/middleware.ts
index 9009ef94a93548a37928fbb79db4d17573dde8b0..6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c
--- a/middleware.ts
+++ b/middleware.ts
@@ -7,6 +7,7 @@
   "/",
   "/api/check",
   "/api/analyze",
+  "/api/user-settings",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-user-settings.test.ts b/src/__tests__/api-user-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..206dc68b6524190c6007f00b602147edc7b72713
--- /dev/null
+++ b/src/__tests__/api-user-settings.test.ts
@@ -0,0 +1,82 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+const upsertUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings, upsertUserSettings }));
+
+async function callGet() {
+  const { GET } = await import("@/app/api/user-settings/route");
+  const res = await GET();
+  const json = await res.json();
+  return { res, json };
+}
+
+async function callPatch(body: unknown) {
+  const { PATCH } = await import("@/app/api/user-settings/route");
+  const req = new Request("http://localhost/api/user-settings", {
+    method: "PATCH",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await PATCH(req);
+  const json = await res.json();
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+});
+
+describe("/api/user-settings", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callGet();
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("returns loggingEnabled=false when no row exists (default)", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue(null);
+
+    const { res, json } = await callGet();
+    expect(res.status).toBe(200);
+    expect(json.loggingEnabled).toBe(false);
+    expect(json.persistenceAvailable).toBe(true);
+    expect(upsertUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("rejects unauthenticated updates with 401 and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPatch({ loggingEnabled: true });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(upsertUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("persists loggingEnabled via PATCH and returns the updated setting", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    upsertUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const { res, json } = await callPatch({ loggingEnabled: true });
+    expect(res.status).toBe(200);
+    expect(json.loggingEnabled).toBe(true);
+    expect(json.persistenceAvailable).toBe(true);
+    expect(upsertUserSettings).toHaveBeenCalledWith({}, "user_123", true);
+  });
+});
+
diff --git a/src/app/api/user-settings/route.ts b/src/app/api/user-settings/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..370e41418b9539b44e9aaad5fc5f9405b260485b
--- /dev/null
+++ b/src/app/api/user-settings/route.ts
@@ -0,0 +1,77 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { getUserSettings, upsertUserSettings } from "@/lib/db/user-settings";
+
+export const runtime = "nodejs";
+
+const UpdateUserSettingsSchema = z.object({
+  loggingEnabled: z.boolean(),
+});
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function GET() {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { loggingEnabled: false, persistenceAvailable: false },
+      { status: 200, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const settings = await getUserSettings(db, userId);
+  return NextResponse.json(
+    { loggingEnabled: settings?.loggingEnabled ?? false, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
+export async function PATCH(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { error: "Persistence is disabled." },
+      { status: 503, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = UpdateUserSettingsSchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const updated = await upsertUserSettings(db, userId, parsed.data.loggingEnabled);
+  return NextResponse.json(
+    { loggingEnabled: updated?.loggingEnabled ?? parsed.data.loggingEnabled, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 9db92fbfddf12094c87fc753d64f71213afd6e34..cc55ea86919cb717b261115eba22baacd1db415c
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -533,11 +533,13 @@
 export function BlacklistChecker() {
   const m = getMessages("en");
   const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
+  const { isLoaded: authLoaded, isSignedIn } = useAuth();
 
   const [address, setAddress] = React.useState("");
   const [validation, setValidation] = React.useState<ReturnType<typeof validateTronAddress> | null>(null);
   const [load, setLoad] = React.useState<LoadState>({ state: "idle" });
   const [loggingEnabled, setLoggingEnabled] = React.useState(false);
+  const fetchedServerLoggingPref = React.useRef(false);
 
   React.useEffect(() => {
     const handle = window.setTimeout(() => {
@@ -551,6 +553,35 @@
     setLoggingEnabled(readLocalLoggingPref());
   }, []);
 
+  React.useEffect(() => {
+    if (!clerkEnabled) return;
+    if (!authLoaded) return;
+    if (!isSignedIn) {
+      fetchedServerLoggingPref.current = false;
+      return;
+    }
+    if (fetchedServerLoggingPref.current) return;
+    fetchedServerLoggingPref.current = true;
+
+    const controller = new AbortController();
+    void (async () => {
+      try {
+        const res = await fetch("/api/user-settings", { method: "GET", credentials: "include", signal: controller.signal });
+        if (!res.ok) return;
+        const json = (await res.json()) as unknown;
+        if (!json || typeof json !== "object") return;
+        const v = (json as Record<string, unknown>).loggingEnabled;
+        if (typeof v !== "boolean") return;
+        setLoggingEnabled(v);
+        writeLocalLoggingPref(v);
+      } catch {
+        // ignore
+      }
+    })();
+
+    return () => controller.abort();
+  }, [clerkEnabled, authLoaded, isSignedIn]);
+
   const normalizedAddress = validation?.normalized ?? address.trim();
   const isValid = validation?.ok ?? false;
 
@@ -881,18 +912,18 @@
               transition={{ duration: 0.4, delay: 0.18 }}
               className="mx-auto mt-4 max-w-2xl"
             >
-              <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+                  <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
                 <CardHeader className="pb-3">
                   <CardTitle className="text-base">Account</CardTitle>
                   <CardDescription>
-                    Configure privacy defaults. Saving reports is not enabled yet (DB/credits work is next).
+                    Configure privacy defaults. Report saving is opt-in and controlled by this setting.
                   </CardDescription>
                 </CardHeader>
                 <CardContent className="flex items-start justify-between gap-4">
                   <div className="min-w-0">
                     <div className="text-sm font-medium text-foreground">Opt-in: save screening history</div>
                     <div className="mt-1 text-sm text-muted-foreground">
-                      This currently stores only a local preference. No server-side address logging is performed yet.
+                      This setting is saved to your account. Screening history persistence remains opt-in.
                     </div>
                   </div>
                   <Switch
@@ -900,7 +931,35 @@
                     onCheckedChange={(v) => {
                       setLoggingEnabled(v);
                       writeLocalLoggingPref(v);
-                      toast.message(v ? "Logging preference enabled (local only)" : "Logging preference disabled");
+
+                      void (async () => {
+                        try {
+                          const res = await fetch("/api/user-settings", {
+                            method: "PATCH",
+                            headers: { "content-type": "application/json" },
+                            credentials: "include",
+                            body: JSON.stringify({ loggingEnabled: v }),
+                          });
+
+                          if (!res.ok) throw new Error(`Request failed (${res.status}).`);
+                          const json = (await res.json()) as unknown;
+                          const value =
+                            json && typeof json === "object" ? (json as Record<string, unknown>).loggingEnabled : undefined;
+                          if (typeof value === "boolean") {
+                            setLoggingEnabled(value);
+                            writeLocalLoggingPref(value);
+                          }
+
+                          toast.message(v ? "Saving preference enabled" : "Saving preference disabled");
+                        } catch {
+                          setLoggingEnabled((prev) => {
+                            const revert = !v;
+                            writeLocalLoggingPref(revert);
+                            return revert;
+                          });
+                          toast.message("Could not update preference. Please try again.");
+                        }
+                      })();
                     }}
                     aria-label="Enable saving screening history"
                   />

exec
/bin/zsh -lc '/Users/chiko/side_projects/usdt_blacklisted_web/ralph log "Added route-level tests for /api/user-settings auth + default + update behavior"' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 73ms:

file update:
diff --git a/middleware.ts b/middleware.ts
index 9009ef94a93548a37928fbb79db4d17573dde8b0..6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c
--- a/middleware.ts
+++ b/middleware.ts
@@ -7,6 +7,7 @@
   "/",
   "/api/check",
   "/api/analyze",
+  "/api/user-settings",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-user-settings.test.ts b/src/__tests__/api-user-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..206dc68b6524190c6007f00b602147edc7b72713
--- /dev/null
+++ b/src/__tests__/api-user-settings.test.ts
@@ -0,0 +1,82 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+const upsertUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings, upsertUserSettings }));
+
+async function callGet() {
+  const { GET } = await import("@/app/api/user-settings/route");
+  const res = await GET();
+  const json = await res.json();
+  return { res, json };
+}
+
+async function callPatch(body: unknown) {
+  const { PATCH } = await import("@/app/api/user-settings/route");
+  const req = new Request("http://localhost/api/user-settings", {
+    method: "PATCH",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await PATCH(req);
+  const json = await res.json();
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+});
+
+describe("/api/user-settings", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callGet();
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("returns loggingEnabled=false when no row exists (default)", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue(null);
+
+    const { res, json } = await callGet();
+    expect(res.status).toBe(200);
+    expect(json.loggingEnabled).toBe(false);
+    expect(json.persistenceAvailable).toBe(true);
+    expect(upsertUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("rejects unauthenticated updates with 401 and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPatch({ loggingEnabled: true });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(upsertUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("persists loggingEnabled via PATCH and returns the updated setting", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    upsertUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const { res, json } = await callPatch({ loggingEnabled: true });
+    expect(res.status).toBe(200);
+    expect(json.loggingEnabled).toBe(true);
+    expect(json.persistenceAvailable).toBe(true);
+    expect(upsertUserSettings).toHaveBeenCalledWith({}, "user_123", true);
+  });
+});
+
diff --git a/src/app/api/user-settings/route.ts b/src/app/api/user-settings/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..370e41418b9539b44e9aaad5fc5f9405b260485b
--- /dev/null
+++ b/src/app/api/user-settings/route.ts
@@ -0,0 +1,77 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { getUserSettings, upsertUserSettings } from "@/lib/db/user-settings";
+
+export const runtime = "nodejs";
+
+const UpdateUserSettingsSchema = z.object({
+  loggingEnabled: z.boolean(),
+});
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function GET() {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { loggingEnabled: false, persistenceAvailable: false },
+      { status: 200, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const settings = await getUserSettings(db, userId);
+  return NextResponse.json(
+    { loggingEnabled: settings?.loggingEnabled ?? false, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
+export async function PATCH(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { error: "Persistence is disabled." },
+      { status: 503, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = UpdateUserSettingsSchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const updated = await upsertUserSettings(db, userId, parsed.data.loggingEnabled);
+  return NextResponse.json(
+    { loggingEnabled: updated?.loggingEnabled ?? parsed.data.loggingEnabled, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 9db92fbfddf12094c87fc753d64f71213afd6e34..cc55ea86919cb717b261115eba22baacd1db415c
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -533,11 +533,13 @@
 export function BlacklistChecker() {
   const m = getMessages("en");
   const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
+  const { isLoaded: authLoaded, isSignedIn } = useAuth();
 
   const [address, setAddress] = React.useState("");
   const [validation, setValidation] = React.useState<ReturnType<typeof validateTronAddress> | null>(null);
   const [load, setLoad] = React.useState<LoadState>({ state: "idle" });
   const [loggingEnabled, setLoggingEnabled] = React.useState(false);
+  const fetchedServerLoggingPref = React.useRef(false);
 
   React.useEffect(() => {
     const handle = window.setTimeout(() => {
@@ -551,6 +553,35 @@
     setLoggingEnabled(readLocalLoggingPref());
   }, []);
 
+  React.useEffect(() => {
+    if (!clerkEnabled) return;
+    if (!authLoaded) return;
+    if (!isSignedIn) {
+      fetchedServerLoggingPref.current = false;
+      return;
+    }
+    if (fetchedServerLoggingPref.current) return;
+    fetchedServerLoggingPref.current = true;
+
+    const controller = new AbortController();
+    void (async () => {
+      try {
+        const res = await fetch("/api/user-settings", { method: "GET", credentials: "include", signal: controller.signal });
+        if (!res.ok) return;
+        const json = (await res.json()) as unknown;
+        if (!json || typeof json !== "object") return;
+        const v = (json as Record<string, unknown>).loggingEnabled;
+        if (typeof v !== "boolean") return;
+        setLoggingEnabled(v);
+        writeLocalLoggingPref(v);
+      } catch {
+        // ignore
+      }
+    })();
+
+    return () => controller.abort();
+  }, [clerkEnabled, authLoaded, isSignedIn]);
+
   const normalizedAddress = validation?.normalized ?? address.trim();
   const isValid = validation?.ok ?? false;
 
@@ -881,18 +912,18 @@
               transition={{ duration: 0.4, delay: 0.18 }}
               className="mx-auto mt-4 max-w-2xl"
             >
-              <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+                  <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
                 <CardHeader className="pb-3">
                   <CardTitle className="text-base">Account</CardTitle>
                   <CardDescription>
-                    Configure privacy defaults. Saving reports is not enabled yet (DB/credits work is next).
+                    Configure privacy defaults. Report saving is opt-in and controlled by this setting.
                   </CardDescription>
                 </CardHeader>
                 <CardContent className="flex items-start justify-between gap-4">
                   <div className="min-w-0">
                     <div className="text-sm font-medium text-foreground">Opt-in: save screening history</div>
                     <div className="mt-1 text-sm text-muted-foreground">
-                      This currently stores only a local preference. No server-side address logging is performed yet.
+                      This setting is saved to your account. Screening history persistence remains opt-in.
                     </div>
                   </div>
                   <Switch
@@ -900,7 +931,35 @@
                     onCheckedChange={(v) => {
                       setLoggingEnabled(v);
                       writeLocalLoggingPref(v);
-                      toast.message(v ? "Logging preference enabled (local only)" : "Logging preference disabled");
+
+                      void (async () => {
+                        try {
+                          const res = await fetch("/api/user-settings", {
+                            method: "PATCH",
+                            headers: { "content-type": "application/json" },
+                            credentials: "include",
+                            body: JSON.stringify({ loggingEnabled: v }),
+                          });
+
+                          if (!res.ok) throw new Error(`Request failed (${res.status}).`);
+                          const json = (await res.json()) as unknown;
+                          const value =
+                            json && typeof json === "object" ? (json as Record<string, unknown>).loggingEnabled : undefined;
+                          if (typeof value === "boolean") {
+                            setLoggingEnabled(value);
+                            writeLocalLoggingPref(value);
+                          }
+
+                          toast.message(v ? "Saving preference enabled" : "Saving preference disabled");
+                        } catch {
+                          setLoggingEnabled((prev) => {
+                            const revert = !v;
+                            writeLocalLoggingPref(revert);
+                            return revert;
+                          });
+                          toast.message("Could not update preference. Please try again.");
+                        }
+                      })();
                     }}
                     aria-label="Enable saving screening history"
                   />


thinking
**Addressing missing keys**

I need to handle the scenario when Clerk keys are missing because the route currently returns a 401 error when getAuthenticatedUserId is null, and our tests don’t cover this situation. It seems like callGet uses GET() without passing Request, but since the route's GET signature expects no args, it's fine since we defined `export async function GET()`. In Next.js, GET can accept Request without any issues. I’ll check if step 4 tests are complete and plan to run pnpm tests soon to keep everything on track.
Plan update
  ✓ Review guardrails and prior errors
  ✓ Audit existing auth, DB, API patterns
  ✓ Implement settings GET/PUT routes
  ✓ Add unit/route tests
  → Run lint, test, build
  • Security/perf/regression review, commit, logs
file update:
diff --git a/middleware.ts b/middleware.ts
index 9009ef94a93548a37928fbb79db4d17573dde8b0..6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c
--- a/middleware.ts
+++ b/middleware.ts
@@ -7,6 +7,7 @@
   "/",
   "/api/check",
   "/api/analyze",
+  "/api/user-settings",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-user-settings.test.ts b/src/__tests__/api-user-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..206dc68b6524190c6007f00b602147edc7b72713
--- /dev/null
+++ b/src/__tests__/api-user-settings.test.ts
@@ -0,0 +1,82 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+const upsertUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings, upsertUserSettings }));
+
+async function callGet() {
+  const { GET } = await import("@/app/api/user-settings/route");
+  const res = await GET();
+  const json = await res.json();
+  return { res, json };
+}
+
+async function callPatch(body: unknown) {
+  const { PATCH } = await import("@/app/api/user-settings/route");
+  const req = new Request("http://localhost/api/user-settings", {
+    method: "PATCH",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await PATCH(req);
+  const json = await res.json();
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+});
+
+describe("/api/user-settings", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callGet();
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("returns loggingEnabled=false when no row exists (default)", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue(null);
+
+    const { res, json } = await callGet();
+    expect(res.status).toBe(200);
+    expect(json.loggingEnabled).toBe(false);
+    expect(json.persistenceAvailable).toBe(true);
+    expect(upsertUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("rejects unauthenticated updates with 401 and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPatch({ loggingEnabled: true });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(upsertUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("persists loggingEnabled via PATCH and returns the updated setting", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    upsertUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const { res, json } = await callPatch({ loggingEnabled: true });
+    expect(res.status).toBe(200);
+    expect(json.loggingEnabled).toBe(true);
+    expect(json.persistenceAvailable).toBe(true);
+    expect(upsertUserSettings).toHaveBeenCalledWith({}, "user_123", true);
+  });
+});
+
diff --git a/src/app/api/user-settings/route.ts b/src/app/api/user-settings/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..370e41418b9539b44e9aaad5fc5f9405b260485b
--- /dev/null
+++ b/src/app/api/user-settings/route.ts
@@ -0,0 +1,77 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { getUserSettings, upsertUserSettings } from "@/lib/db/user-settings";
+
+export const runtime = "nodejs";
+
+const UpdateUserSettingsSchema = z.object({
+  loggingEnabled: z.boolean(),
+});
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function GET() {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { loggingEnabled: false, persistenceAvailable: false },
+      { status: 200, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const settings = await getUserSettings(db, userId);
+  return NextResponse.json(
+    { loggingEnabled: settings?.loggingEnabled ?? false, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
+export async function PATCH(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { error: "Persistence is disabled." },
+      { status: 503, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = UpdateUserSettingsSchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const updated = await upsertUserSettings(db, userId, parsed.data.loggingEnabled);
+  return NextResponse.json(
+    { loggingEnabled: updated?.loggingEnabled ?? parsed.data.loggingEnabled, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 9db92fbfddf12094c87fc753d64f71213afd6e34..cc55ea86919cb717b261115eba22baacd1db415c
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -533,11 +533,13 @@
 export function BlacklistChecker() {
   const m = getMessages("en");
   const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
+  const { isLoaded: authLoaded, isSignedIn } = useAuth();
 
   const [address, setAddress] = React.useState("");
   const [validation, setValidation] = React.useState<ReturnType<typeof validateTronAddress> | null>(null);
   const [load, setLoad] = React.useState<LoadState>({ state: "idle" });
   const [loggingEnabled, setLoggingEnabled] = React.useState(false);
+  const fetchedServerLoggingPref = React.useRef(false);
 
   React.useEffect(() => {
     const handle = window.setTimeout(() => {
@@ -551,6 +553,35 @@
     setLoggingEnabled(readLocalLoggingPref());
   }, []);
 
+  React.useEffect(() => {
+    if (!clerkEnabled) return;
+    if (!authLoaded) return;
+    if (!isSignedIn) {
+      fetchedServerLoggingPref.current = false;
+      return;
+    }
+    if (fetchedServerLoggingPref.current) return;
+    fetchedServerLoggingPref.current = true;
+
+    const controller = new AbortController();
+    void (async () => {
+      try {
+        const res = await fetch("/api/user-settings", { method: "GET", credentials: "include", signal: controller.signal });
+        if (!res.ok) return;
+        const json = (await res.json()) as unknown;
+        if (!json || typeof json !== "object") return;
+        const v = (json as Record<string, unknown>).loggingEnabled;
+        if (typeof v !== "boolean") return;
+        setLoggingEnabled(v);
+        writeLocalLoggingPref(v);
+      } catch {
+        // ignore
+      }
+    })();
+
+    return () => controller.abort();
+  }, [clerkEnabled, authLoaded, isSignedIn]);
+
   const normalizedAddress = validation?.normalized ?? address.trim();
   const isValid = validation?.ok ?? false;
 
@@ -881,18 +912,18 @@
               transition={{ duration: 0.4, delay: 0.18 }}
               className="mx-auto mt-4 max-w-2xl"
             >
-              <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+                  <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
                 <CardHeader className="pb-3">
                   <CardTitle className="text-base">Account</CardTitle>
                   <CardDescription>
-                    Configure privacy defaults. Saving reports is not enabled yet (DB/credits work is next).
+                    Configure privacy defaults. Report saving is opt-in and controlled by this setting.
                   </CardDescription>
                 </CardHeader>
                 <CardContent className="flex items-start justify-between gap-4">
                   <div className="min-w-0">
                     <div className="text-sm font-medium text-foreground">Opt-in: save screening history</div>
                     <div className="mt-1 text-sm text-muted-foreground">
-                      This currently stores only a local preference. No server-side address logging is performed yet.
+                      This setting is saved to your account. Screening history persistence remains opt-in.
                     </div>
                   </div>
                   <Switch
@@ -900,7 +931,35 @@
                     onCheckedChange={(v) => {
                       setLoggingEnabled(v);
                       writeLocalLoggingPref(v);
-                      toast.message(v ? "Logging preference enabled (local only)" : "Logging preference disabled");
+
+                      void (async () => {
+                        try {
+                          const res = await fetch("/api/user-settings", {
+                            method: "PATCH",
+                            headers: { "content-type": "application/json" },
+                            credentials: "include",
+                            body: JSON.stringify({ loggingEnabled: v }),
+                          });
+
+                          if (!res.ok) throw new Error(`Request failed (${res.status}).`);
+                          const json = (await res.json()) as unknown;
+                          const value =
+                            json && typeof json === "object" ? (json as Record<string, unknown>).loggingEnabled : undefined;
+                          if (typeof value === "boolean") {
+                            setLoggingEnabled(value);
+                            writeLocalLoggingPref(value);
+                          }
+
+                          toast.message(v ? "Saving preference enabled" : "Saving preference disabled");
+                        } catch {
+                          setLoggingEnabled((prev) => {
+                            const revert = !v;
+                            writeLocalLoggingPref(revert);
+                            return revert;
+                          });
+                          toast.message("Could not update preference. Please try again.");
+                        }
+                      })();
                     }}
                     aria-label="Enable saving screening history"
                   />


thinking
**Running verification commands**

I'm looking to run verification commands like `pnpm lint`, `test`, and `build`. Given that the approval policy is set to "never," I can proceed with this. I’ll also include `pnpm test` and similar commands, but it might take a bit of time. After the tests, I'll log the major actions to keep track of everything. I'll run these commands sequentially using shell_command to monitor the process easily.
exec
/bin/zsh -lc '/Users/chiko/side_projects/usdt_blacklisted_web/ralph log "Running quality gates: pnpm lint, pnpm test, pnpm build"' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 71ms:

file update:
diff --git a/middleware.ts b/middleware.ts
index 9009ef94a93548a37928fbb79db4d17573dde8b0..6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c
--- a/middleware.ts
+++ b/middleware.ts
@@ -7,6 +7,7 @@
   "/",
   "/api/check",
   "/api/analyze",
+  "/api/user-settings",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-user-settings.test.ts b/src/__tests__/api-user-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..206dc68b6524190c6007f00b602147edc7b72713
--- /dev/null
+++ b/src/__tests__/api-user-settings.test.ts
@@ -0,0 +1,82 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+const upsertUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings, upsertUserSettings }));
+
+async function callGet() {
+  const { GET } = await import("@/app/api/user-settings/route");
+  const res = await GET();
+  const json = await res.json();
+  return { res, json };
+}
+
+async function callPatch(body: unknown) {
+  const { PATCH } = await import("@/app/api/user-settings/route");
+  const req = new Request("http://localhost/api/user-settings", {
+    method: "PATCH",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await PATCH(req);
+  const json = await res.json();
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+});
+
+describe("/api/user-settings", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callGet();
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("returns loggingEnabled=false when no row exists (default)", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue(null);
+
+    const { res, json } = await callGet();
+    expect(res.status).toBe(200);
+    expect(json.loggingEnabled).toBe(false);
+    expect(json.persistenceAvailable).toBe(true);
+    expect(upsertUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("rejects unauthenticated updates with 401 and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPatch({ loggingEnabled: true });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(upsertUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("persists loggingEnabled via PATCH and returns the updated setting", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    upsertUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const { res, json } = await callPatch({ loggingEnabled: true });
+    expect(res.status).toBe(200);
+    expect(json.loggingEnabled).toBe(true);
+    expect(json.persistenceAvailable).toBe(true);
+    expect(upsertUserSettings).toHaveBeenCalledWith({}, "user_123", true);
+  });
+});
+
diff --git a/src/app/api/user-settings/route.ts b/src/app/api/user-settings/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..370e41418b9539b44e9aaad5fc5f9405b260485b
--- /dev/null
+++ b/src/app/api/user-settings/route.ts
@@ -0,0 +1,77 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { getUserSettings, upsertUserSettings } from "@/lib/db/user-settings";
+
+export const runtime = "nodejs";
+
+const UpdateUserSettingsSchema = z.object({
+  loggingEnabled: z.boolean(),
+});
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function GET() {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { loggingEnabled: false, persistenceAvailable: false },
+      { status: 200, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const settings = await getUserSettings(db, userId);
+  return NextResponse.json(
+    { loggingEnabled: settings?.loggingEnabled ?? false, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
+export async function PATCH(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { error: "Persistence is disabled." },
+      { status: 503, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = UpdateUserSettingsSchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const updated = await upsertUserSettings(db, userId, parsed.data.loggingEnabled);
+  return NextResponse.json(
+    { loggingEnabled: updated?.loggingEnabled ?? parsed.data.loggingEnabled, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 9db92fbfddf12094c87fc753d64f71213afd6e34..cc55ea86919cb717b261115eba22baacd1db415c
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -533,11 +533,13 @@
 export function BlacklistChecker() {
   const m = getMessages("en");
   const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
+  const { isLoaded: authLoaded, isSignedIn } = useAuth();
 
   const [address, setAddress] = React.useState("");
   const [validation, setValidation] = React.useState<ReturnType<typeof validateTronAddress> | null>(null);
   const [load, setLoad] = React.useState<LoadState>({ state: "idle" });
   const [loggingEnabled, setLoggingEnabled] = React.useState(false);
+  const fetchedServerLoggingPref = React.useRef(false);
 
   React.useEffect(() => {
     const handle = window.setTimeout(() => {
@@ -551,6 +553,35 @@
     setLoggingEnabled(readLocalLoggingPref());
   }, []);
 
+  React.useEffect(() => {
+    if (!clerkEnabled) return;
+    if (!authLoaded) return;
+    if (!isSignedIn) {
+      fetchedServerLoggingPref.current = false;
+      return;
+    }
+    if (fetchedServerLoggingPref.current) return;
+    fetchedServerLoggingPref.current = true;
+
+    const controller = new AbortController();
+    void (async () => {
+      try {
+        const res = await fetch("/api/user-settings", { method: "GET", credentials: "include", signal: controller.signal });
+        if (!res.ok) return;
+        const json = (await res.json()) as unknown;
+        if (!json || typeof json !== "object") return;
+        const v = (json as Record<string, unknown>).loggingEnabled;
+        if (typeof v !== "boolean") return;
+        setLoggingEnabled(v);
+        writeLocalLoggingPref(v);
+      } catch {
+        // ignore
+      }
+    })();
+
+    return () => controller.abort();
+  }, [clerkEnabled, authLoaded, isSignedIn]);
+
   const normalizedAddress = validation?.normalized ?? address.trim();
   const isValid = validation?.ok ?? false;
 
@@ -881,18 +912,18 @@
               transition={{ duration: 0.4, delay: 0.18 }}
               className="mx-auto mt-4 max-w-2xl"
             >
-              <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+                  <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
                 <CardHeader className="pb-3">
                   <CardTitle className="text-base">Account</CardTitle>
                   <CardDescription>
-                    Configure privacy defaults. Saving reports is not enabled yet (DB/credits work is next).
+                    Configure privacy defaults. Report saving is opt-in and controlled by this setting.
                   </CardDescription>
                 </CardHeader>
                 <CardContent className="flex items-start justify-between gap-4">
                   <div className="min-w-0">
                     <div className="text-sm font-medium text-foreground">Opt-in: save screening history</div>
                     <div className="mt-1 text-sm text-muted-foreground">
-                      This currently stores only a local preference. No server-side address logging is performed yet.
+                      This setting is saved to your account. Screening history persistence remains opt-in.
                     </div>
                   </div>
                   <Switch
@@ -900,7 +931,35 @@
                     onCheckedChange={(v) => {
                       setLoggingEnabled(v);
                       writeLocalLoggingPref(v);
-                      toast.message(v ? "Logging preference enabled (local only)" : "Logging preference disabled");
+
+                      void (async () => {
+                        try {
+                          const res = await fetch("/api/user-settings", {
+                            method: "PATCH",
+                            headers: { "content-type": "application/json" },
+                            credentials: "include",
+                            body: JSON.stringify({ loggingEnabled: v }),
+                          });
+
+                          if (!res.ok) throw new Error(`Request failed (${res.status}).`);
+                          const json = (await res.json()) as unknown;
+                          const value =
+                            json && typeof json === "object" ? (json as Record<string, unknown>).loggingEnabled : undefined;
+                          if (typeof value === "boolean") {
+                            setLoggingEnabled(value);
+                            writeLocalLoggingPref(value);
+                          }
+
+                          toast.message(v ? "Saving preference enabled" : "Saving preference disabled");
+                        } catch {
+                          setLoggingEnabled((prev) => {
+                            const revert = !v;
+                            writeLocalLoggingPref(revert);
+                            return revert;
+                          });
+                          toast.message("Could not update preference. Please try again.");
+                        }
+                      })();
                     }}
                     aria-label="Enable saving screening history"
                   />

exec
/bin/zsh -lc 'pnpm lint' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 2.49s:

> usdt_blacklisted_web@0.1.0 lint /Users/chiko/side_projects/usdt_blacklisted_web
> eslint


/Users/chiko/side_projects/usdt_blacklisted_web/src/components/blacklist-checker.tsx
  955:46  warning  'prev' is defined but never used  @typescript-eslint/no-unused-vars

✖ 1 problem (0 errors, 1 warning)

file update:
diff --git a/middleware.ts b/middleware.ts
index 9009ef94a93548a37928fbb79db4d17573dde8b0..6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c
--- a/middleware.ts
+++ b/middleware.ts
@@ -7,6 +7,7 @@
   "/",
   "/api/check",
   "/api/analyze",
+  "/api/user-settings",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-user-settings.test.ts b/src/__tests__/api-user-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..206dc68b6524190c6007f00b602147edc7b72713
--- /dev/null
+++ b/src/__tests__/api-user-settings.test.ts
@@ -0,0 +1,82 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+const upsertUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings, upsertUserSettings }));
+
+async function callGet() {
+  const { GET } = await import("@/app/api/user-settings/route");
+  const res = await GET();
+  const json = await res.json();
+  return { res, json };
+}
+
+async function callPatch(body: unknown) {
+  const { PATCH } = await import("@/app/api/user-settings/route");
+  const req = new Request("http://localhost/api/user-settings", {
+    method: "PATCH",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await PATCH(req);
+  const json = await res.json();
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+});
+
+describe("/api/user-settings", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callGet();
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("returns loggingEnabled=false when no row exists (default)", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue(null);
+
+    const { res, json } = await callGet();
+    expect(res.status).toBe(200);
+    expect(json.loggingEnabled).toBe(false);
+    expect(json.persistenceAvailable).toBe(true);
+    expect(upsertUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("rejects unauthenticated updates with 401 and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPatch({ loggingEnabled: true });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(upsertUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("persists loggingEnabled via PATCH and returns the updated setting", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    upsertUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const { res, json } = await callPatch({ loggingEnabled: true });
+    expect(res.status).toBe(200);
+    expect(json.loggingEnabled).toBe(true);
+    expect(json.persistenceAvailable).toBe(true);
+    expect(upsertUserSettings).toHaveBeenCalledWith({}, "user_123", true);
+  });
+});
+
diff --git a/src/app/api/user-settings/route.ts b/src/app/api/user-settings/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..370e41418b9539b44e9aaad5fc5f9405b260485b
--- /dev/null
+++ b/src/app/api/user-settings/route.ts
@@ -0,0 +1,77 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { getUserSettings, upsertUserSettings } from "@/lib/db/user-settings";
+
+export const runtime = "nodejs";
+
+const UpdateUserSettingsSchema = z.object({
+  loggingEnabled: z.boolean(),
+});
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function GET() {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { loggingEnabled: false, persistenceAvailable: false },
+      { status: 200, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const settings = await getUserSettings(db, userId);
+  return NextResponse.json(
+    { loggingEnabled: settings?.loggingEnabled ?? false, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
+export async function PATCH(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { error: "Persistence is disabled." },
+      { status: 503, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = UpdateUserSettingsSchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const updated = await upsertUserSettings(db, userId, parsed.data.loggingEnabled);
+  return NextResponse.json(
+    { loggingEnabled: updated?.loggingEnabled ?? parsed.data.loggingEnabled, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 9db92fbfddf12094c87fc753d64f71213afd6e34..cc55ea86919cb717b261115eba22baacd1db415c
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -533,11 +533,13 @@
 export function BlacklistChecker() {
   const m = getMessages("en");
   const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
+  const { isLoaded: authLoaded, isSignedIn } = useAuth();
 
   const [address, setAddress] = React.useState("");
   const [validation, setValidation] = React.useState<ReturnType<typeof validateTronAddress> | null>(null);
   const [load, setLoad] = React.useState<LoadState>({ state: "idle" });
   const [loggingEnabled, setLoggingEnabled] = React.useState(false);
+  const fetchedServerLoggingPref = React.useRef(false);
 
   React.useEffect(() => {
     const handle = window.setTimeout(() => {
@@ -551,6 +553,35 @@
     setLoggingEnabled(readLocalLoggingPref());
   }, []);
 
+  React.useEffect(() => {
+    if (!clerkEnabled) return;
+    if (!authLoaded) return;
+    if (!isSignedIn) {
+      fetchedServerLoggingPref.current = false;
+      return;
+    }
+    if (fetchedServerLoggingPref.current) return;
+    fetchedServerLoggingPref.current = true;
+
+    const controller = new AbortController();
+    void (async () => {
+      try {
+        const res = await fetch("/api/user-settings", { method: "GET", credentials: "include", signal: controller.signal });
+        if (!res.ok) return;
+        const json = (await res.json()) as unknown;
+        if (!json || typeof json !== "object") return;
+        const v = (json as Record<string, unknown>).loggingEnabled;
+        if (typeof v !== "boolean") return;
+        setLoggingEnabled(v);
+        writeLocalLoggingPref(v);
+      } catch {
+        // ignore
+      }
+    })();
+
+    return () => controller.abort();
+  }, [clerkEnabled, authLoaded, isSignedIn]);
+
   const normalizedAddress = validation?.normalized ?? address.trim();
   const isValid = validation?.ok ?? false;
 
@@ -881,18 +912,18 @@
               transition={{ duration: 0.4, delay: 0.18 }}
               className="mx-auto mt-4 max-w-2xl"
             >
-              <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+                  <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
                 <CardHeader className="pb-3">
                   <CardTitle className="text-base">Account</CardTitle>
                   <CardDescription>
-                    Configure privacy defaults. Saving reports is not enabled yet (DB/credits work is next).
+                    Configure privacy defaults. Report saving is opt-in and controlled by this setting.
                   </CardDescription>
                 </CardHeader>
                 <CardContent className="flex items-start justify-between gap-4">
                   <div className="min-w-0">
                     <div className="text-sm font-medium text-foreground">Opt-in: save screening history</div>
                     <div className="mt-1 text-sm text-muted-foreground">
-                      This currently stores only a local preference. No server-side address logging is performed yet.
+                      This setting is saved to your account. Screening history persistence remains opt-in.
                     </div>
                   </div>
                   <Switch
@@ -900,7 +931,35 @@
                     onCheckedChange={(v) => {
                       setLoggingEnabled(v);
                       writeLocalLoggingPref(v);
-                      toast.message(v ? "Logging preference enabled (local only)" : "Logging preference disabled");
+
+                      void (async () => {
+                        try {
+                          const res = await fetch("/api/user-settings", {
+                            method: "PATCH",
+                            headers: { "content-type": "application/json" },
+                            credentials: "include",
+                            body: JSON.stringify({ loggingEnabled: v }),
+                          });
+
+                          if (!res.ok) throw new Error(`Request failed (${res.status}).`);
+                          const json = (await res.json()) as unknown;
+                          const value =
+                            json && typeof json === "object" ? (json as Record<string, unknown>).loggingEnabled : undefined;
+                          if (typeof value === "boolean") {
+                            setLoggingEnabled(value);
+                            writeLocalLoggingPref(value);
+                          }
+
+                          toast.message(v ? "Saving preference enabled" : "Saving preference disabled");
+                        } catch {
+                          setLoggingEnabled((prev) => {
+                            const revert = !v;
+                            writeLocalLoggingPref(revert);
+                            return revert;
+                          });
+                          toast.message("Could not update preference. Please try again.");
+                        }
+                      })();
                     }}
                     aria-label="Enable saving screening history"
                   />


thinking
**Refining code for logging**

I'm looking at a lint warning that's not ideal. I should remove the unused `prev` parameter in the `setLoggingEnabled` callback. Instead, I can directly revert the value outside of `setState`. 

To ensure it works correctly, I can set it up like this: 

```
setLoggingEnabled(!v);
writeLocalLoggingPref(!v);
```

Also, I need to structure error handling with a `catch` for any async functions. Let's clean this up and apply the patch.
file update
M /Users/chiko/side_projects/usdt_blacklisted_web/src/components/blacklist-checker.tsx
@@ -954,7 +954,5 @@
                         } catch {
-                          setLoggingEnabled((prev) => {
-                            const revert = !v;
-                            writeLocalLoggingPref(revert);
-                            return revert;
-                          });
+                          const revert = !v;
+                          setLoggingEnabled(revert);
+                          writeLocalLoggingPref(revert);
                           toast.message("Could not update preference. Please try again.");
apply_patch(auto_approved=true) exited 0 in 76ms:
Success. Updated the following files:
M src/components/blacklist-checker.tsx
file update:
diff --git a/middleware.ts b/middleware.ts
index 9009ef94a93548a37928fbb79db4d17573dde8b0..6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c
--- a/middleware.ts
+++ b/middleware.ts
@@ -7,6 +7,7 @@
   "/",
   "/api/check",
   "/api/analyze",
+  "/api/user-settings",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-user-settings.test.ts b/src/__tests__/api-user-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..206dc68b6524190c6007f00b602147edc7b72713
--- /dev/null
+++ b/src/__tests__/api-user-settings.test.ts
@@ -0,0 +1,82 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+const upsertUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings, upsertUserSettings }));
+
+async function callGet() {
+  const { GET } = await import("@/app/api/user-settings/route");
+  const res = await GET();
+  const json = await res.json();
+  return { res, json };
+}
+
+async function callPatch(body: unknown) {
+  const { PATCH } = await import("@/app/api/user-settings/route");
+  const req = new Request("http://localhost/api/user-settings", {
+    method: "PATCH",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await PATCH(req);
+  const json = await res.json();
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+});
+
+describe("/api/user-settings", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callGet();
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("returns loggingEnabled=false when no row exists (default)", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue(null);
+
+    const { res, json } = await callGet();
+    expect(res.status).toBe(200);
+    expect(json.loggingEnabled).toBe(false);
+    expect(json.persistenceAvailable).toBe(true);
+    expect(upsertUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("rejects unauthenticated updates with 401 and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPatch({ loggingEnabled: true });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(upsertUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("persists loggingEnabled via PATCH and returns the updated setting", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    upsertUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const { res, json } = await callPatch({ loggingEnabled: true });
+    expect(res.status).toBe(200);
+    expect(json.loggingEnabled).toBe(true);
+    expect(json.persistenceAvailable).toBe(true);
+    expect(upsertUserSettings).toHaveBeenCalledWith({}, "user_123", true);
+  });
+});
+
diff --git a/src/app/api/user-settings/route.ts b/src/app/api/user-settings/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..370e41418b9539b44e9aaad5fc5f9405b260485b
--- /dev/null
+++ b/src/app/api/user-settings/route.ts
@@ -0,0 +1,77 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { getUserSettings, upsertUserSettings } from "@/lib/db/user-settings";
+
+export const runtime = "nodejs";
+
+const UpdateUserSettingsSchema = z.object({
+  loggingEnabled: z.boolean(),
+});
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function GET() {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { loggingEnabled: false, persistenceAvailable: false },
+      { status: 200, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const settings = await getUserSettings(db, userId);
+  return NextResponse.json(
+    { loggingEnabled: settings?.loggingEnabled ?? false, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
+export async function PATCH(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { error: "Persistence is disabled." },
+      { status: 503, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = UpdateUserSettingsSchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const updated = await upsertUserSettings(db, userId, parsed.data.loggingEnabled);
+  return NextResponse.json(
+    { loggingEnabled: updated?.loggingEnabled ?? parsed.data.loggingEnabled, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 9db92fbfddf12094c87fc753d64f71213afd6e34..c15ee53a0f7867aac39de17be6efd381c554ce0b
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -533,11 +533,13 @@
 export function BlacklistChecker() {
   const m = getMessages("en");
   const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
+  const { isLoaded: authLoaded, isSignedIn } = useAuth();
 
   const [address, setAddress] = React.useState("");
   const [validation, setValidation] = React.useState<ReturnType<typeof validateTronAddress> | null>(null);
   const [load, setLoad] = React.useState<LoadState>({ state: "idle" });
   const [loggingEnabled, setLoggingEnabled] = React.useState(false);
+  const fetchedServerLoggingPref = React.useRef(false);
 
   React.useEffect(() => {
     const handle = window.setTimeout(() => {
@@ -551,6 +553,35 @@
     setLoggingEnabled(readLocalLoggingPref());
   }, []);
 
+  React.useEffect(() => {
+    if (!clerkEnabled) return;
+    if (!authLoaded) return;
+    if (!isSignedIn) {
+      fetchedServerLoggingPref.current = false;
+      return;
+    }
+    if (fetchedServerLoggingPref.current) return;
+    fetchedServerLoggingPref.current = true;
+
+    const controller = new AbortController();
+    void (async () => {
+      try {
+        const res = await fetch("/api/user-settings", { method: "GET", credentials: "include", signal: controller.signal });
+        if (!res.ok) return;
+        const json = (await res.json()) as unknown;
+        if (!json || typeof json !== "object") return;
+        const v = (json as Record<string, unknown>).loggingEnabled;
+        if (typeof v !== "boolean") return;
+        setLoggingEnabled(v);
+        writeLocalLoggingPref(v);
+      } catch {
+        // ignore
+      }
+    })();
+
+    return () => controller.abort();
+  }, [clerkEnabled, authLoaded, isSignedIn]);
+
   const normalizedAddress = validation?.normalized ?? address.trim();
   const isValid = validation?.ok ?? false;
 
@@ -881,18 +912,18 @@
               transition={{ duration: 0.4, delay: 0.18 }}
               className="mx-auto mt-4 max-w-2xl"
             >
-              <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+                  <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
                 <CardHeader className="pb-3">
                   <CardTitle className="text-base">Account</CardTitle>
                   <CardDescription>
-                    Configure privacy defaults. Saving reports is not enabled yet (DB/credits work is next).
+                    Configure privacy defaults. Report saving is opt-in and controlled by this setting.
                   </CardDescription>
                 </CardHeader>
                 <CardContent className="flex items-start justify-between gap-4">
                   <div className="min-w-0">
                     <div className="text-sm font-medium text-foreground">Opt-in: save screening history</div>
                     <div className="mt-1 text-sm text-muted-foreground">
-                      This currently stores only a local preference. No server-side address logging is performed yet.
+                      This setting is saved to your account. Screening history persistence remains opt-in.
                     </div>
                   </div>
                   <Switch
@@ -900,7 +931,33 @@
                     onCheckedChange={(v) => {
                       setLoggingEnabled(v);
                       writeLocalLoggingPref(v);
-                      toast.message(v ? "Logging preference enabled (local only)" : "Logging preference disabled");
+
+                      void (async () => {
+                        try {
+                          const res = await fetch("/api/user-settings", {
+                            method: "PATCH",
+                            headers: { "content-type": "application/json" },
+                            credentials: "include",
+                            body: JSON.stringify({ loggingEnabled: v }),
+                          });
+
+                          if (!res.ok) throw new Error(`Request failed (${res.status}).`);
+                          const json = (await res.json()) as unknown;
+                          const value =
+                            json && typeof json === "object" ? (json as Record<string, unknown>).loggingEnabled : undefined;
+                          if (typeof value === "boolean") {
+                            setLoggingEnabled(value);
+                            writeLocalLoggingPref(value);
+                          }
+
+                          toast.message(v ? "Saving preference enabled" : "Saving preference disabled");
+                        } catch {
+                          const revert = !v;
+                          setLoggingEnabled(revert);
+                          writeLocalLoggingPref(revert);
+                          toast.message("Could not update preference. Please try again.");
+                        }
+                      })();
                     }}
                     aria-label="Enable saving screening history"
                   />

file update:
diff --git a/middleware.ts b/middleware.ts
index 9009ef94a93548a37928fbb79db4d17573dde8b0..6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c
--- a/middleware.ts
+++ b/middleware.ts
@@ -7,6 +7,7 @@
   "/",
   "/api/check",
   "/api/analyze",
+  "/api/user-settings",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-user-settings.test.ts b/src/__tests__/api-user-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..206dc68b6524190c6007f00b602147edc7b72713
--- /dev/null
+++ b/src/__tests__/api-user-settings.test.ts
@@ -0,0 +1,82 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+const upsertUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings, upsertUserSettings }));
+
+async function callGet() {
+  const { GET } = await import("@/app/api/user-settings/route");
+  const res = await GET();
+  const json = await res.json();
+  return { res, json };
+}
+
+async function callPatch(body: unknown) {
+  const { PATCH } = await import("@/app/api/user-settings/route");
+  const req = new Request("http://localhost/api/user-settings", {
+    method: "PATCH",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await PATCH(req);
+  const json = await res.json();
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+});
+
+describe("/api/user-settings", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callGet();
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("returns loggingEnabled=false when no row exists (default)", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue(null);
+
+    const { res, json } = await callGet();
+    expect(res.status).toBe(200);
+    expect(json.loggingEnabled).toBe(false);
+    expect(json.persistenceAvailable).toBe(true);
+    expect(upsertUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("rejects unauthenticated updates with 401 and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPatch({ loggingEnabled: true });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(upsertUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("persists loggingEnabled via PATCH and returns the updated setting", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    upsertUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const { res, json } = await callPatch({ loggingEnabled: true });
+    expect(res.status).toBe(200);
+    expect(json.loggingEnabled).toBe(true);
+    expect(json.persistenceAvailable).toBe(true);
+    expect(upsertUserSettings).toHaveBeenCalledWith({}, "user_123", true);
+  });
+});
+
diff --git a/src/app/api/user-settings/route.ts b/src/app/api/user-settings/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..370e41418b9539b44e9aaad5fc5f9405b260485b
--- /dev/null
+++ b/src/app/api/user-settings/route.ts
@@ -0,0 +1,77 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { getUserSettings, upsertUserSettings } from "@/lib/db/user-settings";
+
+export const runtime = "nodejs";
+
+const UpdateUserSettingsSchema = z.object({
+  loggingEnabled: z.boolean(),
+});
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function GET() {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { loggingEnabled: false, persistenceAvailable: false },
+      { status: 200, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const settings = await getUserSettings(db, userId);
+  return NextResponse.json(
+    { loggingEnabled: settings?.loggingEnabled ?? false, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
+export async function PATCH(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { error: "Persistence is disabled." },
+      { status: 503, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = UpdateUserSettingsSchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const updated = await upsertUserSettings(db, userId, parsed.data.loggingEnabled);
+  return NextResponse.json(
+    { loggingEnabled: updated?.loggingEnabled ?? parsed.data.loggingEnabled, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 9db92fbfddf12094c87fc753d64f71213afd6e34..c15ee53a0f7867aac39de17be6efd381c554ce0b
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -533,11 +533,13 @@
 export function BlacklistChecker() {
   const m = getMessages("en");
   const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
+  const { isLoaded: authLoaded, isSignedIn } = useAuth();
 
   const [address, setAddress] = React.useState("");
   const [validation, setValidation] = React.useState<ReturnType<typeof validateTronAddress> | null>(null);
   const [load, setLoad] = React.useState<LoadState>({ state: "idle" });
   const [loggingEnabled, setLoggingEnabled] = React.useState(false);
+  const fetchedServerLoggingPref = React.useRef(false);
 
   React.useEffect(() => {
     const handle = window.setTimeout(() => {
@@ -551,6 +553,35 @@
     setLoggingEnabled(readLocalLoggingPref());
   }, []);
 
+  React.useEffect(() => {
+    if (!clerkEnabled) return;
+    if (!authLoaded) return;
+    if (!isSignedIn) {
+      fetchedServerLoggingPref.current = false;
+      return;
+    }
+    if (fetchedServerLoggingPref.current) return;
+    fetchedServerLoggingPref.current = true;
+
+    const controller = new AbortController();
+    void (async () => {
+      try {
+        const res = await fetch("/api/user-settings", { method: "GET", credentials: "include", signal: controller.signal });
+        if (!res.ok) return;
+        const json = (await res.json()) as unknown;
+        if (!json || typeof json !== "object") return;
+        const v = (json as Record<string, unknown>).loggingEnabled;
+        if (typeof v !== "boolean") return;
+        setLoggingEnabled(v);
+        writeLocalLoggingPref(v);
+      } catch {
+        // ignore
+      }
+    })();
+
+    return () => controller.abort();
+  }, [clerkEnabled, authLoaded, isSignedIn]);
+
   const normalizedAddress = validation?.normalized ?? address.trim();
   const isValid = validation?.ok ?? false;
 
@@ -881,18 +912,18 @@
               transition={{ duration: 0.4, delay: 0.18 }}
               className="mx-auto mt-4 max-w-2xl"
             >
-              <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+                  <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
                 <CardHeader className="pb-3">
                   <CardTitle className="text-base">Account</CardTitle>
                   <CardDescription>
-                    Configure privacy defaults. Saving reports is not enabled yet (DB/credits work is next).
+                    Configure privacy defaults. Report saving is opt-in and controlled by this setting.
                   </CardDescription>
                 </CardHeader>
                 <CardContent className="flex items-start justify-between gap-4">
                   <div className="min-w-0">
                     <div className="text-sm font-medium text-foreground">Opt-in: save screening history</div>
                     <div className="mt-1 text-sm text-muted-foreground">
-                      This currently stores only a local preference. No server-side address logging is performed yet.
+                      This setting is saved to your account. Screening history persistence remains opt-in.
                     </div>
                   </div>
                   <Switch
@@ -900,7 +931,33 @@
                     onCheckedChange={(v) => {
                       setLoggingEnabled(v);
                       writeLocalLoggingPref(v);
-                      toast.message(v ? "Logging preference enabled (local only)" : "Logging preference disabled");
+
+                      void (async () => {
+                        try {
+                          const res = await fetch("/api/user-settings", {
+                            method: "PATCH",
+                            headers: { "content-type": "application/json" },
+                            credentials: "include",
+                            body: JSON.stringify({ loggingEnabled: v }),
+                          });
+
+                          if (!res.ok) throw new Error(`Request failed (${res.status}).`);
+                          const json = (await res.json()) as unknown;
+                          const value =
+                            json && typeof json === "object" ? (json as Record<string, unknown>).loggingEnabled : undefined;
+                          if (typeof value === "boolean") {
+                            setLoggingEnabled(value);
+                            writeLocalLoggingPref(value);
+                          }
+
+                          toast.message(v ? "Saving preference enabled" : "Saving preference disabled");
+                        } catch {
+                          const revert = !v;
+                          setLoggingEnabled(revert);
+                          writeLocalLoggingPref(revert);
+                          toast.message("Could not update preference. Please try again.");
+                        }
+                      })();
                     }}
                     aria-label="Enable saving screening history"
                   />

exec
/bin/zsh -lc 'pnpm lint' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 2.35s:

> usdt_blacklisted_web@0.1.0 lint /Users/chiko/side_projects/usdt_blacklisted_web
> eslint

file update:
diff --git a/middleware.ts b/middleware.ts
index 9009ef94a93548a37928fbb79db4d17573dde8b0..6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c
--- a/middleware.ts
+++ b/middleware.ts
@@ -7,6 +7,7 @@
   "/",
   "/api/check",
   "/api/analyze",
+  "/api/user-settings",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-user-settings.test.ts b/src/__tests__/api-user-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..206dc68b6524190c6007f00b602147edc7b72713
--- /dev/null
+++ b/src/__tests__/api-user-settings.test.ts
@@ -0,0 +1,82 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+const upsertUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings, upsertUserSettings }));
+
+async function callGet() {
+  const { GET } = await import("@/app/api/user-settings/route");
+  const res = await GET();
+  const json = await res.json();
+  return { res, json };
+}
+
+async function callPatch(body: unknown) {
+  const { PATCH } = await import("@/app/api/user-settings/route");
+  const req = new Request("http://localhost/api/user-settings", {
+    method: "PATCH",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await PATCH(req);
+  const json = await res.json();
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+});
+
+describe("/api/user-settings", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callGet();
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("returns loggingEnabled=false when no row exists (default)", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue(null);
+
+    const { res, json } = await callGet();
+    expect(res.status).toBe(200);
+    expect(json.loggingEnabled).toBe(false);
+    expect(json.persistenceAvailable).toBe(true);
+    expect(upsertUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("rejects unauthenticated updates with 401 and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPatch({ loggingEnabled: true });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(upsertUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("persists loggingEnabled via PATCH and returns the updated setting", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    upsertUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const { res, json } = await callPatch({ loggingEnabled: true });
+    expect(res.status).toBe(200);
+    expect(json.loggingEnabled).toBe(true);
+    expect(json.persistenceAvailable).toBe(true);
+    expect(upsertUserSettings).toHaveBeenCalledWith({}, "user_123", true);
+  });
+});
+
diff --git a/src/app/api/user-settings/route.ts b/src/app/api/user-settings/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..370e41418b9539b44e9aaad5fc5f9405b260485b
--- /dev/null
+++ b/src/app/api/user-settings/route.ts
@@ -0,0 +1,77 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { getUserSettings, upsertUserSettings } from "@/lib/db/user-settings";
+
+export const runtime = "nodejs";
+
+const UpdateUserSettingsSchema = z.object({
+  loggingEnabled: z.boolean(),
+});
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function GET() {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { loggingEnabled: false, persistenceAvailable: false },
+      { status: 200, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const settings = await getUserSettings(db, userId);
+  return NextResponse.json(
+    { loggingEnabled: settings?.loggingEnabled ?? false, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
+export async function PATCH(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { error: "Persistence is disabled." },
+      { status: 503, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = UpdateUserSettingsSchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const updated = await upsertUserSettings(db, userId, parsed.data.loggingEnabled);
+  return NextResponse.json(
+    { loggingEnabled: updated?.loggingEnabled ?? parsed.data.loggingEnabled, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 9db92fbfddf12094c87fc753d64f71213afd6e34..c15ee53a0f7867aac39de17be6efd381c554ce0b
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -533,11 +533,13 @@
 export function BlacklistChecker() {
   const m = getMessages("en");
   const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
+  const { isLoaded: authLoaded, isSignedIn } = useAuth();
 
   const [address, setAddress] = React.useState("");
   const [validation, setValidation] = React.useState<ReturnType<typeof validateTronAddress> | null>(null);
   const [load, setLoad] = React.useState<LoadState>({ state: "idle" });
   const [loggingEnabled, setLoggingEnabled] = React.useState(false);
+  const fetchedServerLoggingPref = React.useRef(false);
 
   React.useEffect(() => {
     const handle = window.setTimeout(() => {
@@ -551,6 +553,35 @@
     setLoggingEnabled(readLocalLoggingPref());
   }, []);
 
+  React.useEffect(() => {
+    if (!clerkEnabled) return;
+    if (!authLoaded) return;
+    if (!isSignedIn) {
+      fetchedServerLoggingPref.current = false;
+      return;
+    }
+    if (fetchedServerLoggingPref.current) return;
+    fetchedServerLoggingPref.current = true;
+
+    const controller = new AbortController();
+    void (async () => {
+      try {
+        const res = await fetch("/api/user-settings", { method: "GET", credentials: "include", signal: controller.signal });
+        if (!res.ok) return;
+        const json = (await res.json()) as unknown;
+        if (!json || typeof json !== "object") return;
+        const v = (json as Record<string, unknown>).loggingEnabled;
+        if (typeof v !== "boolean") return;
+        setLoggingEnabled(v);
+        writeLocalLoggingPref(v);
+      } catch {
+        // ignore
+      }
+    })();
+
+    return () => controller.abort();
+  }, [clerkEnabled, authLoaded, isSignedIn]);
+
   const normalizedAddress = validation?.normalized ?? address.trim();
   const isValid = validation?.ok ?? false;
 
@@ -881,18 +912,18 @@
               transition={{ duration: 0.4, delay: 0.18 }}
               className="mx-auto mt-4 max-w-2xl"
             >
-              <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+                  <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
                 <CardHeader className="pb-3">
                   <CardTitle className="text-base">Account</CardTitle>
                   <CardDescription>
-                    Configure privacy defaults. Saving reports is not enabled yet (DB/credits work is next).
+                    Configure privacy defaults. Report saving is opt-in and controlled by this setting.
                   </CardDescription>
                 </CardHeader>
                 <CardContent className="flex items-start justify-between gap-4">
                   <div className="min-w-0">
                     <div className="text-sm font-medium text-foreground">Opt-in: save screening history</div>
                     <div className="mt-1 text-sm text-muted-foreground">
-                      This currently stores only a local preference. No server-side address logging is performed yet.
+                      This setting is saved to your account. Screening history persistence remains opt-in.
                     </div>
                   </div>
                   <Switch
@@ -900,7 +931,33 @@
                     onCheckedChange={(v) => {
                       setLoggingEnabled(v);
                       writeLocalLoggingPref(v);
-                      toast.message(v ? "Logging preference enabled (local only)" : "Logging preference disabled");
+
+                      void (async () => {
+                        try {
+                          const res = await fetch("/api/user-settings", {
+                            method: "PATCH",
+                            headers: { "content-type": "application/json" },
+                            credentials: "include",
+                            body: JSON.stringify({ loggingEnabled: v }),
+                          });
+
+                          if (!res.ok) throw new Error(`Request failed (${res.status}).`);
+                          const json = (await res.json()) as unknown;
+                          const value =
+                            json && typeof json === "object" ? (json as Record<string, unknown>).loggingEnabled : undefined;
+                          if (typeof value === "boolean") {
+                            setLoggingEnabled(value);
+                            writeLocalLoggingPref(value);
+                          }
+
+                          toast.message(v ? "Saving preference enabled" : "Saving preference disabled");
+                        } catch {
+                          const revert = !v;
+                          setLoggingEnabled(revert);
+                          writeLocalLoggingPref(revert);
+                          toast.message("Could not update preference. Please try again.");
+                        }
+                      })();
                     }}
                     aria-label="Enable saving screening history"
                   />

exec
/bin/zsh -lc 'pnpm test' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 1.14s:

> usdt_blacklisted_web@0.1.0 test /Users/chiko/side_projects/usdt_blacklisted_web
> vitest run


[1m[46m RUN [49m[22m [36mv4.0.17 [39m[90m/Users/chiko/side_projects/usdt_blacklisted_web[39m

 [32m✓[39m src/lib/exposure.test.ts [2m([22m[2m1 test[22m[2m)[22m[32m 3[2mms[22m[39m
 [32m✓[39m src/lib/sanctions.test.ts [2m([22m[2m2 tests[22m[2m)[22m[32m 6[2mms[22m[39m
 [32m✓[39m src/lib/aml.test.ts [2m([22m[2m7 tests[22m[2m)[22m[32m 4[2mms[22m[39m
 [32m✓[39m src/__tests__/api-user-settings.test.ts [2m([22m[2m4 tests[22m[2m)[22m[32m 125[2mms[22m[39m
 [32m✓[39m src/__tests__/api-analyze.test.ts [2m([22m[2m2 tests[22m[2m)[22m[32m 169[2mms[22m[39m
 [32m✓[39m src/lib/db/address-hash.test.ts [2m([22m[2m4 tests[22m[2m)[22m[32m 3[2mms[22m[39m
 [32m✓[39m src/lib/entity.test.ts [2m([22m[2m2 tests[22m[2m)[22m[32m 1[2mms[22m[39m
 [32m✓[39m src/lib/heuristics.test.ts [2m([22m[2m3 tests[22m[2m)[22m[32m 2[2mms[22m[39m
 [32m✓[39m src/lib/db/index.test.ts [2m([22m[2m1 test[22m[2m)[22m[32m 272[2mms[22m[39m
 [32m✓[39m src/lib/db/scoped-queries.test.ts [2m([22m[2m4 tests[22m[2m)[22m[32m 4[2mms[22m[39m

[2m Test Files [22m [1m[32m10 passed[39m[22m[90m (10)[39m
[2m      Tests [22m [1m[32m30 passed[39m[22m[90m (30)[39m
file update:
diff --git a/middleware.ts b/middleware.ts
index 9009ef94a93548a37928fbb79db4d17573dde8b0..6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c
--- a/middleware.ts
+++ b/middleware.ts
@@ -7,6 +7,7 @@
   "/",
   "/api/check",
   "/api/analyze",
+  "/api/user-settings",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-user-settings.test.ts b/src/__tests__/api-user-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..206dc68b6524190c6007f00b602147edc7b72713
--- /dev/null
+++ b/src/__tests__/api-user-settings.test.ts
@@ -0,0 +1,82 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+const upsertUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings, upsertUserSettings }));
+
+async function callGet() {
+  const { GET } = await import("@/app/api/user-settings/route");
+  const res = await GET();
+  const json = await res.json();
+  return { res, json };
+}
+
+async function callPatch(body: unknown) {
+  const { PATCH } = await import("@/app/api/user-settings/route");
+  const req = new Request("http://localhost/api/user-settings", {
+    method: "PATCH",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await PATCH(req);
+  const json = await res.json();
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+});
+
+describe("/api/user-settings", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callGet();
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("returns loggingEnabled=false when no row exists (default)", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue(null);
+
+    const { res, json } = await callGet();
+    expect(res.status).toBe(200);
+    expect(json.loggingEnabled).toBe(false);
+    expect(json.persistenceAvailable).toBe(true);
+    expect(upsertUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("rejects unauthenticated updates with 401 and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPatch({ loggingEnabled: true });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(upsertUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("persists loggingEnabled via PATCH and returns the updated setting", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    upsertUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const { res, json } = await callPatch({ loggingEnabled: true });
+    expect(res.status).toBe(200);
+    expect(json.loggingEnabled).toBe(true);
+    expect(json.persistenceAvailable).toBe(true);
+    expect(upsertUserSettings).toHaveBeenCalledWith({}, "user_123", true);
+  });
+});
+
diff --git a/src/app/api/user-settings/route.ts b/src/app/api/user-settings/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..370e41418b9539b44e9aaad5fc5f9405b260485b
--- /dev/null
+++ b/src/app/api/user-settings/route.ts
@@ -0,0 +1,77 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { getUserSettings, upsertUserSettings } from "@/lib/db/user-settings";
+
+export const runtime = "nodejs";
+
+const UpdateUserSettingsSchema = z.object({
+  loggingEnabled: z.boolean(),
+});
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function GET() {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { loggingEnabled: false, persistenceAvailable: false },
+      { status: 200, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const settings = await getUserSettings(db, userId);
+  return NextResponse.json(
+    { loggingEnabled: settings?.loggingEnabled ?? false, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
+export async function PATCH(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { error: "Persistence is disabled." },
+      { status: 503, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = UpdateUserSettingsSchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const updated = await upsertUserSettings(db, userId, parsed.data.loggingEnabled);
+  return NextResponse.json(
+    { loggingEnabled: updated?.loggingEnabled ?? parsed.data.loggingEnabled, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 9db92fbfddf12094c87fc753d64f71213afd6e34..c15ee53a0f7867aac39de17be6efd381c554ce0b
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -533,11 +533,13 @@
 export function BlacklistChecker() {
   const m = getMessages("en");
   const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
+  const { isLoaded: authLoaded, isSignedIn } = useAuth();
 
   const [address, setAddress] = React.useState("");
   const [validation, setValidation] = React.useState<ReturnType<typeof validateTronAddress> | null>(null);
   const [load, setLoad] = React.useState<LoadState>({ state: "idle" });
   const [loggingEnabled, setLoggingEnabled] = React.useState(false);
+  const fetchedServerLoggingPref = React.useRef(false);
 
   React.useEffect(() => {
     const handle = window.setTimeout(() => {
@@ -551,6 +553,35 @@
     setLoggingEnabled(readLocalLoggingPref());
   }, []);
 
+  React.useEffect(() => {
+    if (!clerkEnabled) return;
+    if (!authLoaded) return;
+    if (!isSignedIn) {
+      fetchedServerLoggingPref.current = false;
+      return;
+    }
+    if (fetchedServerLoggingPref.current) return;
+    fetchedServerLoggingPref.current = true;
+
+    const controller = new AbortController();
+    void (async () => {
+      try {
+        const res = await fetch("/api/user-settings", { method: "GET", credentials: "include", signal: controller.signal });
+        if (!res.ok) return;
+        const json = (await res.json()) as unknown;
+        if (!json || typeof json !== "object") return;
+        const v = (json as Record<string, unknown>).loggingEnabled;
+        if (typeof v !== "boolean") return;
+        setLoggingEnabled(v);
+        writeLocalLoggingPref(v);
+      } catch {
+        // ignore
+      }
+    })();
+
+    return () => controller.abort();
+  }, [clerkEnabled, authLoaded, isSignedIn]);
+
   const normalizedAddress = validation?.normalized ?? address.trim();
   const isValid = validation?.ok ?? false;
 
@@ -881,18 +912,18 @@
               transition={{ duration: 0.4, delay: 0.18 }}
               className="mx-auto mt-4 max-w-2xl"
             >
-              <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+                  <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
                 <CardHeader className="pb-3">
                   <CardTitle className="text-base">Account</CardTitle>
                   <CardDescription>
-                    Configure privacy defaults. Saving reports is not enabled yet (DB/credits work is next).
+                    Configure privacy defaults. Report saving is opt-in and controlled by this setting.
                   </CardDescription>
                 </CardHeader>
                 <CardContent className="flex items-start justify-between gap-4">
                   <div className="min-w-0">
                     <div className="text-sm font-medium text-foreground">Opt-in: save screening history</div>
                     <div className="mt-1 text-sm text-muted-foreground">
-                      This currently stores only a local preference. No server-side address logging is performed yet.
+                      This setting is saved to your account. Screening history persistence remains opt-in.
                     </div>
                   </div>
                   <Switch
@@ -900,7 +931,33 @@
                     onCheckedChange={(v) => {
                       setLoggingEnabled(v);
                       writeLocalLoggingPref(v);
-                      toast.message(v ? "Logging preference enabled (local only)" : "Logging preference disabled");
+
+                      void (async () => {
+                        try {
+                          const res = await fetch("/api/user-settings", {
+                            method: "PATCH",
+                            headers: { "content-type": "application/json" },
+                            credentials: "include",
+                            body: JSON.stringify({ loggingEnabled: v }),
+                          });
+
+                          if (!res.ok) throw new Error(`Request failed (${res.status}).`);
+                          const json = (await res.json()) as unknown;
+                          const value =
+                            json && typeof json === "object" ? (json as Record<string, unknown>).loggingEnabled : undefined;
+                          if (typeof value === "boolean") {
+                            setLoggingEnabled(value);
+                            writeLocalLoggingPref(value);
+                          }
+
+                          toast.message(v ? "Saving preference enabled" : "Saving preference disabled");
+                        } catch {
+                          const revert = !v;
+                          setLoggingEnabled(revert);
+                          writeLocalLoggingPref(revert);
+                          toast.message("Could not update preference. Please try again.");
+                        }
+                      })();
                     }}
                     aria-label="Enable saving screening history"
                   />

exec
/bin/zsh -lc 'pnpm build' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 7.56s:

> usdt_blacklisted_web@0.1.0 build /Users/chiko/side_projects/usdt_blacklisted_web
> next build

▲ Next.js 16.1.4 (Turbopack)
- Environments: .env

  Creating an optimized production build ...
✓ Compiled successfully in 3.3s
  Running TypeScript ...
  Collecting page data using 7 workers ...
  Generating static pages using 7 workers (0/7) ...
  Generating static pages using 7 workers (1/7) 
  Generating static pages using 7 workers (3/7) 
  Generating static pages using 7 workers (5/7) 
✓ Generating static pages using 7 workers (7/7) in 193.6ms
  Finalizing page optimization ...

Route (app)
┌ ○ /
file update:
diff --git a/middleware.ts b/middleware.ts
index 9009ef94a93548a37928fbb79db4d17573dde8b0..6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c
--- a/middleware.ts
+++ b/middleware.ts
@@ -7,6 +7,7 @@
   "/",
   "/api/check",
   "/api/analyze",
+  "/api/user-settings",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-user-settings.test.ts b/src/__tests__/api-user-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..206dc68b6524190c6007f00b602147edc7b72713
--- /dev/null
+++ b/src/__tests__/api-user-settings.test.ts
@@ -0,0 +1,82 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+const upsertUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings, upsertUserSettings }));
+
+async function callGet() {
+  const { GET } = await import("@/app/api/user-settings/route");
+  const res = await GET();
+  const json = await res.json();
+  return { res, json };
+}
+
+async function callPatch(body: unknown) {
+  const { PATCH } = await import("@/app/api/user-settings/route");
+  const req = new Request("http://localhost/api/user-settings", {
+    method: "PATCH",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await PATCH(req);
+  const json = await res.json();
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+});
+
+describe("/api/user-settings", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callGet();
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("returns loggingEnabled=false when no row exists (default)", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue(null);
+
+    const { res, json } = await callGet();
+    expect(res.status).toBe(200);
+    expect(json.loggingEnabled).toBe(false);
+    expect(json.persistenceAvailable).toBe(true);
+    expect(upsertUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("rejects unauthenticated updates with 401 and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPatch({ loggingEnabled: true });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(upsertUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("persists loggingEnabled via PATCH and returns the updated setting", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    upsertUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const { res, json } = await callPatch({ loggingEnabled: true });
+    expect(res.status).toBe(200);
+    expect(json.loggingEnabled).toBe(true);
+    expect(json.persistenceAvailable).toBe(true);
+    expect(upsertUserSettings).toHaveBeenCalledWith({}, "user_123", true);
+  });
+});
+
diff --git a/src/app/api/user-settings/route.ts b/src/app/api/user-settings/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..370e41418b9539b44e9aaad5fc5f9405b260485b
--- /dev/null
+++ b/src/app/api/user-settings/route.ts
@@ -0,0 +1,77 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { getUserSettings, upsertUserSettings } from "@/lib/db/user-settings";
+
+export const runtime = "nodejs";
+
+const UpdateUserSettingsSchema = z.object({
+  loggingEnabled: z.boolean(),
+});
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function GET() {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { loggingEnabled: false, persistenceAvailable: false },
+      { status: 200, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const settings = await getUserSettings(db, userId);
+  return NextResponse.json(
+    { loggingEnabled: settings?.loggingEnabled ?? false, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
+export async function PATCH(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { error: "Persistence is disabled." },
+      { status: 503, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = UpdateUserSettingsSchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const updated = await upsertUserSettings(db, userId, parsed.data.loggingEnabled);
+  return NextResponse.json(
+    { loggingEnabled: updated?.loggingEnabled ?? parsed.data.loggingEnabled, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 9db92fbfddf12094c87fc753d64f71213afd6e34..c15ee53a0f7867aac39de17be6efd381c554ce0b
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -533,11 +533,13 @@
 export function BlacklistChecker() {
   const m = getMessages("en");
   const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
+  const { isLoaded: authLoaded, isSignedIn } = useAuth();
 
   const [address, setAddress] = React.useState("");
   const [validation, setValidation] = React.useState<ReturnType<typeof validateTronAddress> | null>(null);
   const [load, setLoad] = React.useState<LoadState>({ state: "idle" });
   const [loggingEnabled, setLoggingEnabled] = React.useState(false);
+  const fetchedServerLoggingPref = React.useRef(false);
 
   React.useEffect(() => {
     const handle = window.setTimeout(() => {
@@ -551,6 +553,35 @@
     setLoggingEnabled(readLocalLoggingPref());
   }, []);
 
+  React.useEffect(() => {
+    if (!clerkEnabled) return;
+    if (!authLoaded) return;
+    if (!isSignedIn) {
+      fetchedServerLoggingPref.current = false;
+      return;
+    }
+    if (fetchedServerLoggingPref.current) return;
+    fetchedServerLoggingPref.current = true;
+
+    const controller = new AbortController();
+    void (async () => {
+      try {
+        const res = await fetch("/api/user-settings", { method: "GET", credentials: "include", signal: controller.signal });
+        if (!res.ok) return;
+        const json = (await res.json()) as unknown;
+        if (!json || typeof json !== "object") return;
+        const v = (json as Record<string, unknown>).loggingEnabled;
+        if (typeof v !== "boolean") return;
+        setLoggingEnabled(v);
+        writeLocalLoggingPref(v);
+      } catch {
+        // ignore
+      }
+    })();
+
+    return () => controller.abort();
+  }, [clerkEnabled, authLoaded, isSignedIn]);
+
   const normalizedAddress = validation?.normalized ?? address.trim();
   const isValid = validation?.ok ?? false;
 
@@ -881,18 +912,18 @@
               transition={{ duration: 0.4, delay: 0.18 }}
               className="mx-auto mt-4 max-w-2xl"
             >
-              <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+                  <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
                 <CardHeader className="pb-3">
                   <CardTitle className="text-base">Account</CardTitle>
                   <CardDescription>
-                    Configure privacy defaults. Saving reports is not enabled yet (DB/credits work is next).
+                    Configure privacy defaults. Report saving is opt-in and controlled by this setting.
                   </CardDescription>
                 </CardHeader>
                 <CardContent className="flex items-start justify-between gap-4">
                   <div className="min-w-0">
                     <div className="text-sm font-medium text-foreground">Opt-in: save screening history</div>
                     <div className="mt-1 text-sm text-muted-foreground">
-                      This currently stores only a local preference. No server-side address logging is performed yet.
+                      This setting is saved to your account. Screening history persistence remains opt-in.
                     </div>
                   </div>
                   <Switch
@@ -900,7 +931,33 @@
                     onCheckedChange={(v) => {
                       setLoggingEnabled(v);
                       writeLocalLoggingPref(v);
-                      toast.message(v ? "Logging preference enabled (local only)" : "Logging preference disabled");
+
+                      void (async () => {
+                        try {
+                          const res = await fetch("/api/user-settings", {
+                            method: "PATCH",
+                            headers: { "content-type": "application/json" },
+                            credentials: "include",
+                            body: JSON.stringify({ loggingEnabled: v }),
+                          });
+
+                          if (!res.ok) throw new Error(`Request failed (${res.status}).`);
+                          const json = (await res.json()) as unknown;
+                          const value =
+                            json && typeof json === "object" ? (json as Record<string, unknown>).loggingEnabled : undefined;
+                          if (typeof value === "boolean") {
+                            setLoggingEnabled(value);
+                            writeLocalLoggingPref(value);
+                          }
+
+                          toast.message(v ? "Saving preference enabled" : "Saving preference disabled");
+                        } catch {
+                          const revert = !v;
+                          setLoggingEnabled(revert);
+                          writeLocalLoggingPref(revert);
+                          toast.message("Could not update preference. Please try again.");
+                        }
+                      })();
                     }}
                     aria-label="Enable saving screening history"
                   />

exec
/bin/zsh -lc '/Users/chiko/side_projects/usdt_blacklisted_web/ralph log "Quality gates complete: lint/test/build PASS"' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 70ms:

file update:
diff --git a/middleware.ts b/middleware.ts
index 9009ef94a93548a37928fbb79db4d17573dde8b0..6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c
--- a/middleware.ts
+++ b/middleware.ts
@@ -7,6 +7,7 @@
   "/",
   "/api/check",
   "/api/analyze",
+  "/api/user-settings",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-user-settings.test.ts b/src/__tests__/api-user-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..206dc68b6524190c6007f00b602147edc7b72713
--- /dev/null
+++ b/src/__tests__/api-user-settings.test.ts
@@ -0,0 +1,82 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+const upsertUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings, upsertUserSettings }));
+
+async function callGet() {
+  const { GET } = await import("@/app/api/user-settings/route");
+  const res = await GET();
+  const json = await res.json();
+  return { res, json };
+}
+
+async function callPatch(body: unknown) {
+  const { PATCH } = await import("@/app/api/user-settings/route");
+  const req = new Request("http://localhost/api/user-settings", {
+    method: "PATCH",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await PATCH(req);
+  const json = await res.json();
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+});
+
+describe("/api/user-settings", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callGet();
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("returns loggingEnabled=false when no row exists (default)", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue(null);
+
+    const { res, json } = await callGet();
+    expect(res.status).toBe(200);
+    expect(json.loggingEnabled).toBe(false);
+    expect(json.persistenceAvailable).toBe(true);
+    expect(upsertUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("rejects unauthenticated updates with 401 and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPatch({ loggingEnabled: true });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(upsertUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("persists loggingEnabled via PATCH and returns the updated setting", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    upsertUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const { res, json } = await callPatch({ loggingEnabled: true });
+    expect(res.status).toBe(200);
+    expect(json.loggingEnabled).toBe(true);
+    expect(json.persistenceAvailable).toBe(true);
+    expect(upsertUserSettings).toHaveBeenCalledWith({}, "user_123", true);
+  });
+});
+
diff --git a/src/app/api/user-settings/route.ts b/src/app/api/user-settings/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..370e41418b9539b44e9aaad5fc5f9405b260485b
--- /dev/null
+++ b/src/app/api/user-settings/route.ts
@@ -0,0 +1,77 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { getUserSettings, upsertUserSettings } from "@/lib/db/user-settings";
+
+export const runtime = "nodejs";
+
+const UpdateUserSettingsSchema = z.object({
+  loggingEnabled: z.boolean(),
+});
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function GET() {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { loggingEnabled: false, persistenceAvailable: false },
+      { status: 200, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const settings = await getUserSettings(db, userId);
+  return NextResponse.json(
+    { loggingEnabled: settings?.loggingEnabled ?? false, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
+export async function PATCH(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { error: "Persistence is disabled." },
+      { status: 503, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = UpdateUserSettingsSchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const updated = await upsertUserSettings(db, userId, parsed.data.loggingEnabled);
+  return NextResponse.json(
+    { loggingEnabled: updated?.loggingEnabled ?? parsed.data.loggingEnabled, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 9db92fbfddf12094c87fc753d64f71213afd6e34..c15ee53a0f7867aac39de17be6efd381c554ce0b
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -533,11 +533,13 @@
 export function BlacklistChecker() {
   const m = getMessages("en");
   const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
+  const { isLoaded: authLoaded, isSignedIn } = useAuth();
 
   const [address, setAddress] = React.useState("");
   const [validation, setValidation] = React.useState<ReturnType<typeof validateTronAddress> | null>(null);
   const [load, setLoad] = React.useState<LoadState>({ state: "idle" });
   const [loggingEnabled, setLoggingEnabled] = React.useState(false);
+  const fetchedServerLoggingPref = React.useRef(false);
 
   React.useEffect(() => {
     const handle = window.setTimeout(() => {
@@ -551,6 +553,35 @@
     setLoggingEnabled(readLocalLoggingPref());
   }, []);
 
+  React.useEffect(() => {
+    if (!clerkEnabled) return;
+    if (!authLoaded) return;
+    if (!isSignedIn) {
+      fetchedServerLoggingPref.current = false;
+      return;
+    }
+    if (fetchedServerLoggingPref.current) return;
+    fetchedServerLoggingPref.current = true;
+
+    const controller = new AbortController();
+    void (async () => {
+      try {
+        const res = await fetch("/api/user-settings", { method: "GET", credentials: "include", signal: controller.signal });
+        if (!res.ok) return;
+        const json = (await res.json()) as unknown;
+        if (!json || typeof json !== "object") return;
+        const v = (json as Record<string, unknown>).loggingEnabled;
+        if (typeof v !== "boolean") return;
+        setLoggingEnabled(v);
+        writeLocalLoggingPref(v);
+      } catch {
+        // ignore
+      }
+    })();
+
+    return () => controller.abort();
+  }, [clerkEnabled, authLoaded, isSignedIn]);
+
   const normalizedAddress = validation?.normalized ?? address.trim();
   const isValid = validation?.ok ?? false;
 
@@ -881,18 +912,18 @@
               transition={{ duration: 0.4, delay: 0.18 }}
               className="mx-auto mt-4 max-w-2xl"
             >
-              <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+                  <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
                 <CardHeader className="pb-3">
                   <CardTitle className="text-base">Account</CardTitle>
                   <CardDescription>
-                    Configure privacy defaults. Saving reports is not enabled yet (DB/credits work is next).
+                    Configure privacy defaults. Report saving is opt-in and controlled by this setting.
                   </CardDescription>
                 </CardHeader>
                 <CardContent className="flex items-start justify-between gap-4">
                   <div className="min-w-0">
                     <div className="text-sm font-medium text-foreground">Opt-in: save screening history</div>
                     <div className="mt-1 text-sm text-muted-foreground">
-                      This currently stores only a local preference. No server-side address logging is performed yet.
+                      This setting is saved to your account. Screening history persistence remains opt-in.
                     </div>
                   </div>
                   <Switch
@@ -900,7 +931,33 @@
                     onCheckedChange={(v) => {
                       setLoggingEnabled(v);
                       writeLocalLoggingPref(v);
-                      toast.message(v ? "Logging preference enabled (local only)" : "Logging preference disabled");
+
+                      void (async () => {
+                        try {
+                          const res = await fetch("/api/user-settings", {
+                            method: "PATCH",
+                            headers: { "content-type": "application/json" },
+                            credentials: "include",
+                            body: JSON.stringify({ loggingEnabled: v }),
+                          });
+
+                          if (!res.ok) throw new Error(`Request failed (${res.status}).`);
+                          const json = (await res.json()) as unknown;
+                          const value =
+                            json && typeof json === "object" ? (json as Record<string, unknown>).loggingEnabled : undefined;
+                          if (typeof value === "boolean") {
+                            setLoggingEnabled(value);
+                            writeLocalLoggingPref(value);
+                          }
+
+                          toast.message(v ? "Saving preference enabled" : "Saving preference disabled");
+                        } catch {
+                          const revert = !v;
+                          setLoggingEnabled(revert);
+                          writeLocalLoggingPref(revert);
+                          toast.message("Could not update preference. Please try again.");
+                        }
+                      })();
                     }}
                     aria-label="Enable saving screening history"
                   />

Plan update
  ✓ Review guardrails and prior errors
  ✓ Audit existing auth, DB, API patterns
  ✓ Implement settings GET/PUT routes
  ✓ Add unit/route tests
  ✓ Run lint, test, build
  → Security/perf/regression review, commit, logs
file update:
diff --git a/middleware.ts b/middleware.ts
index 9009ef94a93548a37928fbb79db4d17573dde8b0..6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c
--- a/middleware.ts
+++ b/middleware.ts
@@ -7,6 +7,7 @@
   "/",
   "/api/check",
   "/api/analyze",
+  "/api/user-settings",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-user-settings.test.ts b/src/__tests__/api-user-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..206dc68b6524190c6007f00b602147edc7b72713
--- /dev/null
+++ b/src/__tests__/api-user-settings.test.ts
@@ -0,0 +1,82 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+const upsertUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings, upsertUserSettings }));
+
+async function callGet() {
+  const { GET } = await import("@/app/api/user-settings/route");
+  const res = await GET();
+  const json = await res.json();
+  return { res, json };
+}
+
+async function callPatch(body: unknown) {
+  const { PATCH } = await import("@/app/api/user-settings/route");
+  const req = new Request("http://localhost/api/user-settings", {
+    method: "PATCH",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await PATCH(req);
+  const json = await res.json();
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+});
+
+describe("/api/user-settings", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callGet();
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("returns loggingEnabled=false when no row exists (default)", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue(null);
+
+    const { res, json } = await callGet();
+    expect(res.status).toBe(200);
+    expect(json.loggingEnabled).toBe(false);
+    expect(json.persistenceAvailable).toBe(true);
+    expect(upsertUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("rejects unauthenticated updates with 401 and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPatch({ loggingEnabled: true });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(upsertUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("persists loggingEnabled via PATCH and returns the updated setting", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    upsertUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const { res, json } = await callPatch({ loggingEnabled: true });
+    expect(res.status).toBe(200);
+    expect(json.loggingEnabled).toBe(true);
+    expect(json.persistenceAvailable).toBe(true);
+    expect(upsertUserSettings).toHaveBeenCalledWith({}, "user_123", true);
+  });
+});
+
diff --git a/src/app/api/user-settings/route.ts b/src/app/api/user-settings/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..370e41418b9539b44e9aaad5fc5f9405b260485b
--- /dev/null
+++ b/src/app/api/user-settings/route.ts
@@ -0,0 +1,77 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { getUserSettings, upsertUserSettings } from "@/lib/db/user-settings";
+
+export const runtime = "nodejs";
+
+const UpdateUserSettingsSchema = z.object({
+  loggingEnabled: z.boolean(),
+});
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function GET() {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { loggingEnabled: false, persistenceAvailable: false },
+      { status: 200, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const settings = await getUserSettings(db, userId);
+  return NextResponse.json(
+    { loggingEnabled: settings?.loggingEnabled ?? false, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
+export async function PATCH(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { error: "Persistence is disabled." },
+      { status: 503, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = UpdateUserSettingsSchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const updated = await upsertUserSettings(db, userId, parsed.data.loggingEnabled);
+  return NextResponse.json(
+    { loggingEnabled: updated?.loggingEnabled ?? parsed.data.loggingEnabled, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 9db92fbfddf12094c87fc753d64f71213afd6e34..c15ee53a0f7867aac39de17be6efd381c554ce0b
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -533,11 +533,13 @@
 export function BlacklistChecker() {
   const m = getMessages("en");
   const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
+  const { isLoaded: authLoaded, isSignedIn } = useAuth();
 
   const [address, setAddress] = React.useState("");
   const [validation, setValidation] = React.useState<ReturnType<typeof validateTronAddress> | null>(null);
   const [load, setLoad] = React.useState<LoadState>({ state: "idle" });
   const [loggingEnabled, setLoggingEnabled] = React.useState(false);
+  const fetchedServerLoggingPref = React.useRef(false);
 
   React.useEffect(() => {
     const handle = window.setTimeout(() => {
@@ -551,6 +553,35 @@
     setLoggingEnabled(readLocalLoggingPref());
   }, []);
 
+  React.useEffect(() => {
+    if (!clerkEnabled) return;
+    if (!authLoaded) return;
+    if (!isSignedIn) {
+      fetchedServerLoggingPref.current = false;
+      return;
+    }
+    if (fetchedServerLoggingPref.current) return;
+    fetchedServerLoggingPref.current = true;
+
+    const controller = new AbortController();
+    void (async () => {
+      try {
+        const res = await fetch("/api/user-settings", { method: "GET", credentials: "include", signal: controller.signal });
+        if (!res.ok) return;
+        const json = (await res.json()) as unknown;
+        if (!json || typeof json !== "object") return;
+        const v = (json as Record<string, unknown>).loggingEnabled;
+        if (typeof v !== "boolean") return;
+        setLoggingEnabled(v);
+        writeLocalLoggingPref(v);
+      } catch {
+        // ignore
+      }
+    })();
+
+    return () => controller.abort();
+  }, [clerkEnabled, authLoaded, isSignedIn]);
+
   const normalizedAddress = validation?.normalized ?? address.trim();
   const isValid = validation?.ok ?? false;
 
@@ -881,18 +912,18 @@
               transition={{ duration: 0.4, delay: 0.18 }}
               className="mx-auto mt-4 max-w-2xl"
             >
-              <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+                  <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
                 <CardHeader className="pb-3">
                   <CardTitle className="text-base">Account</CardTitle>
                   <CardDescription>
-                    Configure privacy defaults. Saving reports is not enabled yet (DB/credits work is next).
+                    Configure privacy defaults. Report saving is opt-in and controlled by this setting.
                   </CardDescription>
                 </CardHeader>
                 <CardContent className="flex items-start justify-between gap-4">
                   <div className="min-w-0">
                     <div className="text-sm font-medium text-foreground">Opt-in: save screening history</div>
                     <div className="mt-1 text-sm text-muted-foreground">
-                      This currently stores only a local preference. No server-side address logging is performed yet.
+                      This setting is saved to your account. Screening history persistence remains opt-in.
                     </div>
                   </div>
                   <Switch
@@ -900,7 +931,33 @@
                     onCheckedChange={(v) => {
                       setLoggingEnabled(v);
                       writeLocalLoggingPref(v);
-                      toast.message(v ? "Logging preference enabled (local only)" : "Logging preference disabled");
+
+                      void (async () => {
+                        try {
+                          const res = await fetch("/api/user-settings", {
+                            method: "PATCH",
+                            headers: { "content-type": "application/json" },
+                            credentials: "include",
+                            body: JSON.stringify({ loggingEnabled: v }),
+                          });
+
+                          if (!res.ok) throw new Error(`Request failed (${res.status}).`);
+                          const json = (await res.json()) as unknown;
+                          const value =
+                            json && typeof json === "object" ? (json as Record<string, unknown>).loggingEnabled : undefined;
+                          if (typeof value === "boolean") {
+                            setLoggingEnabled(value);
+                            writeLocalLoggingPref(value);
+                          }
+
+                          toast.message(v ? "Saving preference enabled" : "Saving preference disabled");
+                        } catch {
+                          const revert = !v;
+                          setLoggingEnabled(revert);
+                          writeLocalLoggingPref(revert);
+                          toast.message("Could not update preference. Please try again.");
+                        }
+                      })();
                     }}
                     aria-label="Enable saving screening history"
                   />


thinking
**Evaluating API concerns**

I have a concern: if the method getAuthenticatedUserId returns null, it means some environment keys might be missing. This gives a 401 instead of a 501, which is not harmful but could be misleading. I need to ensure that API logs do not include the full request body, and that's an important point. I'll also check that the middleware change adds a new public route without affecting others. Now it’s time to inspect the git diff for the staging check.
exec
/bin/zsh -lc 'git status --porcelain && git diff --stat' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 78ms:
 M .agents/tasks/prd-post-mvp.json
 M .ralph/activity.log
 M .ralph/errors.log
 M .ralph/runs/run-20260123-044356-6274-iter-3.log
 M .ralph/runs/run-20260123-044356-6274-iter-3.md
 M middleware.ts
 M src/components/blacklist-checker.tsx
?? .ralph/.tmp/prompt-20260123-044356-6274-4.md
?? .ralph/.tmp/story-20260123-044356-6274-4.json
?? .ralph/.tmp/story-20260123-044356-6274-4.md
?? .ralph/runs/run-20260123-044356-6274-iter-4.log
?? src/__tests__/api-user-settings.test.ts
?? src/app/api/user-settings/
 .agents/tasks/prd-post-mvp.json                 |   13 +-
 .ralph/activity.log                             |    9 +
 .ralph/errors.log                               |    1 +
 .ralph/runs/run-20260123-044356-6274-iter-3.log | 1467 ++++++++++++++++++++++-
 .ralph/runs/run-20260123-044356-6274-iter-3.md  |   15 +-
 middleware.ts                                   |    1 +
 src/components/blacklist-checker.tsx            |   65 +-
file update:
diff --git a/middleware.ts b/middleware.ts
index 9009ef94a93548a37928fbb79db4d17573dde8b0..6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c
--- a/middleware.ts
+++ b/middleware.ts
@@ -7,6 +7,7 @@
   "/",
   "/api/check",
   "/api/analyze",
+  "/api/user-settings",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-user-settings.test.ts b/src/__tests__/api-user-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..206dc68b6524190c6007f00b602147edc7b72713
--- /dev/null
+++ b/src/__tests__/api-user-settings.test.ts
@@ -0,0 +1,82 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+const upsertUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings, upsertUserSettings }));
+
+async function callGet() {
+  const { GET } = await import("@/app/api/user-settings/route");
+  const res = await GET();
+  const json = await res.json();
+  return { res, json };
+}
+
+async function callPatch(body: unknown) {
+  const { PATCH } = await import("@/app/api/user-settings/route");
+  const req = new Request("http://localhost/api/user-settings", {
+    method: "PATCH",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await PATCH(req);
+  const json = await res.json();
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+});
+
+describe("/api/user-settings", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callGet();
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("returns loggingEnabled=false when no row exists (default)", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue(null);
+
+    const { res, json } = await callGet();
+    expect(res.status).toBe(200);
+    expect(json.loggingEnabled).toBe(false);
+    expect(json.persistenceAvailable).toBe(true);
+    expect(upsertUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("rejects unauthenticated updates with 401 and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPatch({ loggingEnabled: true });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(upsertUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("persists loggingEnabled via PATCH and returns the updated setting", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    upsertUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const { res, json } = await callPatch({ loggingEnabled: true });
+    expect(res.status).toBe(200);
+    expect(json.loggingEnabled).toBe(true);
+    expect(json.persistenceAvailable).toBe(true);
+    expect(upsertUserSettings).toHaveBeenCalledWith({}, "user_123", true);
+  });
+});
+
diff --git a/src/app/api/user-settings/route.ts b/src/app/api/user-settings/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..370e41418b9539b44e9aaad5fc5f9405b260485b
--- /dev/null
+++ b/src/app/api/user-settings/route.ts
@@ -0,0 +1,77 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { getUserSettings, upsertUserSettings } from "@/lib/db/user-settings";
+
+export const runtime = "nodejs";
+
+const UpdateUserSettingsSchema = z.object({
+  loggingEnabled: z.boolean(),
+});
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function GET() {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { loggingEnabled: false, persistenceAvailable: false },
+      { status: 200, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const settings = await getUserSettings(db, userId);
+  return NextResponse.json(
+    { loggingEnabled: settings?.loggingEnabled ?? false, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
+export async function PATCH(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { error: "Persistence is disabled." },
+      { status: 503, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = UpdateUserSettingsSchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const updated = await upsertUserSettings(db, userId, parsed.data.loggingEnabled);
+  return NextResponse.json(
+    { loggingEnabled: updated?.loggingEnabled ?? parsed.data.loggingEnabled, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 9db92fbfddf12094c87fc753d64f71213afd6e34..c15ee53a0f7867aac39de17be6efd381c554ce0b
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -533,11 +533,13 @@
 export function BlacklistChecker() {
   const m = getMessages("en");
   const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
+  const { isLoaded: authLoaded, isSignedIn } = useAuth();
 
   const [address, setAddress] = React.useState("");
   const [validation, setValidation] = React.useState<ReturnType<typeof validateTronAddress> | null>(null);
   const [load, setLoad] = React.useState<LoadState>({ state: "idle" });
   const [loggingEnabled, setLoggingEnabled] = React.useState(false);
+  const fetchedServerLoggingPref = React.useRef(false);
 
   React.useEffect(() => {
     const handle = window.setTimeout(() => {
@@ -551,6 +553,35 @@
     setLoggingEnabled(readLocalLoggingPref());
   }, []);
 
+  React.useEffect(() => {
+    if (!clerkEnabled) return;
+    if (!authLoaded) return;
+    if (!isSignedIn) {
+      fetchedServerLoggingPref.current = false;
+      return;
+    }
+    if (fetchedServerLoggingPref.current) return;
+    fetchedServerLoggingPref.current = true;
+
+    const controller = new AbortController();
+    void (async () => {
+      try {
+        const res = await fetch("/api/user-settings", { method: "GET", credentials: "include", signal: controller.signal });
+        if (!res.ok) return;
+        const json = (await res.json()) as unknown;
+        if (!json || typeof json !== "object") return;
+        const v = (json as Record<string, unknown>).loggingEnabled;
+        if (typeof v !== "boolean") return;
+        setLoggingEnabled(v);
+        writeLocalLoggingPref(v);
+      } catch {
+        // ignore
+      }
+    })();
+
+    return () => controller.abort();
+  }, [clerkEnabled, authLoaded, isSignedIn]);
+
   const normalizedAddress = validation?.normalized ?? address.trim();
   const isValid = validation?.ok ?? false;
 
@@ -881,18 +912,18 @@
               transition={{ duration: 0.4, delay: 0.18 }}
               className="mx-auto mt-4 max-w-2xl"
             >
-              <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+                  <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
                 <CardHeader className="pb-3">
                   <CardTitle className="text-base">Account</CardTitle>
                   <CardDescription>
-                    Configure privacy defaults. Saving reports is not enabled yet (DB/credits work is next).
+                    Configure privacy defaults. Report saving is opt-in and controlled by this setting.
                   </CardDescription>
                 </CardHeader>
                 <CardContent className="flex items-start justify-between gap-4">
                   <div className="min-w-0">
                     <div className="text-sm font-medium text-foreground">Opt-in: save screening history</div>
                     <div className="mt-1 text-sm text-muted-foreground">
-                      This currently stores only a local preference. No server-side address logging is performed yet.
+                      This setting is saved to your account. Screening history persistence remains opt-in.
                     </div>
                   </div>
                   <Switch
@@ -900,7 +931,33 @@
                     onCheckedChange={(v) => {
                       setLoggingEnabled(v);
                       writeLocalLoggingPref(v);
-                      toast.message(v ? "Logging preference enabled (local only)" : "Logging preference disabled");
+
+                      void (async () => {
+                        try {
+                          const res = await fetch("/api/user-settings", {
+                            method: "PATCH",
+                            headers: { "content-type": "application/json" },
+                            credentials: "include",
+                            body: JSON.stringify({ loggingEnabled: v }),
+                          });
+
+                          if (!res.ok) throw new Error(`Request failed (${res.status}).`);
+                          const json = (await res.json()) as unknown;
+                          const value =
+                            json && typeof json === "object" ? (json as Record<string, unknown>).loggingEnabled : undefined;
+                          if (typeof value === "boolean") {
+                            setLoggingEnabled(value);
+                            writeLocalLoggingPref(value);
+                          }
+
+                          toast.message(v ? "Saving preference enabled" : "Saving preference disabled");
+                        } catch {
+                          const revert = !v;
+                          setLoggingEnabled(revert);
+                          writeLocalLoggingPref(revert);
+                          toast.message("Could not update preference. Please try again.");
+                        }
+                      })();
                     }}
                     aria-label="Enable saving screening history"
                   />


thinking
**Considering file commit decisions**

I'm looking at some files like `.ralph/.tmp` and `run-iter-4.log`. They seem temporary, but I’m unsure whether they should be committed. In previous logs, errors led to repeated failures with uncommitted changes. I think we should follow the harness and commit most things, except possibly `.ralph/.tmp`. I need to check the `.gitignore` to see if `.ralph` should be ignored, as it’s not clear if we should currently commit that. Let's take a look at the `.gitignore` file.
exec
/bin/zsh -lc "sed -n '1,200p' .gitignore" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 63ms:
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
file update:
diff --git a/middleware.ts b/middleware.ts
index 9009ef94a93548a37928fbb79db4d17573dde8b0..6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c
--- a/middleware.ts
+++ b/middleware.ts
@@ -7,6 +7,7 @@
   "/",
   "/api/check",
   "/api/analyze",
+  "/api/user-settings",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-user-settings.test.ts b/src/__tests__/api-user-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..206dc68b6524190c6007f00b602147edc7b72713
--- /dev/null
+++ b/src/__tests__/api-user-settings.test.ts
@@ -0,0 +1,82 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+const upsertUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings, upsertUserSettings }));
+
+async function callGet() {
+  const { GET } = await import("@/app/api/user-settings/route");
+  const res = await GET();
+  const json = await res.json();
+  return { res, json };
+}
+
+async function callPatch(body: unknown) {
+  const { PATCH } = await import("@/app/api/user-settings/route");
+  const req = new Request("http://localhost/api/user-settings", {
+    method: "PATCH",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await PATCH(req);
+  const json = await res.json();
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+});
+
+describe("/api/user-settings", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callGet();
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("returns loggingEnabled=false when no row exists (default)", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue(null);
+
+    const { res, json } = await callGet();
+    expect(res.status).toBe(200);
+    expect(json.loggingEnabled).toBe(false);
+    expect(json.persistenceAvailable).toBe(true);
+    expect(upsertUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("rejects unauthenticated updates with 401 and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPatch({ loggingEnabled: true });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(upsertUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("persists loggingEnabled via PATCH and returns the updated setting", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    upsertUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const { res, json } = await callPatch({ loggingEnabled: true });
+    expect(res.status).toBe(200);
+    expect(json.loggingEnabled).toBe(true);
+    expect(json.persistenceAvailable).toBe(true);
+    expect(upsertUserSettings).toHaveBeenCalledWith({}, "user_123", true);
+  });
+});
+
diff --git a/src/app/api/user-settings/route.ts b/src/app/api/user-settings/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..370e41418b9539b44e9aaad5fc5f9405b260485b
--- /dev/null
+++ b/src/app/api/user-settings/route.ts
@@ -0,0 +1,77 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { getUserSettings, upsertUserSettings } from "@/lib/db/user-settings";
+
+export const runtime = "nodejs";
+
+const UpdateUserSettingsSchema = z.object({
+  loggingEnabled: z.boolean(),
+});
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function GET() {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { loggingEnabled: false, persistenceAvailable: false },
+      { status: 200, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const settings = await getUserSettings(db, userId);
+  return NextResponse.json(
+    { loggingEnabled: settings?.loggingEnabled ?? false, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
+export async function PATCH(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { error: "Persistence is disabled." },
+      { status: 503, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = UpdateUserSettingsSchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const updated = await upsertUserSettings(db, userId, parsed.data.loggingEnabled);
+  return NextResponse.json(
+    { loggingEnabled: updated?.loggingEnabled ?? parsed.data.loggingEnabled, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 9db92fbfddf12094c87fc753d64f71213afd6e34..c15ee53a0f7867aac39de17be6efd381c554ce0b
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -533,11 +533,13 @@
 export function BlacklistChecker() {
   const m = getMessages("en");
   const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
+  const { isLoaded: authLoaded, isSignedIn } = useAuth();
 
   const [address, setAddress] = React.useState("");
   const [validation, setValidation] = React.useState<ReturnType<typeof validateTronAddress> | null>(null);
   const [load, setLoad] = React.useState<LoadState>({ state: "idle" });
   const [loggingEnabled, setLoggingEnabled] = React.useState(false);
+  const fetchedServerLoggingPref = React.useRef(false);
 
   React.useEffect(() => {
     const handle = window.setTimeout(() => {
@@ -551,6 +553,35 @@
     setLoggingEnabled(readLocalLoggingPref());
   }, []);
 
+  React.useEffect(() => {
+    if (!clerkEnabled) return;
+    if (!authLoaded) return;
+    if (!isSignedIn) {
+      fetchedServerLoggingPref.current = false;
+      return;
+    }
+    if (fetchedServerLoggingPref.current) return;
+    fetchedServerLoggingPref.current = true;
+
+    const controller = new AbortController();
+    void (async () => {
+      try {
+        const res = await fetch("/api/user-settings", { method: "GET", credentials: "include", signal: controller.signal });
+        if (!res.ok) return;
+        const json = (await res.json()) as unknown;
+        if (!json || typeof json !== "object") return;
+        const v = (json as Record<string, unknown>).loggingEnabled;
+        if (typeof v !== "boolean") return;
+        setLoggingEnabled(v);
+        writeLocalLoggingPref(v);
+      } catch {
+        // ignore
+      }
+    })();
+
+    return () => controller.abort();
+  }, [clerkEnabled, authLoaded, isSignedIn]);
+
   const normalizedAddress = validation?.normalized ?? address.trim();
   const isValid = validation?.ok ?? false;
 
@@ -881,18 +912,18 @@
               transition={{ duration: 0.4, delay: 0.18 }}
               className="mx-auto mt-4 max-w-2xl"
             >
-              <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+                  <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
                 <CardHeader className="pb-3">
                   <CardTitle className="text-base">Account</CardTitle>
                   <CardDescription>
-                    Configure privacy defaults. Saving reports is not enabled yet (DB/credits work is next).
+                    Configure privacy defaults. Report saving is opt-in and controlled by this setting.
                   </CardDescription>
                 </CardHeader>
                 <CardContent className="flex items-start justify-between gap-4">
                   <div className="min-w-0">
                     <div className="text-sm font-medium text-foreground">Opt-in: save screening history</div>
                     <div className="mt-1 text-sm text-muted-foreground">
-                      This currently stores only a local preference. No server-side address logging is performed yet.
+                      This setting is saved to your account. Screening history persistence remains opt-in.
                     </div>
                   </div>
                   <Switch
@@ -900,7 +931,33 @@
                     onCheckedChange={(v) => {
                       setLoggingEnabled(v);
                       writeLocalLoggingPref(v);
-                      toast.message(v ? "Logging preference enabled (local only)" : "Logging preference disabled");
+
+                      void (async () => {
+                        try {
+                          const res = await fetch("/api/user-settings", {
+                            method: "PATCH",
+                            headers: { "content-type": "application/json" },
+                            credentials: "include",
+                            body: JSON.stringify({ loggingEnabled: v }),
+                          });
+
+                          if (!res.ok) throw new Error(`Request failed (${res.status}).`);
+                          const json = (await res.json()) as unknown;
+                          const value =
+                            json && typeof json === "object" ? (json as Record<string, unknown>).loggingEnabled : undefined;
+                          if (typeof value === "boolean") {
+                            setLoggingEnabled(value);
+                            writeLocalLoggingPref(value);
+                          }
+
+                          toast.message(v ? "Saving preference enabled" : "Saving preference disabled");
+                        } catch {
+                          const revert = !v;
+                          setLoggingEnabled(revert);
+                          writeLocalLoggingPref(revert);
+                          toast.message("Could not update preference. Please try again.");
+                        }
+                      })();
                     }}
                     aria-label="Enable saving screening history"
                   />


thinking
**Evaluating commit strategy**

I'm analyzing how to handle files like `.ralph/` and `.agents tasks`. It seems we should commit changes in `.ralph/runs`, but what about `.tmp` files? Maybe we need to commit those too, even if they're temporary. The instructions indicate all changes must be committed, but I'm hesitant about modifying the `prd-post-mvp.json` file since the rules say not to edit it. If the loop updates it, then the change could be valid, but confirming its correctness seems necessary. I'll need to inspect the differences further.
exec
/bin/zsh -lc "git diff -- .agents/tasks/prd-post-mvp.json | sed -n '1,200p'" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 69ms:
diff --git a/.agents/tasks/prd-post-mvp.json b/.agents/tasks/prd-post-mvp.json
index 88b5943..1d10861 100644
--- a/.agents/tasks/prd-post-mvp.json
+++ b/.agents/tasks/prd-post-mvp.json
@@ -173,7 +173,7 @@
     {
       "id": "US-003",
       "title": "[P2] Implement schema: user settings + saved reports + watchlist",
-      "status": "in_progress",
+      "status": "done",
       "dependsOn": [
         "US-002"
       ],
@@ -186,13 +186,13 @@
         "Negative case: Attempting to query another user\u2019s data by id/address is blocked at the query layer (always filter by authenticated userId)."
       ],
       "startedAt": "2026-01-23T05:11:58.613523+00:00",
-      "completedAt": null,
-      "updatedAt": "2026-01-23T05:11:58.613711+00:00"
+      "completedAt": "2026-01-23T05:30:24.005680+00:00",
exec
/bin/zsh -lc "git diff -- .ralph/errors.log | sed -n '1,120p'" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 41ms:
diff --git a/.ralph/errors.log b/.ralph/errors.log
index 7ce8994..f31a52f 100644
--- a/.ralph/errors.log
+++ b/.ralph/errors.log
@@ -4,3 +4,4 @@
 
 [2026-01-23 04:55:57] ITERATION 1 left uncommitted changes; review run summary at /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-044356-6274-iter-1.md
 [2026-01-23 05:11:56] ITERATION 2 left uncommitted changes; review run summary at /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-044356-6274-iter-2.md
+[2026-01-23 05:30:23] ITERATION 3 left uncommitted changes; review run summary at /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-044356-6274-iter-3.md
exec
/bin/zsh -lc "git diff -- middleware.ts | sed -n '1,80p'" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 37ms:
diff --git a/middleware.ts b/middleware.ts
index 9009ef9..6afe8fd 100644
--- a/middleware.ts
+++ b/middleware.ts
@@ -7,6 +7,7 @@ const isPublicRoute = createRouteMatcher([
   "/",
   "/api/check",
   "/api/analyze",
+  "/api/user-settings",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
exec
/bin/zsh -lc "git diff -- src/components/blacklist-checker.tsx | sed -n '1,120p'" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 39ms:
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 9db92fb..c15ee53 100644
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -533,11 +533,13 @@ function ScamWarningAlert() {
 export function BlacklistChecker() {
   const m = getMessages("en");
   const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
+  const { isLoaded: authLoaded, isSignedIn } = useAuth();
 
   const [address, setAddress] = React.useState("");
   const [validation, setValidation] = React.useState<ReturnType<typeof validateTronAddress> | null>(null);
   const [load, setLoad] = React.useState<LoadState>({ state: "idle" });
   const [loggingEnabled, setLoggingEnabled] = React.useState(false);
+  const fetchedServerLoggingPref = React.useRef(false);
 
   React.useEffect(() => {
     const handle = window.setTimeout(() => {
@@ -551,6 +553,35 @@ export function BlacklistChecker() {
     setLoggingEnabled(readLocalLoggingPref());
exec
/bin/zsh -lc 'git diff --stat -- .ralph/runs/run-20260123-044356-6274-iter-3.md .ralph/runs/run-20260123-044356-6274-iter-3.log | cat' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 69ms:
 .ralph/runs/run-20260123-044356-6274-iter-3.log | 1467 ++++++++++++++++++++++-
 .ralph/runs/run-20260123-044356-6274-iter-3.md  |   15 +-
 2 files changed, 1477 insertions(+), 5 deletions(-)
exec
/bin/zsh -lc 'ls -la .ralph/.tmp && wc -l .ralph/.tmp/* 2>/dev/null || true' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 67ms:
total 144
drwxr-xr-x@ 21 chiko  staff   672 Jan 23 05:30 .
drwxr-xr-x@  8 chiko  staff   256 Jan 23 04:25 ..
-rw-r--r--@  1 chiko  staff   524 Jan 23 04:21 prd-prompt-20260123-042148-75244.md
-rw-r--r--@  1 chiko  staff   512 Jan 23 04:37 prd-prompt-20260123-043736-96875.md
-rw-r--r--@  1 chiko  staff  7708 Jan 23 04:43 prompt-20260123-044356-6274-1.md
-rw-r--r--@  1 chiko  staff  7599 Jan 23 05:11 prompt-20260123-044356-6274-3.md
-rw-r--r--@  1 chiko  staff  7518 Jan 23 05:30 prompt-20260123-044356-6274-4.md
-rw-r--r--@  1 chiko  staff    56 Jan 23 04:25 story-20260123-042526-80680-1.json
-rw-r--r--@  1 chiko  staff     0 Jan 23 04:25 story-20260123-042526-80680-1.md
-rw-r--r--@  1 chiko  staff    56 Jan 23 04:26 story-20260123-042600-81451-1.json
-rw-r--r--@  1 chiko  staff     0 Jan 23 04:26 story-20260123-042600-81451-1.md
-rw-r--r--@  1 chiko  staff    56 Jan 23 04:34 story-20260123-043424-92605-1.json
-rw-r--r--@  1 chiko  staff     0 Jan 23 04:34 story-20260123-043424-92605-1.md
-rw-r--r--@  1 chiko  staff    56 Jan 23 04:37 story-20260123-043705-96152-1.json
-rw-r--r--@  1 chiko  staff     0 Jan 23 04:37 story-20260123-043705-96152-1.md
-rw-r--r--@  1 chiko  staff   216 Jan 23 04:43 story-20260123-044356-6274-1.json
-rw-r--r--@  1 chiko  staff  1002 Jan 23 04:43 story-20260123-044356-6274-1.md
-rw-r--r--@  1 chiko  staff   225 Jan 23 05:11 story-20260123-044356-6274-3.json
-rw-r--r--@  1 chiko  staff   875 Jan 23 05:11 story-20260123-044356-6274-3.md
file update:
diff --git a/middleware.ts b/middleware.ts
index 9009ef94a93548a37928fbb79db4d17573dde8b0..6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c
--- a/middleware.ts
+++ b/middleware.ts
@@ -7,6 +7,7 @@
   "/",
   "/api/check",
   "/api/analyze",
+  "/api/user-settings",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-user-settings.test.ts b/src/__tests__/api-user-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..206dc68b6524190c6007f00b602147edc7b72713
--- /dev/null
+++ b/src/__tests__/api-user-settings.test.ts
@@ -0,0 +1,82 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+const upsertUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings, upsertUserSettings }));
+
+async function callGet() {
+  const { GET } = await import("@/app/api/user-settings/route");
+  const res = await GET();
+  const json = await res.json();
+  return { res, json };
+}
+
+async function callPatch(body: unknown) {
+  const { PATCH } = await import("@/app/api/user-settings/route");
+  const req = new Request("http://localhost/api/user-settings", {
+    method: "PATCH",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await PATCH(req);
+  const json = await res.json();
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+});
+
+describe("/api/user-settings", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callGet();
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("returns loggingEnabled=false when no row exists (default)", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue(null);
+
+    const { res, json } = await callGet();
+    expect(res.status).toBe(200);
+    expect(json.loggingEnabled).toBe(false);
+    expect(json.persistenceAvailable).toBe(true);
+    expect(upsertUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("rejects unauthenticated updates with 401 and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPatch({ loggingEnabled: true });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(upsertUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("persists loggingEnabled via PATCH and returns the updated setting", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    upsertUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const { res, json } = await callPatch({ loggingEnabled: true });
+    expect(res.status).toBe(200);
+    expect(json.loggingEnabled).toBe(true);
+    expect(json.persistenceAvailable).toBe(true);
+    expect(upsertUserSettings).toHaveBeenCalledWith({}, "user_123", true);
+  });
+});
+
diff --git a/src/app/api/user-settings/route.ts b/src/app/api/user-settings/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..370e41418b9539b44e9aaad5fc5f9405b260485b
--- /dev/null
+++ b/src/app/api/user-settings/route.ts
@@ -0,0 +1,77 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { getUserSettings, upsertUserSettings } from "@/lib/db/user-settings";
+
+export const runtime = "nodejs";
+
+const UpdateUserSettingsSchema = z.object({
+  loggingEnabled: z.boolean(),
+});
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function GET() {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { loggingEnabled: false, persistenceAvailable: false },
+      { status: 200, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const settings = await getUserSettings(db, userId);
+  return NextResponse.json(
+    { loggingEnabled: settings?.loggingEnabled ?? false, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
+export async function PATCH(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { error: "Persistence is disabled." },
+      { status: 503, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = UpdateUserSettingsSchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const updated = await upsertUserSettings(db, userId, parsed.data.loggingEnabled);
+  return NextResponse.json(
+    { loggingEnabled: updated?.loggingEnabled ?? parsed.data.loggingEnabled, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 9db92fbfddf12094c87fc753d64f71213afd6e34..c15ee53a0f7867aac39de17be6efd381c554ce0b
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -533,11 +533,13 @@
 export function BlacklistChecker() {
   const m = getMessages("en");
   const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
+  const { isLoaded: authLoaded, isSignedIn } = useAuth();
 
   const [address, setAddress] = React.useState("");
   const [validation, setValidation] = React.useState<ReturnType<typeof validateTronAddress> | null>(null);
   const [load, setLoad] = React.useState<LoadState>({ state: "idle" });
   const [loggingEnabled, setLoggingEnabled] = React.useState(false);
+  const fetchedServerLoggingPref = React.useRef(false);
 
   React.useEffect(() => {
     const handle = window.setTimeout(() => {
@@ -551,6 +553,35 @@
     setLoggingEnabled(readLocalLoggingPref());
   }, []);
 
+  React.useEffect(() => {
+    if (!clerkEnabled) return;
+    if (!authLoaded) return;
+    if (!isSignedIn) {
+      fetchedServerLoggingPref.current = false;
+      return;
+    }
+    if (fetchedServerLoggingPref.current) return;
+    fetchedServerLoggingPref.current = true;
+
+    const controller = new AbortController();
+    void (async () => {
+      try {
+        const res = await fetch("/api/user-settings", { method: "GET", credentials: "include", signal: controller.signal });
+        if (!res.ok) return;
+        const json = (await res.json()) as unknown;
+        if (!json || typeof json !== "object") return;
+        const v = (json as Record<string, unknown>).loggingEnabled;
+        if (typeof v !== "boolean") return;
+        setLoggingEnabled(v);
+        writeLocalLoggingPref(v);
+      } catch {
+        // ignore
+      }
+    })();
+
+    return () => controller.abort();
+  }, [clerkEnabled, authLoaded, isSignedIn]);
+
   const normalizedAddress = validation?.normalized ?? address.trim();
   const isValid = validation?.ok ?? false;
 
@@ -881,18 +912,18 @@
               transition={{ duration: 0.4, delay: 0.18 }}
               className="mx-auto mt-4 max-w-2xl"
             >
-              <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+                  <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
                 <CardHeader className="pb-3">
                   <CardTitle className="text-base">Account</CardTitle>
                   <CardDescription>
-                    Configure privacy defaults. Saving reports is not enabled yet (DB/credits work is next).
+                    Configure privacy defaults. Report saving is opt-in and controlled by this setting.
                   </CardDescription>
                 </CardHeader>
                 <CardContent className="flex items-start justify-between gap-4">
                   <div className="min-w-0">
                     <div className="text-sm font-medium text-foreground">Opt-in: save screening history</div>
                     <div className="mt-1 text-sm text-muted-foreground">
-                      This currently stores only a local preference. No server-side address logging is performed yet.
+                      This setting is saved to your account. Screening history persistence remains opt-in.
                     </div>
                   </div>
                   <Switch
@@ -900,7 +931,33 @@
                     onCheckedChange={(v) => {
                       setLoggingEnabled(v);
                       writeLocalLoggingPref(v);
-                      toast.message(v ? "Logging preference enabled (local only)" : "Logging preference disabled");
+
+                      void (async () => {
+                        try {
+                          const res = await fetch("/api/user-settings", {
+                            method: "PATCH",
+                            headers: { "content-type": "application/json" },
+                            credentials: "include",
+                            body: JSON.stringify({ loggingEnabled: v }),
+                          });
+
+                          if (!res.ok) throw new Error(`Request failed (${res.status}).`);
+                          const json = (await res.json()) as unknown;
+                          const value =
+                            json && typeof json === "object" ? (json as Record<string, unknown>).loggingEnabled : undefined;
+                          if (typeof value === "boolean") {
+                            setLoggingEnabled(value);
+                            writeLocalLoggingPref(value);
+                          }
+
+                          toast.message(v ? "Saving preference enabled" : "Saving preference disabled");
+                        } catch {
+                          const revert = !v;
+                          setLoggingEnabled(revert);
+                          writeLocalLoggingPref(revert);
+                          toast.message("Could not update preference. Please try again.");
+                        }
+                      })();
                     }}
                     aria-label="Enable saving screening history"
                   />




thinking
**Clarifying commit steps**

I'm trying to sort through the commit process. It looks like I need to commit changes first, then update progress and commit that as well. There's something about all changes needing to be committed, including logs. But if I commit before updating progress, that might require a second commit. The order suggests I should append progress after the initial commit, but it’s confusing. Maybe they just want two commits or to amend the first one? It's tricky!
thinking
**Sorting commit instructions**

I'm trying to interpret the commit instructions clearly. It seems like the initial commit should include code changes. After that, I’d update the progress.md file, but step 10 wants everything staged and committed first. I worry that since step 11 is after the initial commit, the progress entry won't be committed, which goes against the rule that all changes must be committed. Maybe I can do a second commit for the progress entry, but I need to stick to the order given!
thinking
**Clarifying commit requirements**

I'm trying to figure out the requirements regarding commits. The requirement states that all changes must be committed, and I think I may need a second commit just for progress.md and the activity log. But step 10 mentions staging everything first, which could lead to extra work if I'm doing it twice. It’s tricky because step 11 doesn’t explicitly say to commit the progress entry, yet earlier they note all changes need to be committed. I need to check if progress.md even exists to understand better!
exec
/bin/zsh -lc 'ls -la .ralph/progress.md && tail -n 40 .ralph/progress.md' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 65ms:
-rw-r--r--@ 1 chiko  staff  5581 Jan 23 05:25 .ralph/progress.md
Run: 20260123-044356-6274 (iteration 3)
Run log: /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-044356-6274-iter-3.log
Run summary: /Users/chiko/side_projects/usdt_blacklisted_web/.ralph/runs/run-20260123-044356-6274-iter-3.md
- Guardrails reviewed: yes
- No-commit run: false
- Commit: 6e30910 feat(db): add address hashing and scoped queries
- Post-commit status: clean
- Verification:
  - Command: pnpm lint -> PASS
  - Command: pnpm test -> PASS
  - Command: pnpm build -> PASS
- Files changed:
  - ralph
  - src/lib/db/index.ts
  - src/lib/db/schema.ts
  - src/lib/db/address-hash.ts
  - src/lib/db/user-settings.ts
  - src/lib/db/saved-reports.ts
  - src/lib/db/watchlist.ts
file update:
diff --git a/middleware.ts b/middleware.ts
index 9009ef94a93548a37928fbb79db4d17573dde8b0..6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c
--- a/middleware.ts
+++ b/middleware.ts
@@ -7,6 +7,7 @@
   "/",
   "/api/check",
   "/api/analyze",
+  "/api/user-settings",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-user-settings.test.ts b/src/__tests__/api-user-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..206dc68b6524190c6007f00b602147edc7b72713
--- /dev/null
+++ b/src/__tests__/api-user-settings.test.ts
@@ -0,0 +1,82 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+const upsertUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings, upsertUserSettings }));
+
+async function callGet() {
+  const { GET } = await import("@/app/api/user-settings/route");
+  const res = await GET();
+  const json = await res.json();
+  return { res, json };
+}
+
+async function callPatch(body: unknown) {
+  const { PATCH } = await import("@/app/api/user-settings/route");
+  const req = new Request("http://localhost/api/user-settings", {
+    method: "PATCH",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await PATCH(req);
+  const json = await res.json();
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+});
+
+describe("/api/user-settings", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callGet();
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("returns loggingEnabled=false when no row exists (default)", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue(null);
+
+    const { res, json } = await callGet();
+    expect(res.status).toBe(200);
+    expect(json.loggingEnabled).toBe(false);
+    expect(json.persistenceAvailable).toBe(true);
+    expect(upsertUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("rejects unauthenticated updates with 401 and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPatch({ loggingEnabled: true });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(upsertUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("persists loggingEnabled via PATCH and returns the updated setting", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    upsertUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const { res, json } = await callPatch({ loggingEnabled: true });
+    expect(res.status).toBe(200);
+    expect(json.loggingEnabled).toBe(true);
+    expect(json.persistenceAvailable).toBe(true);
+    expect(upsertUserSettings).toHaveBeenCalledWith({}, "user_123", true);
+  });
+});
+
diff --git a/src/app/api/user-settings/route.ts b/src/app/api/user-settings/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..370e41418b9539b44e9aaad5fc5f9405b260485b
--- /dev/null
+++ b/src/app/api/user-settings/route.ts
@@ -0,0 +1,77 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { getUserSettings, upsertUserSettings } from "@/lib/db/user-settings";
+
+export const runtime = "nodejs";
+
+const UpdateUserSettingsSchema = z.object({
+  loggingEnabled: z.boolean(),
+});
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function GET() {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { loggingEnabled: false, persistenceAvailable: false },
+      { status: 200, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const settings = await getUserSettings(db, userId);
+  return NextResponse.json(
+    { loggingEnabled: settings?.loggingEnabled ?? false, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
+export async function PATCH(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { error: "Persistence is disabled." },
+      { status: 503, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = UpdateUserSettingsSchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const updated = await upsertUserSettings(db, userId, parsed.data.loggingEnabled);
+  return NextResponse.json(
+    { loggingEnabled: updated?.loggingEnabled ?? parsed.data.loggingEnabled, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 9db92fbfddf12094c87fc753d64f71213afd6e34..c15ee53a0f7867aac39de17be6efd381c554ce0b
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -533,11 +533,13 @@
 export function BlacklistChecker() {
   const m = getMessages("en");
   const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
+  const { isLoaded: authLoaded, isSignedIn } = useAuth();
 
   const [address, setAddress] = React.useState("");
   const [validation, setValidation] = React.useState<ReturnType<typeof validateTronAddress> | null>(null);
   const [load, setLoad] = React.useState<LoadState>({ state: "idle" });
   const [loggingEnabled, setLoggingEnabled] = React.useState(false);
+  const fetchedServerLoggingPref = React.useRef(false);
 
   React.useEffect(() => {
     const handle = window.setTimeout(() => {
@@ -551,6 +553,35 @@
     setLoggingEnabled(readLocalLoggingPref());
   }, []);
 
+  React.useEffect(() => {
+    if (!clerkEnabled) return;
+    if (!authLoaded) return;
+    if (!isSignedIn) {
+      fetchedServerLoggingPref.current = false;
+      return;
+    }
+    if (fetchedServerLoggingPref.current) return;
+    fetchedServerLoggingPref.current = true;
+
+    const controller = new AbortController();
+    void (async () => {
+      try {
+        const res = await fetch("/api/user-settings", { method: "GET", credentials: "include", signal: controller.signal });
+        if (!res.ok) return;
+        const json = (await res.json()) as unknown;
+        if (!json || typeof json !== "object") return;
+        const v = (json as Record<string, unknown>).loggingEnabled;
+        if (typeof v !== "boolean") return;
+        setLoggingEnabled(v);
+        writeLocalLoggingPref(v);
+      } catch {
+        // ignore
+      }
+    })();
+
+    return () => controller.abort();
+  }, [clerkEnabled, authLoaded, isSignedIn]);
+
   const normalizedAddress = validation?.normalized ?? address.trim();
   const isValid = validation?.ok ?? false;
 
@@ -881,18 +912,18 @@
               transition={{ duration: 0.4, delay: 0.18 }}
               className="mx-auto mt-4 max-w-2xl"
             >
-              <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+                  <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
                 <CardHeader className="pb-3">
                   <CardTitle className="text-base">Account</CardTitle>
                   <CardDescription>
-                    Configure privacy defaults. Saving reports is not enabled yet (DB/credits work is next).
+                    Configure privacy defaults. Report saving is opt-in and controlled by this setting.
                   </CardDescription>
                 </CardHeader>
                 <CardContent className="flex items-start justify-between gap-4">
                   <div className="min-w-0">
                     <div className="text-sm font-medium text-foreground">Opt-in: save screening history</div>
                     <div className="mt-1 text-sm text-muted-foreground">
-                      This currently stores only a local preference. No server-side address logging is performed yet.
+                      This setting is saved to your account. Screening history persistence remains opt-in.
                     </div>
                   </div>
                   <Switch
@@ -900,7 +931,33 @@
                     onCheckedChange={(v) => {
                       setLoggingEnabled(v);
                       writeLocalLoggingPref(v);
-                      toast.message(v ? "Logging preference enabled (local only)" : "Logging preference disabled");
+
+                      void (async () => {
+                        try {
+                          const res = await fetch("/api/user-settings", {
+                            method: "PATCH",
+                            headers: { "content-type": "application/json" },
+                            credentials: "include",
+                            body: JSON.stringify({ loggingEnabled: v }),
+                          });
+
+                          if (!res.ok) throw new Error(`Request failed (${res.status}).`);
+                          const json = (await res.json()) as unknown;
+                          const value =
+                            json && typeof json === "object" ? (json as Record<string, unknown>).loggingEnabled : undefined;
+                          if (typeof value === "boolean") {
+                            setLoggingEnabled(value);
+                            writeLocalLoggingPref(value);
+                          }
+
+                          toast.message(v ? "Saving preference enabled" : "Saving preference disabled");
+                        } catch {
+                          const revert = !v;
+                          setLoggingEnabled(revert);
+                          writeLocalLoggingPref(revert);
+                          toast.message("Could not update preference. Please try again.");
+                        }
+                      })();
                     }}
                     aria-label="Enable saving screening history"
                   />




thinking
**Evaluating commit process**

I'm working with progress.md, and the last entry is iteration 3. Step 11 involves appending an entry after committing, but to keep progress.md committed, I could write it before the commit. However, the order indicates it should be after. Maybe it’s better to commit the code first and then update progress, but that would leave an uncommitted file. Past errors suggest I should include progress.md in the commit. Perhaps I could do two commits: one for code and tests, then another for the progress update.
thinking
**Clarifying commit steps**

I need to commit the progress entry after step 11, even though it's not explicitly required. However, this might create an issue. The requirement from step 10 states that the status should be clean after committing. This will be true after the first commit, but step 11 will leave the tree dirty. To avoid uncommitted changes, I'm planning to commit the code changes first, append to progress.md, and then create a second commit for updating the logs. The rules state all changes made during the run must be committed, implying everything should be finalized by the end.
thinking
**Planning commits and updates**

I'm deciding to do two commits and will use the $commit skill to ensure that I'm following the required message format. I’ll likely use this skill for both commits, since the requirement specifies to use it for all changes. Also, there are updates to the PRD JSON regarding statuses, but I should commit those too. Now I need to check for modifications in `.ralph/runs/run-...iter-3.*`, which seem significant, as well as see if I need to update the `.ralph/runs/run-...iter-4.md` file, since only iter-4.log is currently untracked. I should also verify the existence of the run summary path for iter-4.
exec
/bin/zsh -lc 'ls -la .ralph/runs | tail -n 20' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 56ms:
total 9888
drwxr-xr-x@ 9 chiko  staff      288 Jan 23 05:30 .
drwxr-xr-x@ 8 chiko  staff      256 Jan 23 04:25 ..
-rw-r--r--@ 1 chiko  staff   508765 Jan 23 04:55 run-20260123-044356-6274-iter-1.log
-rw-r--r--@ 1 chiko  staff     1739 Jan 23 04:55 run-20260123-044356-6274-iter-1.md
-rw-r--r--@ 1 chiko  staff  1910349 Jan 23 05:11 run-20260123-044356-6274-iter-2.log
-rw-r--r--@ 1 chiko  staff     1315 Jan 23 05:11 run-20260123-044356-6274-iter-2.md
-rw-r--r--@ 1 chiko  staff  1082739 Jan 23 05:30 run-20260123-044356-6274-iter-3.log
-rw-r--r--@ 1 chiko  staff     1589 Jan 23 05:30 run-20260123-044356-6274-iter-3.md
-rw-r--r--@ 1 chiko  staff   310010 Jan 23 05:37 run-20260123-044356-6274-iter-4.log
file update:
diff --git a/middleware.ts b/middleware.ts
index 9009ef94a93548a37928fbb79db4d17573dde8b0..6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c
--- a/middleware.ts
+++ b/middleware.ts
@@ -7,6 +7,7 @@
   "/",
   "/api/check",
   "/api/analyze",
+  "/api/user-settings",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-user-settings.test.ts b/src/__tests__/api-user-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..206dc68b6524190c6007f00b602147edc7b72713
--- /dev/null
+++ b/src/__tests__/api-user-settings.test.ts
@@ -0,0 +1,82 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+const upsertUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings, upsertUserSettings }));
+
+async function callGet() {
+  const { GET } = await import("@/app/api/user-settings/route");
+  const res = await GET();
+  const json = await res.json();
+  return { res, json };
+}
+
+async function callPatch(body: unknown) {
+  const { PATCH } = await import("@/app/api/user-settings/route");
+  const req = new Request("http://localhost/api/user-settings", {
+    method: "PATCH",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await PATCH(req);
+  const json = await res.json();
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+});
+
+describe("/api/user-settings", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callGet();
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("returns loggingEnabled=false when no row exists (default)", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue(null);
+
+    const { res, json } = await callGet();
+    expect(res.status).toBe(200);
+    expect(json.loggingEnabled).toBe(false);
+    expect(json.persistenceAvailable).toBe(true);
+    expect(upsertUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("rejects unauthenticated updates with 401 and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPatch({ loggingEnabled: true });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(upsertUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("persists loggingEnabled via PATCH and returns the updated setting", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    upsertUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const { res, json } = await callPatch({ loggingEnabled: true });
+    expect(res.status).toBe(200);
+    expect(json.loggingEnabled).toBe(true);
+    expect(json.persistenceAvailable).toBe(true);
+    expect(upsertUserSettings).toHaveBeenCalledWith({}, "user_123", true);
+  });
+});
+
diff --git a/src/app/api/user-settings/route.ts b/src/app/api/user-settings/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..370e41418b9539b44e9aaad5fc5f9405b260485b
--- /dev/null
+++ b/src/app/api/user-settings/route.ts
@@ -0,0 +1,77 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { getUserSettings, upsertUserSettings } from "@/lib/db/user-settings";
+
+export const runtime = "nodejs";
+
+const UpdateUserSettingsSchema = z.object({
+  loggingEnabled: z.boolean(),
+});
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function GET() {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { loggingEnabled: false, persistenceAvailable: false },
+      { status: 200, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const settings = await getUserSettings(db, userId);
+  return NextResponse.json(
+    { loggingEnabled: settings?.loggingEnabled ?? false, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
+export async function PATCH(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { error: "Persistence is disabled." },
+      { status: 503, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = UpdateUserSettingsSchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const updated = await upsertUserSettings(db, userId, parsed.data.loggingEnabled);
+  return NextResponse.json(
+    { loggingEnabled: updated?.loggingEnabled ?? parsed.data.loggingEnabled, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 9db92fbfddf12094c87fc753d64f71213afd6e34..c15ee53a0f7867aac39de17be6efd381c554ce0b
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -533,11 +533,13 @@
 export function BlacklistChecker() {
   const m = getMessages("en");
   const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
+  const { isLoaded: authLoaded, isSignedIn } = useAuth();
 
   const [address, setAddress] = React.useState("");
   const [validation, setValidation] = React.useState<ReturnType<typeof validateTronAddress> | null>(null);
   const [load, setLoad] = React.useState<LoadState>({ state: "idle" });
   const [loggingEnabled, setLoggingEnabled] = React.useState(false);
+  const fetchedServerLoggingPref = React.useRef(false);
 
   React.useEffect(() => {
     const handle = window.setTimeout(() => {
@@ -551,6 +553,35 @@
     setLoggingEnabled(readLocalLoggingPref());
   }, []);
 
+  React.useEffect(() => {
+    if (!clerkEnabled) return;
+    if (!authLoaded) return;
+    if (!isSignedIn) {
+      fetchedServerLoggingPref.current = false;
+      return;
+    }
+    if (fetchedServerLoggingPref.current) return;
+    fetchedServerLoggingPref.current = true;
+
+    const controller = new AbortController();
+    void (async () => {
+      try {
+        const res = await fetch("/api/user-settings", { method: "GET", credentials: "include", signal: controller.signal });
+        if (!res.ok) return;
+        const json = (await res.json()) as unknown;
+        if (!json || typeof json !== "object") return;
+        const v = (json as Record<string, unknown>).loggingEnabled;
+        if (typeof v !== "boolean") return;
+        setLoggingEnabled(v);
+        writeLocalLoggingPref(v);
+      } catch {
+        // ignore
+      }
+    })();
+
+    return () => controller.abort();
+  }, [clerkEnabled, authLoaded, isSignedIn]);
+
   const normalizedAddress = validation?.normalized ?? address.trim();
   const isValid = validation?.ok ?? false;
 
@@ -881,18 +912,18 @@
               transition={{ duration: 0.4, delay: 0.18 }}
               className="mx-auto mt-4 max-w-2xl"
             >
-              <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+                  <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
                 <CardHeader className="pb-3">
                   <CardTitle className="text-base">Account</CardTitle>
                   <CardDescription>
-                    Configure privacy defaults. Saving reports is not enabled yet (DB/credits work is next).
+                    Configure privacy defaults. Report saving is opt-in and controlled by this setting.
                   </CardDescription>
                 </CardHeader>
                 <CardContent className="flex items-start justify-between gap-4">
                   <div className="min-w-0">
                     <div className="text-sm font-medium text-foreground">Opt-in: save screening history</div>
                     <div className="mt-1 text-sm text-muted-foreground">
-                      This currently stores only a local preference. No server-side address logging is performed yet.
+                      This setting is saved to your account. Screening history persistence remains opt-in.
                     </div>
                   </div>
                   <Switch
@@ -900,7 +931,33 @@
                     onCheckedChange={(v) => {
                       setLoggingEnabled(v);
                       writeLocalLoggingPref(v);
-                      toast.message(v ? "Logging preference enabled (local only)" : "Logging preference disabled");
+
+                      void (async () => {
+                        try {
+                          const res = await fetch("/api/user-settings", {
+                            method: "PATCH",
+                            headers: { "content-type": "application/json" },
+                            credentials: "include",
+                            body: JSON.stringify({ loggingEnabled: v }),
+                          });
+
+                          if (!res.ok) throw new Error(`Request failed (${res.status}).`);
+                          const json = (await res.json()) as unknown;
+                          const value =
+                            json && typeof json === "object" ? (json as Record<string, unknown>).loggingEnabled : undefined;
+                          if (typeof value === "boolean") {
+                            setLoggingEnabled(value);
+                            writeLocalLoggingPref(value);
+                          }
+
+                          toast.message(v ? "Saving preference enabled" : "Saving preference disabled");
+                        } catch {
+                          const revert = !v;
+                          setLoggingEnabled(revert);
+                          writeLocalLoggingPref(revert);
+                          toast.message("Could not update preference. Please try again.");
+                        }
+                      })();
                     }}
                     aria-label="Enable saving screening history"
                   />

exec
/bin/zsh -lc "sed -n '1,200p' /Users/chiko/.codex/skills/commit/SKILL.md" in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 84ms:
---
name: commit
description: Write conventional commit messages with type, scope, and subject when the user wants to commit changes or save work.
---

# Git Commit

Creates git commits following Conventional Commits format with proper type, scope, and subject.

## Quick Start

```bash
# 1. Stage changes
git add <files>  # or: git add -A

# 2. Create commit (branch commit format)
git commit -m "type(scope): subject

Body explaining HOW and WHY.
Reference: Task X.Y, Req N"
file update:
diff --git a/middleware.ts b/middleware.ts
index 9009ef94a93548a37928fbb79db4d17573dde8b0..6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c
--- a/middleware.ts
+++ b/middleware.ts
@@ -7,6 +7,7 @@
   "/",
   "/api/check",
   "/api/analyze",
+  "/api/user-settings",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-user-settings.test.ts b/src/__tests__/api-user-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..206dc68b6524190c6007f00b602147edc7b72713
--- /dev/null
+++ b/src/__tests__/api-user-settings.test.ts
@@ -0,0 +1,82 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+const upsertUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings, upsertUserSettings }));
+
+async function callGet() {
+  const { GET } = await import("@/app/api/user-settings/route");
+  const res = await GET();
+  const json = await res.json();
+  return { res, json };
+}
+
+async function callPatch(body: unknown) {
+  const { PATCH } = await import("@/app/api/user-settings/route");
+  const req = new Request("http://localhost/api/user-settings", {
+    method: "PATCH",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await PATCH(req);
+  const json = await res.json();
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+});
+
+describe("/api/user-settings", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callGet();
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("returns loggingEnabled=false when no row exists (default)", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue(null);
+
+    const { res, json } = await callGet();
+    expect(res.status).toBe(200);
+    expect(json.loggingEnabled).toBe(false);
+    expect(json.persistenceAvailable).toBe(true);
+    expect(upsertUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("rejects unauthenticated updates with 401 and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPatch({ loggingEnabled: true });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(upsertUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("persists loggingEnabled via PATCH and returns the updated setting", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    upsertUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const { res, json } = await callPatch({ loggingEnabled: true });
+    expect(res.status).toBe(200);
+    expect(json.loggingEnabled).toBe(true);
+    expect(json.persistenceAvailable).toBe(true);
+    expect(upsertUserSettings).toHaveBeenCalledWith({}, "user_123", true);
+  });
+});
+
diff --git a/src/app/api/user-settings/route.ts b/src/app/api/user-settings/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..370e41418b9539b44e9aaad5fc5f9405b260485b
--- /dev/null
+++ b/src/app/api/user-settings/route.ts
@@ -0,0 +1,77 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { getUserSettings, upsertUserSettings } from "@/lib/db/user-settings";
+
+export const runtime = "nodejs";
+
+const UpdateUserSettingsSchema = z.object({
+  loggingEnabled: z.boolean(),
+});
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function GET() {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { loggingEnabled: false, persistenceAvailable: false },
+      { status: 200, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const settings = await getUserSettings(db, userId);
+  return NextResponse.json(
+    { loggingEnabled: settings?.loggingEnabled ?? false, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
+export async function PATCH(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { error: "Persistence is disabled." },
+      { status: 503, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = UpdateUserSettingsSchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const updated = await upsertUserSettings(db, userId, parsed.data.loggingEnabled);
+  return NextResponse.json(
+    { loggingEnabled: updated?.loggingEnabled ?? parsed.data.loggingEnabled, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 9db92fbfddf12094c87fc753d64f71213afd6e34..c15ee53a0f7867aac39de17be6efd381c554ce0b
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -533,11 +533,13 @@
 export function BlacklistChecker() {
   const m = getMessages("en");
   const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
+  const { isLoaded: authLoaded, isSignedIn } = useAuth();
 
   const [address, setAddress] = React.useState("");
   const [validation, setValidation] = React.useState<ReturnType<typeof validateTronAddress> | null>(null);
   const [load, setLoad] = React.useState<LoadState>({ state: "idle" });
   const [loggingEnabled, setLoggingEnabled] = React.useState(false);
+  const fetchedServerLoggingPref = React.useRef(false);
 
   React.useEffect(() => {
     const handle = window.setTimeout(() => {
@@ -551,6 +553,35 @@
     setLoggingEnabled(readLocalLoggingPref());
   }, []);
 
+  React.useEffect(() => {
+    if (!clerkEnabled) return;
+    if (!authLoaded) return;
+    if (!isSignedIn) {
+      fetchedServerLoggingPref.current = false;
+      return;
+    }
+    if (fetchedServerLoggingPref.current) return;
+    fetchedServerLoggingPref.current = true;
+
+    const controller = new AbortController();
+    void (async () => {
+      try {
+        const res = await fetch("/api/user-settings", { method: "GET", credentials: "include", signal: controller.signal });
+        if (!res.ok) return;
+        const json = (await res.json()) as unknown;
+        if (!json || typeof json !== "object") return;
+        const v = (json as Record<string, unknown>).loggingEnabled;
+        if (typeof v !== "boolean") return;
+        setLoggingEnabled(v);
+        writeLocalLoggingPref(v);
+      } catch {
+        // ignore
+      }
+    })();
+
+    return () => controller.abort();
+  }, [clerkEnabled, authLoaded, isSignedIn]);
+
   const normalizedAddress = validation?.normalized ?? address.trim();
   const isValid = validation?.ok ?? false;
 
@@ -881,18 +912,18 @@
               transition={{ duration: 0.4, delay: 0.18 }}
               className="mx-auto mt-4 max-w-2xl"
             >
-              <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+                  <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
                 <CardHeader className="pb-3">
                   <CardTitle className="text-base">Account</CardTitle>
                   <CardDescription>
-                    Configure privacy defaults. Saving reports is not enabled yet (DB/credits work is next).
+                    Configure privacy defaults. Report saving is opt-in and controlled by this setting.
                   </CardDescription>
                 </CardHeader>
                 <CardContent className="flex items-start justify-between gap-4">
                   <div className="min-w-0">
                     <div className="text-sm font-medium text-foreground">Opt-in: save screening history</div>
                     <div className="mt-1 text-sm text-muted-foreground">
-                      This currently stores only a local preference. No server-side address logging is performed yet.
+                      This setting is saved to your account. Screening history persistence remains opt-in.
                     </div>
                   </div>
                   <Switch
@@ -900,7 +931,33 @@
                     onCheckedChange={(v) => {
                       setLoggingEnabled(v);
                       writeLocalLoggingPref(v);
-                      toast.message(v ? "Logging preference enabled (local only)" : "Logging preference disabled");
+
+                      void (async () => {
+                        try {
+                          const res = await fetch("/api/user-settings", {
+                            method: "PATCH",
+                            headers: { "content-type": "application/json" },
+                            credentials: "include",
+                            body: JSON.stringify({ loggingEnabled: v }),
+                          });
+
+                          if (!res.ok) throw new Error(`Request failed (${res.status}).`);
+                          const json = (await res.json()) as unknown;
+                          const value =
+                            json && typeof json === "object" ? (json as Record<string, unknown>).loggingEnabled : undefined;
+                          if (typeof value === "boolean") {
+                            setLoggingEnabled(value);
+                            writeLocalLoggingPref(value);
+                          }
+
+                          toast.message(v ? "Saving preference enabled" : "Saving preference disabled");
+                        } catch {
+                          const revert = !v;
+                          setLoggingEnabled(revert);
+                          writeLocalLoggingPref(revert);
+                          toast.message("Could not update preference. Please try again.");
+                        }
+                      })();
                     }}
                     aria-label="Enable saving screening history"
                   />


thinking
I'm planning to stage all changes, including logs. That feels significant, but I see that previous progress entries mention similar steps, so I'm not too worried. It’s reassuring to know I'm on the right track. Now, I think it's a good time to go ahead and stage everything. Let's get this done!
exec
/bin/zsh -lc 'git add -A' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 93ms:

file update:
diff --git a/middleware.ts b/middleware.ts
index 9009ef94a93548a37928fbb79db4d17573dde8b0..6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c
--- a/middleware.ts
+++ b/middleware.ts
@@ -7,6 +7,7 @@
   "/",
   "/api/check",
   "/api/analyze",
+  "/api/user-settings",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-user-settings.test.ts b/src/__tests__/api-user-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..206dc68b6524190c6007f00b602147edc7b72713
--- /dev/null
+++ b/src/__tests__/api-user-settings.test.ts
@@ -0,0 +1,82 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+const upsertUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings, upsertUserSettings }));
+
+async function callGet() {
+  const { GET } = await import("@/app/api/user-settings/route");
+  const res = await GET();
+  const json = await res.json();
+  return { res, json };
+}
+
+async function callPatch(body: unknown) {
+  const { PATCH } = await import("@/app/api/user-settings/route");
+  const req = new Request("http://localhost/api/user-settings", {
+    method: "PATCH",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await PATCH(req);
+  const json = await res.json();
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+});
+
+describe("/api/user-settings", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callGet();
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("returns loggingEnabled=false when no row exists (default)", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue(null);
+
+    const { res, json } = await callGet();
+    expect(res.status).toBe(200);
+    expect(json.loggingEnabled).toBe(false);
+    expect(json.persistenceAvailable).toBe(true);
+    expect(upsertUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("rejects unauthenticated updates with 401 and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPatch({ loggingEnabled: true });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(upsertUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("persists loggingEnabled via PATCH and returns the updated setting", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    upsertUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const { res, json } = await callPatch({ loggingEnabled: true });
+    expect(res.status).toBe(200);
+    expect(json.loggingEnabled).toBe(true);
+    expect(json.persistenceAvailable).toBe(true);
+    expect(upsertUserSettings).toHaveBeenCalledWith({}, "user_123", true);
+  });
+});
+
diff --git a/src/app/api/user-settings/route.ts b/src/app/api/user-settings/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..370e41418b9539b44e9aaad5fc5f9405b260485b
--- /dev/null
+++ b/src/app/api/user-settings/route.ts
@@ -0,0 +1,77 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { getUserSettings, upsertUserSettings } from "@/lib/db/user-settings";
+
+export const runtime = "nodejs";
+
+const UpdateUserSettingsSchema = z.object({
+  loggingEnabled: z.boolean(),
+});
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function GET() {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { loggingEnabled: false, persistenceAvailable: false },
+      { status: 200, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const settings = await getUserSettings(db, userId);
+  return NextResponse.json(
+    { loggingEnabled: settings?.loggingEnabled ?? false, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
+export async function PATCH(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { error: "Persistence is disabled." },
+      { status: 503, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = UpdateUserSettingsSchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const updated = await upsertUserSettings(db, userId, parsed.data.loggingEnabled);
+  return NextResponse.json(
+    { loggingEnabled: updated?.loggingEnabled ?? parsed.data.loggingEnabled, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 9db92fbfddf12094c87fc753d64f71213afd6e34..c15ee53a0f7867aac39de17be6efd381c554ce0b
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -533,11 +533,13 @@
 export function BlacklistChecker() {
   const m = getMessages("en");
   const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
+  const { isLoaded: authLoaded, isSignedIn } = useAuth();
 
   const [address, setAddress] = React.useState("");
   const [validation, setValidation] = React.useState<ReturnType<typeof validateTronAddress> | null>(null);
   const [load, setLoad] = React.useState<LoadState>({ state: "idle" });
   const [loggingEnabled, setLoggingEnabled] = React.useState(false);
+  const fetchedServerLoggingPref = React.useRef(false);
 
   React.useEffect(() => {
     const handle = window.setTimeout(() => {
@@ -551,6 +553,35 @@
     setLoggingEnabled(readLocalLoggingPref());
   }, []);
 
+  React.useEffect(() => {
+    if (!clerkEnabled) return;
+    if (!authLoaded) return;
+    if (!isSignedIn) {
+      fetchedServerLoggingPref.current = false;
+      return;
+    }
+    if (fetchedServerLoggingPref.current) return;
+    fetchedServerLoggingPref.current = true;
+
+    const controller = new AbortController();
+    void (async () => {
+      try {
+        const res = await fetch("/api/user-settings", { method: "GET", credentials: "include", signal: controller.signal });
+        if (!res.ok) return;
+        const json = (await res.json()) as unknown;
+        if (!json || typeof json !== "object") return;
+        const v = (json as Record<string, unknown>).loggingEnabled;
+        if (typeof v !== "boolean") return;
+        setLoggingEnabled(v);
+        writeLocalLoggingPref(v);
+      } catch {
+        // ignore
+      }
+    })();
+
+    return () => controller.abort();
+  }, [clerkEnabled, authLoaded, isSignedIn]);
+
   const normalizedAddress = validation?.normalized ?? address.trim();
   const isValid = validation?.ok ?? false;
 
@@ -881,18 +912,18 @@
               transition={{ duration: 0.4, delay: 0.18 }}
               className="mx-auto mt-4 max-w-2xl"
             >
-              <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+                  <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
                 <CardHeader className="pb-3">
                   <CardTitle className="text-base">Account</CardTitle>
                   <CardDescription>
-                    Configure privacy defaults. Saving reports is not enabled yet (DB/credits work is next).
+                    Configure privacy defaults. Report saving is opt-in and controlled by this setting.
                   </CardDescription>
                 </CardHeader>
                 <CardContent className="flex items-start justify-between gap-4">
                   <div className="min-w-0">
                     <div className="text-sm font-medium text-foreground">Opt-in: save screening history</div>
                     <div className="mt-1 text-sm text-muted-foreground">
-                      This currently stores only a local preference. No server-side address logging is performed yet.
+                      This setting is saved to your account. Screening history persistence remains opt-in.
                     </div>
                   </div>
                   <Switch
@@ -900,7 +931,33 @@
                     onCheckedChange={(v) => {
                       setLoggingEnabled(v);
                       writeLocalLoggingPref(v);
-                      toast.message(v ? "Logging preference enabled (local only)" : "Logging preference disabled");
+
+                      void (async () => {
+                        try {
+                          const res = await fetch("/api/user-settings", {
+                            method: "PATCH",
+                            headers: { "content-type": "application/json" },
+                            credentials: "include",
+                            body: JSON.stringify({ loggingEnabled: v }),
+                          });
+
+                          if (!res.ok) throw new Error(`Request failed (${res.status}).`);
+                          const json = (await res.json()) as unknown;
+                          const value =
+                            json && typeof json === "object" ? (json as Record<string, unknown>).loggingEnabled : undefined;
+                          if (typeof value === "boolean") {
+                            setLoggingEnabled(value);
+                            writeLocalLoggingPref(value);
+                          }
+
+                          toast.message(v ? "Saving preference enabled" : "Saving preference disabled");
+                        } catch {
+                          const revert = !v;
+                          setLoggingEnabled(revert);
+                          writeLocalLoggingPref(revert);
+                          toast.message("Could not update preference. Please try again.");
+                        }
+                      })();
                     }}
                     aria-label="Enable saving screening history"
                   />

exec
/bin/zsh -lc 'git status --porcelain' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 74ms:
M  .agents/tasks/prd-post-mvp.json
A  .ralph/.tmp/prompt-20260123-044356-6274-4.md
A  .ralph/.tmp/story-20260123-044356-6274-4.json
A  .ralph/.tmp/story-20260123-044356-6274-4.md
M  .ralph/activity.log
M  .ralph/errors.log
M  .ralph/runs/run-20260123-044356-6274-iter-3.log
M  .ralph/runs/run-20260123-044356-6274-iter-3.md
AM .ralph/runs/run-20260123-044356-6274-iter-4.log
M  middleware.ts
A  src/__tests__/api-user-settings.test.ts
A  src/app/api/user-settings/route.ts
M  src/components/blacklist-checker.tsx
file update:
diff --git a/middleware.ts b/middleware.ts
index 9009ef94a93548a37928fbb79db4d17573dde8b0..6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c
--- a/middleware.ts
+++ b/middleware.ts
@@ -7,6 +7,7 @@
   "/",
   "/api/check",
   "/api/analyze",
+  "/api/user-settings",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-user-settings.test.ts b/src/__tests__/api-user-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..206dc68b6524190c6007f00b602147edc7b72713
--- /dev/null
+++ b/src/__tests__/api-user-settings.test.ts
@@ -0,0 +1,82 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+const upsertUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings, upsertUserSettings }));
+
+async function callGet() {
+  const { GET } = await import("@/app/api/user-settings/route");
+  const res = await GET();
+  const json = await res.json();
+  return { res, json };
+}
+
+async function callPatch(body: unknown) {
+  const { PATCH } = await import("@/app/api/user-settings/route");
+  const req = new Request("http://localhost/api/user-settings", {
+    method: "PATCH",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await PATCH(req);
+  const json = await res.json();
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+});
+
+describe("/api/user-settings", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callGet();
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("returns loggingEnabled=false when no row exists (default)", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue(null);
+
+    const { res, json } = await callGet();
+    expect(res.status).toBe(200);
+    expect(json.loggingEnabled).toBe(false);
+    expect(json.persistenceAvailable).toBe(true);
+    expect(upsertUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("rejects unauthenticated updates with 401 and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPatch({ loggingEnabled: true });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(upsertUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("persists loggingEnabled via PATCH and returns the updated setting", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    upsertUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const { res, json } = await callPatch({ loggingEnabled: true });
+    expect(res.status).toBe(200);
+    expect(json.loggingEnabled).toBe(true);
+    expect(json.persistenceAvailable).toBe(true);
+    expect(upsertUserSettings).toHaveBeenCalledWith({}, "user_123", true);
+  });
+});
+
diff --git a/src/app/api/user-settings/route.ts b/src/app/api/user-settings/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..370e41418b9539b44e9aaad5fc5f9405b260485b
--- /dev/null
+++ b/src/app/api/user-settings/route.ts
@@ -0,0 +1,77 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { getUserSettings, upsertUserSettings } from "@/lib/db/user-settings";
+
+export const runtime = "nodejs";
+
+const UpdateUserSettingsSchema = z.object({
+  loggingEnabled: z.boolean(),
+});
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function GET() {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { loggingEnabled: false, persistenceAvailable: false },
+      { status: 200, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const settings = await getUserSettings(db, userId);
+  return NextResponse.json(
+    { loggingEnabled: settings?.loggingEnabled ?? false, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
+export async function PATCH(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { error: "Persistence is disabled." },
+      { status: 503, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = UpdateUserSettingsSchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const updated = await upsertUserSettings(db, userId, parsed.data.loggingEnabled);
+  return NextResponse.json(
+    { loggingEnabled: updated?.loggingEnabled ?? parsed.data.loggingEnabled, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 9db92fbfddf12094c87fc753d64f71213afd6e34..c15ee53a0f7867aac39de17be6efd381c554ce0b
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -533,11 +533,13 @@
 export function BlacklistChecker() {
   const m = getMessages("en");
   const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
+  const { isLoaded: authLoaded, isSignedIn } = useAuth();
 
   const [address, setAddress] = React.useState("");
   const [validation, setValidation] = React.useState<ReturnType<typeof validateTronAddress> | null>(null);
   const [load, setLoad] = React.useState<LoadState>({ state: "idle" });
   const [loggingEnabled, setLoggingEnabled] = React.useState(false);
+  const fetchedServerLoggingPref = React.useRef(false);
 
   React.useEffect(() => {
     const handle = window.setTimeout(() => {
@@ -551,6 +553,35 @@
     setLoggingEnabled(readLocalLoggingPref());
   }, []);
 
+  React.useEffect(() => {
+    if (!clerkEnabled) return;
+    if (!authLoaded) return;
+    if (!isSignedIn) {
+      fetchedServerLoggingPref.current = false;
+      return;
+    }
+    if (fetchedServerLoggingPref.current) return;
+    fetchedServerLoggingPref.current = true;
+
+    const controller = new AbortController();
+    void (async () => {
+      try {
+        const res = await fetch("/api/user-settings", { method: "GET", credentials: "include", signal: controller.signal });
+        if (!res.ok) return;
+        const json = (await res.json()) as unknown;
+        if (!json || typeof json !== "object") return;
+        const v = (json as Record<string, unknown>).loggingEnabled;
+        if (typeof v !== "boolean") return;
+        setLoggingEnabled(v);
+        writeLocalLoggingPref(v);
+      } catch {
+        // ignore
+      }
+    })();
+
+    return () => controller.abort();
+  }, [clerkEnabled, authLoaded, isSignedIn]);
+
   const normalizedAddress = validation?.normalized ?? address.trim();
   const isValid = validation?.ok ?? false;
 
@@ -881,18 +912,18 @@
               transition={{ duration: 0.4, delay: 0.18 }}
               className="mx-auto mt-4 max-w-2xl"
             >
-              <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+                  <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
                 <CardHeader className="pb-3">
                   <CardTitle className="text-base">Account</CardTitle>
                   <CardDescription>
-                    Configure privacy defaults. Saving reports is not enabled yet (DB/credits work is next).
+                    Configure privacy defaults. Report saving is opt-in and controlled by this setting.
                   </CardDescription>
                 </CardHeader>
                 <CardContent className="flex items-start justify-between gap-4">
                   <div className="min-w-0">
                     <div className="text-sm font-medium text-foreground">Opt-in: save screening history</div>
                     <div className="mt-1 text-sm text-muted-foreground">
-                      This currently stores only a local preference. No server-side address logging is performed yet.
+                      This setting is saved to your account. Screening history persistence remains opt-in.
                     </div>
                   </div>
                   <Switch
@@ -900,7 +931,33 @@
                     onCheckedChange={(v) => {
                       setLoggingEnabled(v);
                       writeLocalLoggingPref(v);
-                      toast.message(v ? "Logging preference enabled (local only)" : "Logging preference disabled");
+
+                      void (async () => {
+                        try {
+                          const res = await fetch("/api/user-settings", {
+                            method: "PATCH",
+                            headers: { "content-type": "application/json" },
+                            credentials: "include",
+                            body: JSON.stringify({ loggingEnabled: v }),
+                          });
+
+                          if (!res.ok) throw new Error(`Request failed (${res.status}).`);
+                          const json = (await res.json()) as unknown;
+                          const value =
+                            json && typeof json === "object" ? (json as Record<string, unknown>).loggingEnabled : undefined;
+                          if (typeof value === "boolean") {
+                            setLoggingEnabled(value);
+                            writeLocalLoggingPref(value);
+                          }
+
+                          toast.message(v ? "Saving preference enabled" : "Saving preference disabled");
+                        } catch {
+                          const revert = !v;
+                          setLoggingEnabled(revert);
+                          writeLocalLoggingPref(revert);
+                          toast.message("Could not update preference. Please try again.");
+                        }
+                      })();
                     }}
                     aria-label="Enable saving screening history"
                   />

exec
/bin/zsh -lc '/Users/chiko/side_projects/usdt_blacklisted_web/ralph log "Committing US-004 changes"' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 68ms:

file update:
diff --git a/middleware.ts b/middleware.ts
index 9009ef94a93548a37928fbb79db4d17573dde8b0..6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c
--- a/middleware.ts
+++ b/middleware.ts
@@ -7,6 +7,7 @@
   "/",
   "/api/check",
   "/api/analyze",
+  "/api/user-settings",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-user-settings.test.ts b/src/__tests__/api-user-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..206dc68b6524190c6007f00b602147edc7b72713
--- /dev/null
+++ b/src/__tests__/api-user-settings.test.ts
@@ -0,0 +1,82 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+const upsertUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings, upsertUserSettings }));
+
+async function callGet() {
+  const { GET } = await import("@/app/api/user-settings/route");
+  const res = await GET();
+  const json = await res.json();
+  return { res, json };
+}
+
+async function callPatch(body: unknown) {
+  const { PATCH } = await import("@/app/api/user-settings/route");
+  const req = new Request("http://localhost/api/user-settings", {
+    method: "PATCH",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await PATCH(req);
+  const json = await res.json();
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+});
+
+describe("/api/user-settings", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callGet();
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("returns loggingEnabled=false when no row exists (default)", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue(null);
+
+    const { res, json } = await callGet();
+    expect(res.status).toBe(200);
+    expect(json.loggingEnabled).toBe(false);
+    expect(json.persistenceAvailable).toBe(true);
+    expect(upsertUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("rejects unauthenticated updates with 401 and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPatch({ loggingEnabled: true });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(upsertUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("persists loggingEnabled via PATCH and returns the updated setting", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    upsertUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const { res, json } = await callPatch({ loggingEnabled: true });
+    expect(res.status).toBe(200);
+    expect(json.loggingEnabled).toBe(true);
+    expect(json.persistenceAvailable).toBe(true);
+    expect(upsertUserSettings).toHaveBeenCalledWith({}, "user_123", true);
+  });
+});
+
diff --git a/src/app/api/user-settings/route.ts b/src/app/api/user-settings/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..370e41418b9539b44e9aaad5fc5f9405b260485b
--- /dev/null
+++ b/src/app/api/user-settings/route.ts
@@ -0,0 +1,77 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { getUserSettings, upsertUserSettings } from "@/lib/db/user-settings";
+
+export const runtime = "nodejs";
+
+const UpdateUserSettingsSchema = z.object({
+  loggingEnabled: z.boolean(),
+});
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function GET() {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { loggingEnabled: false, persistenceAvailable: false },
+      { status: 200, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const settings = await getUserSettings(db, userId);
+  return NextResponse.json(
+    { loggingEnabled: settings?.loggingEnabled ?? false, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
+export async function PATCH(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { error: "Persistence is disabled." },
+      { status: 503, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = UpdateUserSettingsSchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const updated = await upsertUserSettings(db, userId, parsed.data.loggingEnabled);
+  return NextResponse.json(
+    { loggingEnabled: updated?.loggingEnabled ?? parsed.data.loggingEnabled, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 9db92fbfddf12094c87fc753d64f71213afd6e34..c15ee53a0f7867aac39de17be6efd381c554ce0b
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -533,11 +533,13 @@
 export function BlacklistChecker() {
   const m = getMessages("en");
   const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
+  const { isLoaded: authLoaded, isSignedIn } = useAuth();
 
   const [address, setAddress] = React.useState("");
   const [validation, setValidation] = React.useState<ReturnType<typeof validateTronAddress> | null>(null);
   const [load, setLoad] = React.useState<LoadState>({ state: "idle" });
   const [loggingEnabled, setLoggingEnabled] = React.useState(false);
+  const fetchedServerLoggingPref = React.useRef(false);
 
   React.useEffect(() => {
     const handle = window.setTimeout(() => {
@@ -551,6 +553,35 @@
     setLoggingEnabled(readLocalLoggingPref());
   }, []);
 
+  React.useEffect(() => {
+    if (!clerkEnabled) return;
+    if (!authLoaded) return;
+    if (!isSignedIn) {
+      fetchedServerLoggingPref.current = false;
+      return;
+    }
+    if (fetchedServerLoggingPref.current) return;
+    fetchedServerLoggingPref.current = true;
+
+    const controller = new AbortController();
+    void (async () => {
+      try {
+        const res = await fetch("/api/user-settings", { method: "GET", credentials: "include", signal: controller.signal });
+        if (!res.ok) return;
+        const json = (await res.json()) as unknown;
+        if (!json || typeof json !== "object") return;
+        const v = (json as Record<string, unknown>).loggingEnabled;
+        if (typeof v !== "boolean") return;
+        setLoggingEnabled(v);
+        writeLocalLoggingPref(v);
+      } catch {
+        // ignore
+      }
+    })();
+
+    return () => controller.abort();
+  }, [clerkEnabled, authLoaded, isSignedIn]);
+
   const normalizedAddress = validation?.normalized ?? address.trim();
   const isValid = validation?.ok ?? false;
 
@@ -881,18 +912,18 @@
               transition={{ duration: 0.4, delay: 0.18 }}
               className="mx-auto mt-4 max-w-2xl"
             >
-              <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+                  <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
                 <CardHeader className="pb-3">
                   <CardTitle className="text-base">Account</CardTitle>
                   <CardDescription>
-                    Configure privacy defaults. Saving reports is not enabled yet (DB/credits work is next).
+                    Configure privacy defaults. Report saving is opt-in and controlled by this setting.
                   </CardDescription>
                 </CardHeader>
                 <CardContent className="flex items-start justify-between gap-4">
                   <div className="min-w-0">
                     <div className="text-sm font-medium text-foreground">Opt-in: save screening history</div>
                     <div className="mt-1 text-sm text-muted-foreground">
-                      This currently stores only a local preference. No server-side address logging is performed yet.
+                      This setting is saved to your account. Screening history persistence remains opt-in.
                     </div>
                   </div>
                   <Switch
@@ -900,7 +931,33 @@
                     onCheckedChange={(v) => {
                       setLoggingEnabled(v);
                       writeLocalLoggingPref(v);
-                      toast.message(v ? "Logging preference enabled (local only)" : "Logging preference disabled");
+
+                      void (async () => {
+                        try {
+                          const res = await fetch("/api/user-settings", {
+                            method: "PATCH",
+                            headers: { "content-type": "application/json" },
+                            credentials: "include",
+                            body: JSON.stringify({ loggingEnabled: v }),
+                          });
+
+                          if (!res.ok) throw new Error(`Request failed (${res.status}).`);
+                          const json = (await res.json()) as unknown;
+                          const value =
+                            json && typeof json === "object" ? (json as Record<string, unknown>).loggingEnabled : undefined;
+                          if (typeof value === "boolean") {
+                            setLoggingEnabled(value);
+                            writeLocalLoggingPref(value);
+                          }
+
+                          toast.message(v ? "Saving preference enabled" : "Saving preference disabled");
+                        } catch {
+                          const revert = !v;
+                          setLoggingEnabled(revert);
+                          writeLocalLoggingPref(revert);
+                          toast.message("Could not update preference. Please try again.");
+                        }
+                      })();
                     }}
                     aria-label="Enable saving screening history"
                   />

exec
/bin/zsh -lc 'git commit -m "feat(settings): persist loggingEnabled per user

Add /api/user-settings (GET/PATCH) for authenticated users.
- Default loggingEnabled=false when no settings row exists
- Reject unauthenticated requests with 401
- Wire the signed-in toggle to read/write server settings"' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 103ms:
[main 5ac0323] feat(settings): persist loggingEnabled per user
 13 files changed, 10074 insertions(+), 14 deletions(-)
 create mode 100644 .ralph/.tmp/prompt-20260123-044356-6274-4.md
 create mode 100644 .ralph/.tmp/story-20260123-044356-6274-4.json
 create mode 100644 .ralph/.tmp/story-20260123-044356-6274-4.md
 create mode 100644 .ralph/runs/run-20260123-044356-6274-iter-4.log
 create mode 100644 src/__tests__/api-user-settings.test.ts
 create mode 100644 src/app/api/user-settings/route.ts
file update:
diff --git a/middleware.ts b/middleware.ts
index 9009ef94a93548a37928fbb79db4d17573dde8b0..6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c
--- a/middleware.ts
+++ b/middleware.ts
@@ -7,6 +7,7 @@
   "/",
   "/api/check",
   "/api/analyze",
+  "/api/user-settings",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-user-settings.test.ts b/src/__tests__/api-user-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..206dc68b6524190c6007f00b602147edc7b72713
--- /dev/null
+++ b/src/__tests__/api-user-settings.test.ts
@@ -0,0 +1,82 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+const upsertUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings, upsertUserSettings }));
+
+async function callGet() {
+  const { GET } = await import("@/app/api/user-settings/route");
+  const res = await GET();
+  const json = await res.json();
+  return { res, json };
+}
+
+async function callPatch(body: unknown) {
+  const { PATCH } = await import("@/app/api/user-settings/route");
+  const req = new Request("http://localhost/api/user-settings", {
+    method: "PATCH",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await PATCH(req);
+  const json = await res.json();
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+});
+
+describe("/api/user-settings", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callGet();
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("returns loggingEnabled=false when no row exists (default)", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue(null);
+
+    const { res, json } = await callGet();
+    expect(res.status).toBe(200);
+    expect(json.loggingEnabled).toBe(false);
+    expect(json.persistenceAvailable).toBe(true);
+    expect(upsertUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("rejects unauthenticated updates with 401 and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPatch({ loggingEnabled: true });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(upsertUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("persists loggingEnabled via PATCH and returns the updated setting", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    upsertUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const { res, json } = await callPatch({ loggingEnabled: true });
+    expect(res.status).toBe(200);
+    expect(json.loggingEnabled).toBe(true);
+    expect(json.persistenceAvailable).toBe(true);
+    expect(upsertUserSettings).toHaveBeenCalledWith({}, "user_123", true);
+  });
+});
+
diff --git a/src/app/api/user-settings/route.ts b/src/app/api/user-settings/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..370e41418b9539b44e9aaad5fc5f9405b260485b
--- /dev/null
+++ b/src/app/api/user-settings/route.ts
@@ -0,0 +1,77 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { getUserSettings, upsertUserSettings } from "@/lib/db/user-settings";
+
+export const runtime = "nodejs";
+
+const UpdateUserSettingsSchema = z.object({
+  loggingEnabled: z.boolean(),
+});
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function GET() {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { loggingEnabled: false, persistenceAvailable: false },
+      { status: 200, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const settings = await getUserSettings(db, userId);
+  return NextResponse.json(
+    { loggingEnabled: settings?.loggingEnabled ?? false, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
+export async function PATCH(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { error: "Persistence is disabled." },
+      { status: 503, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = UpdateUserSettingsSchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const updated = await upsertUserSettings(db, userId, parsed.data.loggingEnabled);
+  return NextResponse.json(
+    { loggingEnabled: updated?.loggingEnabled ?? parsed.data.loggingEnabled, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 9db92fbfddf12094c87fc753d64f71213afd6e34..c15ee53a0f7867aac39de17be6efd381c554ce0b
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -533,11 +533,13 @@
 export function BlacklistChecker() {
   const m = getMessages("en");
   const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
+  const { isLoaded: authLoaded, isSignedIn } = useAuth();
 
   const [address, setAddress] = React.useState("");
   const [validation, setValidation] = React.useState<ReturnType<typeof validateTronAddress> | null>(null);
   const [load, setLoad] = React.useState<LoadState>({ state: "idle" });
   const [loggingEnabled, setLoggingEnabled] = React.useState(false);
+  const fetchedServerLoggingPref = React.useRef(false);
 
   React.useEffect(() => {
     const handle = window.setTimeout(() => {
@@ -551,6 +553,35 @@
     setLoggingEnabled(readLocalLoggingPref());
   }, []);
 
+  React.useEffect(() => {
+    if (!clerkEnabled) return;
+    if (!authLoaded) return;
+    if (!isSignedIn) {
+      fetchedServerLoggingPref.current = false;
+      return;
+    }
+    if (fetchedServerLoggingPref.current) return;
+    fetchedServerLoggingPref.current = true;
+
+    const controller = new AbortController();
+    void (async () => {
+      try {
+        const res = await fetch("/api/user-settings", { method: "GET", credentials: "include", signal: controller.signal });
+        if (!res.ok) return;
+        const json = (await res.json()) as unknown;
+        if (!json || typeof json !== "object") return;
+        const v = (json as Record<string, unknown>).loggingEnabled;
+        if (typeof v !== "boolean") return;
+        setLoggingEnabled(v);
+        writeLocalLoggingPref(v);
+      } catch {
+        // ignore
+      }
+    })();
+
+    return () => controller.abort();
+  }, [clerkEnabled, authLoaded, isSignedIn]);
+
   const normalizedAddress = validation?.normalized ?? address.trim();
   const isValid = validation?.ok ?? false;
 
@@ -881,18 +912,18 @@
               transition={{ duration: 0.4, delay: 0.18 }}
               className="mx-auto mt-4 max-w-2xl"
             >
-              <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+                  <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
                 <CardHeader className="pb-3">
                   <CardTitle className="text-base">Account</CardTitle>
                   <CardDescription>
-                    Configure privacy defaults. Saving reports is not enabled yet (DB/credits work is next).
+                    Configure privacy defaults. Report saving is opt-in and controlled by this setting.
                   </CardDescription>
                 </CardHeader>
                 <CardContent className="flex items-start justify-between gap-4">
                   <div className="min-w-0">
                     <div className="text-sm font-medium text-foreground">Opt-in: save screening history</div>
                     <div className="mt-1 text-sm text-muted-foreground">
-                      This currently stores only a local preference. No server-side address logging is performed yet.
+                      This setting is saved to your account. Screening history persistence remains opt-in.
                     </div>
                   </div>
                   <Switch
@@ -900,7 +931,33 @@
                     onCheckedChange={(v) => {
                       setLoggingEnabled(v);
                       writeLocalLoggingPref(v);
-                      toast.message(v ? "Logging preference enabled (local only)" : "Logging preference disabled");
+
+                      void (async () => {
+                        try {
+                          const res = await fetch("/api/user-settings", {
+                            method: "PATCH",
+                            headers: { "content-type": "application/json" },
+                            credentials: "include",
+                            body: JSON.stringify({ loggingEnabled: v }),
+                          });
+
+                          if (!res.ok) throw new Error(`Request failed (${res.status}).`);
+                          const json = (await res.json()) as unknown;
+                          const value =
+                            json && typeof json === "object" ? (json as Record<string, unknown>).loggingEnabled : undefined;
+                          if (typeof value === "boolean") {
+                            setLoggingEnabled(value);
+                            writeLocalLoggingPref(value);
+                          }
+
+                          toast.message(v ? "Saving preference enabled" : "Saving preference disabled");
+                        } catch {
+                          const revert = !v;
+                          setLoggingEnabled(revert);
+                          writeLocalLoggingPref(revert);
+                          toast.message("Could not update preference. Please try again.");
+                        }
+                      })();
                     }}
                     aria-label="Enable saving screening history"
                   />

exec
/bin/zsh -lc 'git status --porcelain' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 66ms:
 M .ralph/activity.log
 M .ralph/runs/run-20260123-044356-6274-iter-4.log
file update:
diff --git a/middleware.ts b/middleware.ts
index 9009ef94a93548a37928fbb79db4d17573dde8b0..6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c
--- a/middleware.ts
+++ b/middleware.ts
@@ -7,6 +7,7 @@
   "/",
   "/api/check",
   "/api/analyze",
+  "/api/user-settings",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-user-settings.test.ts b/src/__tests__/api-user-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..206dc68b6524190c6007f00b602147edc7b72713
--- /dev/null
+++ b/src/__tests__/api-user-settings.test.ts
@@ -0,0 +1,82 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+const upsertUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings, upsertUserSettings }));
+
+async function callGet() {
+  const { GET } = await import("@/app/api/user-settings/route");
+  const res = await GET();
+  const json = await res.json();
+  return { res, json };
+}
+
+async function callPatch(body: unknown) {
+  const { PATCH } = await import("@/app/api/user-settings/route");
+  const req = new Request("http://localhost/api/user-settings", {
+    method: "PATCH",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await PATCH(req);
+  const json = await res.json();
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+});
+
+describe("/api/user-settings", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callGet();
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("returns loggingEnabled=false when no row exists (default)", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue(null);
+
+    const { res, json } = await callGet();
+    expect(res.status).toBe(200);
+    expect(json.loggingEnabled).toBe(false);
+    expect(json.persistenceAvailable).toBe(true);
+    expect(upsertUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("rejects unauthenticated updates with 401 and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPatch({ loggingEnabled: true });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(upsertUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("persists loggingEnabled via PATCH and returns the updated setting", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    upsertUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const { res, json } = await callPatch({ loggingEnabled: true });
+    expect(res.status).toBe(200);
+    expect(json.loggingEnabled).toBe(true);
+    expect(json.persistenceAvailable).toBe(true);
+    expect(upsertUserSettings).toHaveBeenCalledWith({}, "user_123", true);
+  });
+});
+
diff --git a/src/app/api/user-settings/route.ts b/src/app/api/user-settings/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..370e41418b9539b44e9aaad5fc5f9405b260485b
--- /dev/null
+++ b/src/app/api/user-settings/route.ts
@@ -0,0 +1,77 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { getUserSettings, upsertUserSettings } from "@/lib/db/user-settings";
+
+export const runtime = "nodejs";
+
+const UpdateUserSettingsSchema = z.object({
+  loggingEnabled: z.boolean(),
+});
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function GET() {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { loggingEnabled: false, persistenceAvailable: false },
+      { status: 200, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const settings = await getUserSettings(db, userId);
+  return NextResponse.json(
+    { loggingEnabled: settings?.loggingEnabled ?? false, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
+export async function PATCH(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { error: "Persistence is disabled." },
+      { status: 503, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = UpdateUserSettingsSchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const updated = await upsertUserSettings(db, userId, parsed.data.loggingEnabled);
+  return NextResponse.json(
+    { loggingEnabled: updated?.loggingEnabled ?? parsed.data.loggingEnabled, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 9db92fbfddf12094c87fc753d64f71213afd6e34..c15ee53a0f7867aac39de17be6efd381c554ce0b
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -533,11 +533,13 @@
 export function BlacklistChecker() {
   const m = getMessages("en");
   const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
+  const { isLoaded: authLoaded, isSignedIn } = useAuth();
 
   const [address, setAddress] = React.useState("");
   const [validation, setValidation] = React.useState<ReturnType<typeof validateTronAddress> | null>(null);
   const [load, setLoad] = React.useState<LoadState>({ state: "idle" });
   const [loggingEnabled, setLoggingEnabled] = React.useState(false);
+  const fetchedServerLoggingPref = React.useRef(false);
 
   React.useEffect(() => {
     const handle = window.setTimeout(() => {
@@ -551,6 +553,35 @@
     setLoggingEnabled(readLocalLoggingPref());
   }, []);
 
+  React.useEffect(() => {
+    if (!clerkEnabled) return;
+    if (!authLoaded) return;
+    if (!isSignedIn) {
+      fetchedServerLoggingPref.current = false;
+      return;
+    }
+    if (fetchedServerLoggingPref.current) return;
+    fetchedServerLoggingPref.current = true;
+
+    const controller = new AbortController();
+    void (async () => {
+      try {
+        const res = await fetch("/api/user-settings", { method: "GET", credentials: "include", signal: controller.signal });
+        if (!res.ok) return;
+        const json = (await res.json()) as unknown;
+        if (!json || typeof json !== "object") return;
+        const v = (json as Record<string, unknown>).loggingEnabled;
+        if (typeof v !== "boolean") return;
+        setLoggingEnabled(v);
+        writeLocalLoggingPref(v);
+      } catch {
+        // ignore
+      }
+    })();
+
+    return () => controller.abort();
+  }, [clerkEnabled, authLoaded, isSignedIn]);
+
   const normalizedAddress = validation?.normalized ?? address.trim();
   const isValid = validation?.ok ?? false;
 
@@ -881,18 +912,18 @@
               transition={{ duration: 0.4, delay: 0.18 }}
               className="mx-auto mt-4 max-w-2xl"
             >
-              <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+                  <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
                 <CardHeader className="pb-3">
                   <CardTitle className="text-base">Account</CardTitle>
                   <CardDescription>
-                    Configure privacy defaults. Saving reports is not enabled yet (DB/credits work is next).
+                    Configure privacy defaults. Report saving is opt-in and controlled by this setting.
                   </CardDescription>
                 </CardHeader>
                 <CardContent className="flex items-start justify-between gap-4">
                   <div className="min-w-0">
                     <div className="text-sm font-medium text-foreground">Opt-in: save screening history</div>
                     <div className="mt-1 text-sm text-muted-foreground">
-                      This currently stores only a local preference. No server-side address logging is performed yet.
+                      This setting is saved to your account. Screening history persistence remains opt-in.
                     </div>
                   </div>
                   <Switch
@@ -900,7 +931,33 @@
                     onCheckedChange={(v) => {
                       setLoggingEnabled(v);
                       writeLocalLoggingPref(v);
-                      toast.message(v ? "Logging preference enabled (local only)" : "Logging preference disabled");
+
+                      void (async () => {
+                        try {
+                          const res = await fetch("/api/user-settings", {
+                            method: "PATCH",
+                            headers: { "content-type": "application/json" },
+                            credentials: "include",
+                            body: JSON.stringify({ loggingEnabled: v }),
+                          });
+
+                          if (!res.ok) throw new Error(`Request failed (${res.status}).`);
+                          const json = (await res.json()) as unknown;
+                          const value =
+                            json && typeof json === "object" ? (json as Record<string, unknown>).loggingEnabled : undefined;
+                          if (typeof value === "boolean") {
+                            setLoggingEnabled(value);
+                            writeLocalLoggingPref(value);
+                          }
+
+                          toast.message(v ? "Saving preference enabled" : "Saving preference disabled");
+                        } catch {
+                          const revert = !v;
+                          setLoggingEnabled(revert);
+                          writeLocalLoggingPref(revert);
+                          toast.message("Could not update preference. Please try again.");
+                        }
+                      })();
                     }}
                     aria-label="Enable saving screening history"
                   />


thinking
**Considering commit cleanliness**

I'm noticing that my activity log and iter-4.log changed after the last commit, so I'm not in a clean state. Step 10 required me to have a clean state after the commit, which seems to mean I need to either stage the changes or amend the current commit. To achieve that cleanliness, I might need to amend now and then recheck my status. I'll also capture the commit hash later for step 10. It looks like those logs were modified after the commit, so I should probably stage and include them by amending.
exec
/bin/zsh -lc 'git diff -- .ralph/activity.log | tail -n 40' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 59ms:
diff --git a/.ralph/activity.log b/.ralph/activity.log
index 1ff920c..3c7a9e3 100644
--- a/.ralph/activity.log
+++ b/.ralph/activity.log
@@ -40,3 +40,4 @@
 [2026-01-23 05:35:00] Added route-level tests for /api/user-settings auth + default + update behavior
 [2026-01-23 05:35:13] Running quality gates: pnpm lint, pnpm test, pnpm build
 [2026-01-23 05:35:48] Quality gates complete: lint/test/build PASS
+[2026-01-23 05:37:35] Committing US-004 changes
exec
/bin/zsh -lc 'git diff -- .ralph/runs/run-20260123-044356-6274-iter-4.log | tail -n 40' in /Users/chiko/side_projects/usdt_blacklisted_web succeeded in 68ms:
++                          if (!res.ok) throw new Error(`Request failed (${res.status}).`);
++                          const json = (await res.json()) as unknown;
++                          const value =
++                            json && typeof json === "object" ? (json as Record<string, unknown>).loggingEnabled : undefined;
++                          if (typeof value === "boolean") {
++                            setLoggingEnabled(value);
++                            writeLocalLoggingPref(value);
++                          }
++
++                          toast.message(v ? "Saving preference enabled" : "Saving preference disabled");
++                        } catch {
++                          const revert = !v;
++                          setLoggingEnabled(revert);
++                          writeLocalLoggingPref(revert);
++                          toast.message("Could not update preference. Please try again.");
++                        }
++                      })();
+                     }}
+                     aria-label="Enable saving screening history"
+                   />
file update:
diff --git a/middleware.ts b/middleware.ts
index 9009ef94a93548a37928fbb79db4d17573dde8b0..6afe8fd735fffcb1db9a3c5accbf9ce8ec21ce4c
--- a/middleware.ts
+++ b/middleware.ts
@@ -7,6 +7,7 @@
   "/",
   "/api/check",
   "/api/analyze",
+  "/api/user-settings",
   "/sign-in(.*)",
   "/sign-up(.*)",
 ]);
diff --git a/src/__tests__/api-user-settings.test.ts b/src/__tests__/api-user-settings.test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..206dc68b6524190c6007f00b602147edc7b72713
--- /dev/null
+++ b/src/__tests__/api-user-settings.test.ts
@@ -0,0 +1,82 @@
+import { beforeEach, describe, expect, it, vi } from "vitest";
+
+const auth = vi.fn();
+vi.mock("@clerk/nextjs/server", () => ({ auth }));
+
+const getDb = vi.fn();
+vi.mock("@/lib/db", () => ({ getDb }));
+
+const getUserSettings = vi.fn();
+const upsertUserSettings = vi.fn();
+vi.mock("@/lib/db/user-settings", () => ({ getUserSettings, upsertUserSettings }));
+
+async function callGet() {
+  const { GET } = await import("@/app/api/user-settings/route");
+  const res = await GET();
+  const json = await res.json();
+  return { res, json };
+}
+
+async function callPatch(body: unknown) {
+  const { PATCH } = await import("@/app/api/user-settings/route");
+  const req = new Request("http://localhost/api/user-settings", {
+    method: "PATCH",
+    headers: { "content-type": "application/json" },
+    body: JSON.stringify(body),
+  });
+  const res = await PATCH(req);
+  const json = await res.json();
+  return { res, json };
+}
+
+beforeEach(() => {
+  vi.resetModules();
+  vi.clearAllMocks();
+  process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY = "pk_test_123";
+  process.env.CLERK_SECRET_KEY = "sk_test_123";
+});
+
+describe("/api/user-settings", () => {
+  it("returns 401 when unauthenticated and does not touch the DB", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callGet();
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(getUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("returns loggingEnabled=false when no row exists (default)", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    getUserSettings.mockResolvedValue(null);
+
+    const { res, json } = await callGet();
+    expect(res.status).toBe(200);
+    expect(json.loggingEnabled).toBe(false);
+    expect(json.persistenceAvailable).toBe(true);
+    expect(upsertUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("rejects unauthenticated updates with 401 and does not create rows", async () => {
+    auth.mockResolvedValue({ userId: null });
+
+    const { res } = await callPatch({ loggingEnabled: true });
+    expect(res.status).toBe(401);
+    expect(getDb).not.toHaveBeenCalled();
+    expect(upsertUserSettings).not.toHaveBeenCalled();
+  });
+
+  it("persists loggingEnabled via PATCH and returns the updated setting", async () => {
+    auth.mockResolvedValue({ userId: "user_123" });
+    getDb.mockReturnValue({});
+    upsertUserSettings.mockResolvedValue({ loggingEnabled: true });
+
+    const { res, json } = await callPatch({ loggingEnabled: true });
+    expect(res.status).toBe(200);
+    expect(json.loggingEnabled).toBe(true);
+    expect(json.persistenceAvailable).toBe(true);
+    expect(upsertUserSettings).toHaveBeenCalledWith({}, "user_123", true);
+  });
+});
+
diff --git a/src/app/api/user-settings/route.ts b/src/app/api/user-settings/route.ts
new file mode 100644
index 0000000000000000000000000000000000000000..370e41418b9539b44e9aaad5fc5f9405b260485b
--- /dev/null
+++ b/src/app/api/user-settings/route.ts
@@ -0,0 +1,77 @@
+import { NextResponse } from "next/server";
+import { auth } from "@clerk/nextjs/server";
+import { z } from "zod";
+
+import { getDb } from "@/lib/db";
+import { getUserSettings, upsertUserSettings } from "@/lib/db/user-settings";
+
+export const runtime = "nodejs";
+
+const UpdateUserSettingsSchema = z.object({
+  loggingEnabled: z.boolean(),
+});
+
+async function getAuthenticatedUserId(): Promise<string | null> {
+  if (!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || !process.env.CLERK_SECRET_KEY) return null;
+  try {
+    const { userId } = await auth();
+    return userId ?? null;
+  } catch {
+    return null;
+  }
+}
+
+export async function GET() {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { loggingEnabled: false, persistenceAvailable: false },
+      { status: 200, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  const settings = await getUserSettings(db, userId);
+  return NextResponse.json(
+    { loggingEnabled: settings?.loggingEnabled ?? false, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
+export async function PATCH(request: Request) {
+  const userId = await getAuthenticatedUserId();
+  if (!userId) {
+    return NextResponse.json({ error: "Unauthorized." }, { status: 401, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const db = getDb();
+  if (!db) {
+    return NextResponse.json(
+      { error: "Persistence is disabled." },
+      { status: 503, headers: { "Cache-Control": "no-store" } },
+    );
+  }
+
+  let json: unknown;
+  try {
+    json = await request.json();
+  } catch {
+    return NextResponse.json({ error: "Invalid JSON body." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const parsed = UpdateUserSettingsSchema.safeParse(json);
+  if (!parsed.success) {
+    return NextResponse.json({ error: "Invalid request." }, { status: 400, headers: { "Cache-Control": "no-store" } });
+  }
+
+  const updated = await upsertUserSettings(db, userId, parsed.data.loggingEnabled);
+  return NextResponse.json(
+    { loggingEnabled: updated?.loggingEnabled ?? parsed.data.loggingEnabled, persistenceAvailable: true },
+    { status: 200, headers: { "Cache-Control": "no-store" } },
+  );
+}
+
diff --git a/src/components/blacklist-checker.tsx b/src/components/blacklist-checker.tsx
index 9db92fbfddf12094c87fc753d64f71213afd6e34..c15ee53a0f7867aac39de17be6efd381c554ce0b
--- a/src/components/blacklist-checker.tsx
+++ b/src/components/blacklist-checker.tsx
@@ -533,11 +533,13 @@
 export function BlacklistChecker() {
   const m = getMessages("en");
   const clerkEnabled = Boolean(process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY);
+  const { isLoaded: authLoaded, isSignedIn } = useAuth();
 
   const [address, setAddress] = React.useState("");
   const [validation, setValidation] = React.useState<ReturnType<typeof validateTronAddress> | null>(null);
   const [load, setLoad] = React.useState<LoadState>({ state: "idle" });
   const [loggingEnabled, setLoggingEnabled] = React.useState(false);
+  const fetchedServerLoggingPref = React.useRef(false);
 
   React.useEffect(() => {
     const handle = window.setTimeout(() => {
@@ -551,6 +553,35 @@
     setLoggingEnabled(readLocalLoggingPref());
   }, []);
 
+  React.useEffect(() => {
+    if (!clerkEnabled) return;
+    if (!authLoaded) return;
+    if (!isSignedIn) {
+      fetchedServerLoggingPref.current = false;
+      return;
+    }
+    if (fetchedServerLoggingPref.current) return;
+    fetchedServerLoggingPref.current = true;
+
+    const controller = new AbortController();
+    void (async () => {
+      try {
+        const res = await fetch("/api/user-settings", { method: "GET", credentials: "include", signal: controller.signal });
+        if (!res.ok) return;
+        const json = (await res.json()) as unknown;
+        if (!json || typeof json !== "object") return;
+        const v = (json as Record<string, unknown>).loggingEnabled;
+        if (typeof v !== "boolean") return;
+        setLoggingEnabled(v);
+        writeLocalLoggingPref(v);
+      } catch {
+        // ignore
+      }
+    })();
+
+    return () => controller.abort();
+  }, [clerkEnabled, authLoaded, isSignedIn]);
+
   const normalizedAddress = validation?.normalized ?? address.trim();
   const isValid = validation?.ok ?? false;
 
@@ -881,18 +912,18 @@
               transition={{ duration: 0.4, delay: 0.18 }}
               className="mx-auto mt-4 max-w-2xl"
             >
-              <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
+                  <Card className="border-border/60 bg-card/80 backdrop-blur-sm">
                 <CardHeader className="pb-3">
                   <CardTitle className="text-base">Account</CardTitle>
                   <CardDescription>
-                    Configure privacy defaults. Saving reports is not enabled yet (DB/credits work is next).
+                    Configure privacy defaults. Report saving is opt-in and controlled by this setting.
                   </CardDescription>
                 </CardHeader>
                 <CardContent className="flex items-start justify-between gap-4">
                   <div className="min-w-0">
                     <div className="text-sm font-medium text-foreground">Opt-in: save screening history</div>
                     <div className="mt-1 text-sm text-muted-foreground">
-                      This currently stores only a local preference. No server-side address logging is performed yet.
+                      This setting is saved to your account. Screening history persistence remains opt-in.
                     </div>
                   </div>
                   <Switch
@@ -900,7 +931,33 @@
                     onCheckedChange={(v) => {
                       setLoggingEnabled(v);
                       writeLocalLoggingPref(v);
-                      toast.message(v ? "Logging preference enabled (local only)" : "Logging preference disabled");
+
+                      void (async () => {
+                        try {
+                          const res = await fetch("/api/user-settings", {
+                            method: "PATCH",
+                            headers: { "content-type": "application/json" },
+                            credentials: "include",
+                            body: JSON.stringify({ loggingEnabled: v }),
+                          });
+
+                          if (!res.ok) throw new Error(`Request failed (${res.status}).`);
+                          const json = (await res.json()) as unknown;
+                          const value =
+                            json && typeof json === "object" ? (json as Record<string, unknown>).loggingEnabled : undefined;
+                          if (typeof value === "boolean") {
+                            setLoggingEnabled(value);
+                            writeLocalLoggingPref(value);
+                          }
+
+                          toast.message(v ? "Saving preference enabled" : "Saving preference disabled");
+                        } catch {
+                          const revert = !v;
+                          setLoggingEnabled(revert);
+                          writeLocalLoggingPref(revert);
+                          toast.message("Could not update preference. Please try again.");
+                        }
+                      })();
                     }}
                     aria-label="Enable saving screening history"
                   />

exec
/bin/zsh -lc 'git add .ralph/activity.log .ralph/runs/run-20260123-044356-6274-iter-4.log && git commit --amend --no-edit' in /Users/chiko/side_projects/usdt_blacklisted_web